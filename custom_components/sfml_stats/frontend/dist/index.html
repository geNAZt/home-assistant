<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SFML STATS Dashboard by Zara</title>

    <!-- ECharts for Charts -->
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>

    <!-- Vue 3 -->
    <script src="https://cdn.jsdelivr.net/npm/vue@3.4.21/dist/vue.global.prod.js"></script>

    <!-- SortableJS for drag & drop -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>

    <!-- External CSS (modularized) -->
    <link rel="stylesheet" href="/api/sfml_stats/assets/css/main.css">
</head>
<body>
    <!-- Toast Notification Container -->
    <div id="toast-container" class="toast-container"></div>

    <!-- Hold-to-Drag Progress Indicator (Mobile) -->
    <div id="drag-hold-indicator" class="drag-hold-indicator">
        <svg viewBox="0 0 44 44">
            <circle class="progress-ring-bg" cx="22" cy="22" r="20"/>
            <circle class="progress-ring-fill" cx="22" cy="22" r="20"/>
        </svg>
        <span class="hold-icon">‚ú•</span>
    </div>

    <div id="app">
        <header class="header">
            <h1>SFML STATS Dashboard by Zara</h1>
            <div class="header-controls">
                <button @click="toggleDashboardStyle" class="style-toggle" :class="{'active-3d': dashboardStyle === '3d', 'active-2d': dashboardStyle === '2d', 'active-list': dashboardStyle === 'list'}" :title="dashboardStyle === '3d' ? 'Zu 2D wechseln' : dashboardStyle === '2d' ? 'Zur Liste wechseln' : 'Zu 3D wechseln'">
                    <span class="style-toggle-icon">{{ getDashboardStyleIcon() }}</span>
                    <span>{{ getDashboardStyleLabel() }}</span>
                </button>
                <button @click="goToLcars" class="lcars-toggle" title="LCARS Interface (Star Trek)">
                    <span>üññ</span>
                    <span>LCARS</span>
                </button>
                <button @click="toggleTheme" class="theme-toggle" :title="isDarkTheme ? 'Zu Hell wechseln' : 'Zu Dunkel wechseln'">
                    {{ isDarkTheme ? '‚òÄÔ∏è' : 'üåô' }}
                </button>
                <button @click="resetSectionOrder" class="reset-order-btn" title="Sortierung zur√ºcksetzen">
                    ‚Ü∫
                </button>
                <span><span class="status-dot"></span>Live</span>
                <span style="color: var(--text-muted)">{{ lastUpdate }}</span>
            </div>
        </header>

        <main class="main-content sortable-sections" ref="sortableContainer">
            <!-- Top Row: Weather Groups, Forecast, Yield, Price -->
            <section class="top-row sortable-item" data-section="weather">
                <!-- Gruppe 1: IST + KI-Korrigiert -->
                <div class="widget-group-container">
                    <span class="widget-group-label">üõ∞Ô∏è Sensoren-Array</span>
                    <!-- Weather Widget: IST (Sensoren) - CLICKABLE -->
                    <div class="weather-widget clickable" @click="openWeatherModal" style="border-color: #10b981; cursor: pointer;">
                        <div class="weather-main">
                            <div class="weather-icon">{{ weatherIcon }}</div>
                            <div>
                                <div class="weather-temp">{{ weather.temperature?.toFixed(1) || '‚Äî' }}¬∞C</div>
                                <div style="color: var(--text-muted); font-size: 0.8rem;">IST (Sensoren)</div>
                            </div>
                        </div>
                        <div class="weather-details">
                            <div class="weather-detail"><span>‚òÄÔ∏è</span><span>{{ weather.radiation?.toFixed(0) || '0' }} W/m¬≤</span></div>
                            <div class="weather-detail"><span>üíß</span><span>{{ weather.humidity?.toFixed(0) || '‚Äî' }}%</span></div>
                            <div class="weather-detail"><span>üå¨Ô∏è</span><span>{{ weather.wind?.toFixed(1) || '‚Äî' }} km/h</span></div>
                            <div class="weather-detail"><span>‚òÅÔ∏è</span><span>{{ weather.clouds?.toFixed(0) || '‚Äî' }}%</span></div>
                        </div>
                    </div>

                    <!-- Weather Widget: KI-Korrigiert - CLICKABLE -->
                    <div class="weather-widget clickable" @click="openWeatherModal" style="border-color: #8b5cf6; cursor: pointer;">
                        <div class="weather-main">
                            <div class="weather-icon">ü§ñ</div>
                            <div>
                                <div class="weather-temp" style="color: #8b5cf6;">{{ weatherCorrected.temperature?.toFixed(1) || '‚Äî' }}¬∞C</div>
                                <div style="color: var(--text-muted); font-size: 0.8rem;">KI-Korrigiert</div>
                            </div>
                        </div>
                        <div class="weather-details">
                            <div class="weather-detail"><span>‚òÄÔ∏è</span><span>{{ weatherCorrected.radiation?.toFixed(0) || '0' }} W/m¬≤</span></div>
                            <div class="weather-detail"><span>üíß</span><span>{{ weatherCorrected.humidity?.toFixed(0) || '‚Äî' }}%</span></div>
                            <div class="weather-detail"><span>üå¨Ô∏è</span><span>{{ weatherCorrected.wind?.toFixed(1) || '‚Äî' }} km/h</span></div>
                            <div class="weather-detail"><span>‚òÅÔ∏è</span><span>{{ weatherCorrected.clouds?.toFixed(0) || '‚Äî' }}%</span></div>
                        </div>
                    </div>
                </div>

                <!-- Gruppe 2: HA Wetter + Sonne -->
                <div class="widget-group-container">
                    <span class="widget-group-label">üññ Au√üenmission</span>
                    <!-- Weather Widget: HA Integration -->
                    <div class="weather-widget" style="border-color: #3b82f6;">
                        <div class="weather-main">
                            <div class="weather-icon">{{ weatherHAIcon }}</div>
                            <div>
                                <div class="weather-temp" style="color: #3b82f6;">{{ weatherHA.temperature?.toFixed(1) || '‚Äî' }}¬∞C</div>
                                <div style="color: var(--text-muted); font-size: 0.8rem;">HA Wetter</div>
                            </div>
                        </div>
                        <div class="weather-details">
                            <div class="weather-detail"><span>üìç</span><span>{{ weatherHA.state || '‚Äî' }}</span></div>
                            <div class="weather-detail"><span>üíß</span><span>{{ weatherHA.humidity?.toFixed(0) || '‚Äî' }}%</span></div>
                            <div class="weather-detail"><span>üå¨Ô∏è</span><span>{{ weatherHA.wind_speed?.toFixed(1) || '‚Äî' }} km/h</span></div>
                            <div class="weather-detail"><span>‚òÅÔ∏è</span><span>{{ weatherHA.cloud_coverage?.toFixed(0) || '‚Äî' }}%</span></div>
                        </div>
                    </div>

                    <!-- Clothing Recommendation Widget -->
                    <div class="weather-widget clickable" @click="openClothingModal" style="border-color: #ec4899; cursor: pointer;">
                        <div class="weather-main">
                            <div class="weather-icon">üññ</div>
                            <div>
                                <div class="weather-temp" style="color: #ec4899;">Au√üenteam</div>
                                <div style="color: var(--text-muted); font-size: 0.8rem;">Ausr√ºstung</div>
                            </div>
                        </div>
                        <div class="weather-details">
                            <div class="weather-detail"><span>üå°Ô∏è</span><span>{{ weather.temperature?.toFixed(0) || '‚Äî' }}¬∞C</span></div>
                            <div class="weather-detail"><span>üí®</span><span>{{ weather.wind?.toFixed(1) || '‚Äî' }} km/h</span></div>
                            <div class="weather-detail"><span>üíß</span><span>{{ weather.humidity?.toFixed(0) || '‚Äî' }}%</span></div>
                            <div class="weather-detail"><span>‚òÅÔ∏è</span><span>{{ weather.clouds?.toFixed(0) || '‚Äî' }}%</span></div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Energy Flow Diagram -->
            <section class="energy-flow-container collapsible-section sortable-item" data-section="energyMatrix">
                <div class="energy-flow-header">
                    <div>
                        <div class="energy-flow-title">‚ö° Energie-Matrix</div>
                        <div class="energy-flow-subtitle">Echtzeit-Leistungsverteilung ‚Ä¢ Warp-Kern Status</div>
                    </div>
                    <div class="energy-flow-stats">
                        <!-- Prognose heute -->
                        <div>
                            <div style="font-size: 0.7rem; color: var(--text-muted);">üìä Prognose heute</div>
                            <div style="font-size: 0.95rem; font-weight: 600; color: var(--neon-purple);">
                                {{ forecast.todayTotal?.toFixed(2) || '‚Äî' }} kWh
                            </div>
                            <div style="font-size: 0.7rem; color: var(--text-dark);">Rest: {{ forecast.todayRemaining?.toFixed(2) || '‚Äî' }} kWh</div>
                        </div>
                        <!-- Tagesertrag -->
                        <div>
                            <div style="font-size: 0.7rem; color: var(--text-muted);">‚òÄÔ∏è Tagesertrag</div>
                            <div style="font-size: 0.95rem; font-weight: 600; color: var(--neon-green);">
                                {{ energyFlow.statistics.solar_yield_daily?.toFixed(2) || '‚Äî' }} kWh
                            </div>
                            <div style="font-size: 0.7rem; color: var(--text-dark);">Peak: {{ stats.peaks.today?.power_w?.toFixed(0) || '‚Äî' }} W</div>
                        </div>
                        <!-- Beste Stunde (Prognose) -->
                        <div>
                            <div style="font-size: 0.7rem; color: var(--text-muted);">üèÜ Beste Stunde</div>
                            <div style="font-size: 0.95rem; font-weight: 600; color: var(--neon-yellow);">
                                {{ bestHour.hour !== null ? bestHour.hour + ':00' : '‚Äî' }}
                            </div>
                            <div style="font-size: 0.7rem; color: var(--text-dark);">{{ bestHour.prediction_kwh?.toFixed(2) || '‚Äî' }} kWh</div>
                        </div>
                    </div>
                    <button class="section-collapse-btn" @click="toggleSection('energyFlow')" :title="isSectionCollapsed('energyFlow') ? 'Ausklappen' : 'Einklappen'">
                        {{ isSectionCollapsed('energyFlow') ? '+' : '‚àí' }}
                    </button>
                </div>

                <!-- ========== ISOMETRIC 3D ENERGY FLOW DIAGRAM ========== -->
                <svg v-show="!isSectionCollapsed('energyFlow') && dashboardStyle === '3d'" class="isometric-energy-flow" viewBox="0 0 900 520" preserveAspectRatio="xMidYMid meet">
                    <!-- ========== DAY/NIGHT SKY EFFECTS ========== -->

                    <!-- NIGHT MODE: Twinkling Stars -->
                    <g v-if="isNightTime" class="night-sky">
                        <!-- Large bright stars -->
                        <circle cx="50" cy="30" r="2" fill="#ffffff" class="star star-twinkle-1"/>
                        <circle cx="150" cy="60" r="1.5" fill="#ffffff" class="star star-twinkle-2"/>
                        <circle cx="280" cy="25" r="2.5" fill="#ffffff" class="star star-twinkle-3"/>
                        <circle cx="420" cy="45" r="1.8" fill="#ffffff" class="star star-twinkle-1"/>
                        <circle cx="550" cy="20" r="2" fill="#ffffff" class="star star-twinkle-2"/>
                        <circle cx="680" cy="55" r="2.2" fill="#ffffff" class="star star-twinkle-3"/>
                        <circle cx="800" cy="35" r="1.5" fill="#ffffff" class="star star-twinkle-1"/>
                        <circle cx="850" cy="70" r="2" fill="#ffffff" class="star star-twinkle-2"/>

                        <!-- Medium stars -->
                        <circle cx="100" cy="80" r="1.2" fill="#c0c0ff" class="star star-twinkle-2"/>
                        <circle cx="200" cy="40" r="1" fill="#c0c0ff" class="star star-twinkle-3"/>
                        <circle cx="350" cy="70" r="1.3" fill="#c0c0ff" class="star star-twinkle-1"/>
                        <circle cx="500" cy="50" r="1" fill="#c0c0ff" class="star star-twinkle-2"/>
                        <circle cx="620" cy="30" r="1.2" fill="#c0c0ff" class="star star-twinkle-3"/>
                        <circle cx="750" cy="65" r="1" fill="#c0c0ff" class="star star-twinkle-1"/>

                        <!-- Small distant stars -->
                        <circle cx="75" cy="50" r="0.8" fill="#8080ff" class="star star-twinkle-3"/>
                        <circle cx="180" cy="85" r="0.6" fill="#8080ff" class="star star-twinkle-1"/>
                        <circle cx="320" cy="35" r="0.7" fill="#8080ff" class="star star-twinkle-2"/>
                        <circle cx="460" cy="75" r="0.8" fill="#8080ff" class="star star-twinkle-3"/>
                        <circle cx="580" cy="40" r="0.6" fill="#8080ff" class="star star-twinkle-1"/>
                        <circle cx="720" cy="80" r="0.7" fill="#8080ff" class="star star-twinkle-2"/>
                        <circle cx="820" cy="45" r="0.8" fill="#8080ff" class="star star-twinkle-3"/>

                        <!-- Moon (Crescent) - Glow layer -->
                        <path d="M780,30 A30,30 0 1,1 780,90 A22,22 0 1,0 780,30 Z"
                              fill="#fffacd" opacity="0.3" filter="url(#glowCyan)"/>
                        <!-- Moon (Crescent) - Main body -->
                        <path d="M780,35 A25,25 0 1,1 780,85 A18,18 0 1,0 780,35 Z"
                              fill="#fffacd" opacity="1"/>
                        <!-- Moon highlights -->
                        <path d="M780,40 A23,23 0 0,1 780,80 A16,16 0 0,0 780,40 Z"
                              fill="#fff" opacity="0.3"/>
                    </g>

                    <!-- DAY MODE: Sun with rays -->
                    <g v-else class="day-sky">
                        <!-- Sun glow -->
                        <circle cx="820" cy="60" r="50" fill="url(#sunGlowGrad)" class="sun-glow" opacity="0.4"/>
                        <!-- Sun body -->
                        <circle cx="820" cy="60" r="30" fill="#ffd60a" class="sun-body" filter="url(#glowYellow)"/>
                        <!-- Sun inner -->
                        <circle cx="820" cy="60" r="22" fill="#ffeb3b"/>
                        <!-- Sun rays -->
                        <g class="sun-rays">
                            <line x1="820" y1="15" x2="820" y2="0" stroke="#ffd60a" stroke-width="3" stroke-linecap="round" opacity="0.8"/>
                            <line x1="820" y1="105" x2="820" y2="120" stroke="#ffd60a" stroke-width="3" stroke-linecap="round" opacity="0.8"/>
                            <line x1="775" y1="60" x2="760" y2="60" stroke="#ffd60a" stroke-width="3" stroke-linecap="round" opacity="0.8"/>
                            <line x1="865" y1="60" x2="880" y2="60" stroke="#ffd60a" stroke-width="3" stroke-linecap="round" opacity="0.8"/>
                            <line x1="788" y1="28" x2="778" y2="18" stroke="#ffd60a" stroke-width="2.5" stroke-linecap="round" opacity="0.6"/>
                            <line x1="852" y1="92" x2="862" y2="102" stroke="#ffd60a" stroke-width="2.5" stroke-linecap="round" opacity="0.6"/>
                            <line x1="788" y1="92" x2="778" y2="102" stroke="#ffd60a" stroke-width="2.5" stroke-linecap="round" opacity="0.6"/>
                            <line x1="852" y1="28" x2="862" y2="18" stroke="#ffd60a" stroke-width="2.5" stroke-linecap="round" opacity="0.6"/>
                        </g>
                    </g>

                    <defs>
                        <!-- Sun glow gradient -->
                        <radialGradient id="sunGlowGrad" cx="50%" cy="50%" r="50%">
                            <stop offset="0%" stop-color="#ffd60a" stop-opacity="0.8"/>
                            <stop offset="50%" stop-color="#ff9500" stop-opacity="0.3"/>
                            <stop offset="100%" stop-color="#ff9500" stop-opacity="0"/>
                        </radialGradient>
                        <!-- Gradients for 3D effects -->
                        <linearGradient id="platformGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" stop-color="#1a2744"/>
                            <stop offset="50%" stop-color="#0d1a2d"/>
                            <stop offset="100%" stop-color="#061220"/>
                        </linearGradient>
                        <linearGradient id="platformEdgeGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" stop-color="#00d4ff" stop-opacity="0.6"/>
                            <stop offset="100%" stop-color="#00d4ff" stop-opacity="0.1"/>
                        </linearGradient>
                        <linearGradient id="houseWallGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" stop-color="#2a4a6a"/>
                            <stop offset="100%" stop-color="#1a3050"/>
                        </linearGradient>
                        <linearGradient id="houseRoofGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" stop-color="#4a7090"/>
                            <stop offset="100%" stop-color="#2a5070"/>
                        </linearGradient>
                        <linearGradient id="solarPanelGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" stop-color="#1a3a5a"/>
                            <stop offset="50%" stop-color="#0a2540"/>
                            <stop offset="100%" stop-color="#1a4a6a"/>
                        </linearGradient>
                        <linearGradient id="batteryGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" stop-color="#1a4a3a"/>
                            <stop offset="100%" stop-color="#0a2a20"/>
                        </linearGradient>
                        <linearGradient id="batteryFillGrad" x1="0%" y1="100%" x2="0%" y2="0%">
                            <stop offset="0%" stop-color="#22c55e"/>
                            <stop offset="100%" stop-color="#4ade80"/>
                        </linearGradient>
                        <!-- Reactor plasma gradients -->
                        <linearGradient id="reactorPlasmaGreen" x1="0%" y1="100%" x2="0%" y2="0%">
                            <stop offset="0%" stop-color="#22c55e"/>
                            <stop offset="50%" stop-color="#4ade80"/>
                            <stop offset="100%" stop-color="#86efac"/>
                        </linearGradient>
                        <linearGradient id="reactorPlasmaGold" x1="0%" y1="100%" x2="0%" y2="0%">
                            <stop offset="0%" stop-color="#b45309"/>
                            <stop offset="50%" stop-color="#fbbf24"/>
                            <stop offset="100%" stop-color="#fde68a"/>
                        </linearGradient>
                        <linearGradient id="reactorPlasmaGray" x1="0%" y1="100%" x2="0%" y2="0%">
                            <stop offset="0%" stop-color="#475569"/>
                            <stop offset="50%" stop-color="#64748b"/>
                            <stop offset="100%" stop-color="#94a3b8"/>
                        </linearGradient>
                        <!-- Portal plasma gradients -->
                        <linearGradient id="portalPlasmaImport" x1="0%" y1="100%" x2="0%" y2="0%">
                            <stop offset="0%" stop-color="#9d174d"/>
                            <stop offset="50%" stop-color="#ff2e97"/>
                            <stop offset="100%" stop-color="#ff8ed4"/>
                        </linearGradient>
                        <linearGradient id="portalPlasmaExport" x1="0%" y1="100%" x2="0%" y2="0%">
                            <stop offset="0%" stop-color="#0e7490"/>
                            <stop offset="50%" stop-color="#00ffff"/>
                            <stop offset="100%" stop-color="#a5f3fc"/>
                        </linearGradient>
                        <linearGradient id="portalPlasmaIdle" x1="0%" y1="100%" x2="0%" y2="0%">
                            <stop offset="0%" stop-color="#4c1d95"/>
                            <stop offset="50%" stop-color="#8b5cf6"/>
                            <stop offset="100%" stop-color="#c4b5fd"/>
                        </linearGradient>
                        <linearGradient id="gridBoxGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" stop-color="#3a2a5a"/>
                            <stop offset="100%" stop-color="#2a1a4a"/>
                        </linearGradient>

                        <!-- Glow Filters -->
                        <filter id="glowCyan" x="-50%" y="-50%" width="200%" height="200%">
                            <feGaussianBlur stdDeviation="4" result="blur"/>
                            <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
                        </filter>
                        <filter id="glowYellow" x="-50%" y="-50%" width="200%" height="200%">
                            <feGaussianBlur stdDeviation="3" result="blur"/>
                            <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
                        </filter>
                        <filter id="glowGreen" x="-50%" y="-50%" width="200%" height="200%">
                            <feGaussianBlur stdDeviation="3" result="blur"/>
                            <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
                        </filter>
                        <filter id="glowPurple" x="-50%" y="-50%" width="200%" height="200%">
                            <feGaussianBlur stdDeviation="3" result="blur"/>
                            <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
                        </filter>
                        <filter id="shadowFilter" x="-20%" y="-20%" width="140%" height="140%">
                            <feDropShadow dx="2" dy="4" stdDeviation="3" flood-color="#000" flood-opacity="0.5"/>
                        </filter>
                    </defs>

                    <!-- Platform removed as per user request -->

                    <!-- Title removed per user request for cleaner cyberpunk aesthetic -->

                    <!-- ========== ISOMETRIC HOUSE (Top Center - Triangle Layout) ========== -->
                    <g class="iso-house iso-element-clickable" @click="openHouseModal" transform="translate(390, 50) scale(1.4)">
                        <!-- House shadow -->
                        <ellipse cx="40" cy="120" rx="70" ry="20" fill="#000" opacity="0.3"/>

                        <!-- House base/walls - Left wall -->
                        <polygon points="0,60 0,120 60,150 60,90" fill="url(#houseWallGrad)" stroke="#00d4ff" stroke-width="1" opacity="0.9"/>
                        <!-- House base/walls - Right wall -->
                        <polygon points="60,90 60,150 120,120 120,60" fill="#1a3a5a" stroke="#00d4ff" stroke-width="1" opacity="0.9"/>
                        <!-- House base/walls - Top -->
                        <polygon points="0,60 60,30 120,60 60,90" fill="url(#houseRoofGrad)" stroke="#00d4ff" stroke-width="1"/>

                        <!-- Roof - Left side -->
                        <polygon points="60,0 -10,50 60,80 60,0" fill="#3a5a7a" stroke="#00d4ff" stroke-width="1"/>
                        <!-- Roof - Right side -->
                        <polygon points="60,0 130,50 60,80 60,0" fill="#2a4a6a" stroke="#00d4ff" stroke-width="1"/>

                        <!-- Chimney -->
                        <polygon points="85,15 85,40 100,32 100,7" fill="#4a6a8a" stroke="#00d4ff" stroke-width="0.5"/>
                        <polygon points="85,15 100,7 105,10 90,18" fill="#5a7a9a" stroke="#00d4ff" stroke-width="0.5"/>

                        <!-- Windows - Left wall -->
                        <rect x="10" y="75" width="20" height="25" fill="rgba(0, 212, 255, 0.3)" stroke="#00d4ff" stroke-width="1" transform="skewY(26.5)"/>
                        <rect x="35" y="75" width="15" height="25" fill="rgba(0, 212, 255, 0.3)" stroke="#00d4ff" stroke-width="1" transform="skewY(26.5)"/>

                        <!-- Door - Right wall -->
                        <polygon points="75,95 75,135 95,125 95,85" fill="rgba(0, 212, 255, 0.4)" stroke="#00d4ff" stroke-width="1"/>

                        <!-- Window glow effect -->
                        <rect x="12" y="78" width="16" height="20" fill="#00d4ff" opacity="0.2" transform="skewY(26.5)">
                            <animate attributeName="opacity" values="0.2;0.4;0.2" dur="3s" repeatCount="indefinite"/>
                        </rect>
                    </g>

                    <!-- House consumption label - right side of house -->
                    <text x="590" y="210" fill="#00d4ff" font-size="22" font-weight="bold" text-anchor="start" filter="url(#glowCyan)">
                        {{ energyFlow.home.consumption?.toFixed(0) || '0' }} W
                    </text>

                    <!-- ========== ISOMETRIC SOLAR PANELS (Left-Center) ========== -->
                    <g class="iso-solar iso-element-clickable" @click="openSolarModal" transform="translate(55, 80) scale(1.25)">
                        <!-- Panel frame/stand -->
                        <line x1="30" y1="130" x2="30" y2="80" stroke="#4a6a8a" stroke-width="3"/>
                        <line x1="90" y1="130" x2="90" y2="80" stroke="#4a6a8a" stroke-width="3"/>
                        <line x1="60" y1="145" x2="60" y2="60" stroke="#4a6a8a" stroke-width="4"/>

                        <!-- Panel shadow -->
                        <ellipse cx="60" cy="145" rx="50" ry="15" fill="#000" opacity="0.3"/>

                        <!-- Solar Panel Array - 3 rows (S1, S2, S3) -->
                        <!-- Panel S1 (top) -->
                        <g class="panel-s1">
                            <polygon points="20,20 60,0 100,20 60,40" fill="url(#solarPanelGrad)" stroke="#00d4ff" stroke-width="1"/>
                            <!-- Panel cells -->
                            <line x1="40" y1="10" x2="40" y2="30" stroke="#00d4ff" stroke-width="0.5" opacity="0.5"/>
                            <line x1="60" y1="5" x2="60" y2="35" stroke="#00d4ff" stroke-width="0.5" opacity="0.5"/>
                            <line x1="80" y1="10" x2="80" y2="30" stroke="#00d4ff" stroke-width="0.5" opacity="0.5"/>
                            <!-- Reflection highlight -->
                            <polygon points="25,18 45,8 50,12 30,22" fill="#4a8aaa" opacity="0.3"/>
                        </g>

                        <!-- Panel S2 (middle) -->
                        <g class="panel-s2">
                            <polygon points="15,45 55,25 95,45 55,65" fill="url(#solarPanelGrad)" stroke="#00d4ff" stroke-width="1"/>
                            <line x1="35" y1="35" x2="35" y2="55" stroke="#00d4ff" stroke-width="0.5" opacity="0.5"/>
                            <line x1="55" y1="30" x2="55" y2="60" stroke="#00d4ff" stroke-width="0.5" opacity="0.5"/>
                            <line x1="75" y1="35" x2="75" y2="55" stroke="#00d4ff" stroke-width="0.5" opacity="0.5"/>
                            <polygon points="20,43 40,33 45,37 25,47" fill="#4a8aaa" opacity="0.3"/>
                        </g>

                        <!-- Panel S3 (bottom) -->
                        <g class="panel-s3">
                            <polygon points="10,70 50,50 90,70 50,90" fill="url(#solarPanelGrad)" stroke="#00d4ff" stroke-width="1"/>
                            <line x1="30" y1="60" x2="30" y2="80" stroke="#00d4ff" stroke-width="0.5" opacity="0.5"/>
                            <line x1="50" y1="55" x2="50" y2="85" stroke="#00d4ff" stroke-width="0.5" opacity="0.5"/>
                            <line x1="70" y1="60" x2="70" y2="80" stroke="#00d4ff" stroke-width="0.5" opacity="0.5"/>
                            <polygon points="15,68 35,58 40,62 20,72" fill="#4a8aaa" opacity="0.3"/>
                        </g>

                        <!-- Sun reflection animation -->
                        <circle cx="60" cy="40" r="8" fill="#ffdd00" opacity="0.15">
                            <animate attributeName="opacity" values="0.1;0.25;0.1" dur="2s" repeatCount="indefinite"/>
                            <animate attributeName="r" values="6;10;6" dur="2s" repeatCount="indefinite"/>
                        </circle>
                    </g>

                    <!-- Solar total power label - left of solar panels, same height as house label -->
                    <text x="10" y="210" fill="#ffdd00" font-size="22" font-weight="bold" text-anchor="start" filter="url(#glowYellow)">
                        {{ energyFlow.flows.solar_power?.toFixed(0) || '0' }} W
                    </text>

                    <!-- ========== ISOMETRIC BATTERY (Bottom-Left - Transparent Cube with Gold Accent) ========== -->
                    <g v-if="hasBattery" class="iso-battery iso-element-clickable" @click="openBatteryModal" transform="translate(140, 340) scale(1.4)">
                        <!-- Reactor shadow -->
                        <ellipse cx="50" cy="110" rx="45" ry="15" fill="#000" opacity="0.5"/>

                        <!-- Base platform (hexagonal) -->
                        <polygon points="50,100 90,82 90,55 50,37 10,55 10,82" fill="rgba(20, 40, 35, 0.8)" stroke="#22c55e" stroke-width="1.5"/>
                        <polygon points="50,37 90,55 90,82 50,100 10,82 10,55" fill="none" stroke="#fbbf24" stroke-width="0.5" opacity="0.5"/>

                        <!-- Reactor containment ring (bottom) -->
                        <ellipse cx="50" cy="78" rx="32" ry="12" fill="none" stroke="#22c55e" stroke-width="2" opacity="0.8"/>
                        <ellipse cx="50" cy="78" rx="28" ry="10" fill="rgba(34, 197, 94, 0.1)" stroke="#22c55e" stroke-width="1" opacity="0.5"/>

                        <!-- Reactor core (glowing center) - color based on charge/discharge -->
                        <ellipse cx="50" cy="55" rx="18" ry="7" :fill="energyFlow.battery.power > 0 ? 'rgba(34, 197, 94, 0.3)' : (energyFlow.battery.power < 0 ? 'rgba(251, 191, 36, 0.3)' : 'rgba(100, 116, 139, 0.3)')" />
                        <ellipse cx="50" cy="55" rx="12" ry="5" :fill="energyFlow.battery.power > 0 ? '#22c55e' : (energyFlow.battery.power < 0 ? '#fbbf24' : '#64748b')" filter="url(#glowGreen)">
                            <animate attributeName="opacity" values="0.8;1;0.8" dur="1.5s" repeatCount="indefinite"/>
                        </ellipse>

                        <!-- Energy column (vertical plasma) -->
                        <rect x="46" y="18" width="8" height="37" :fill="energyFlow.battery.power > 0 ? 'url(#reactorPlasmaGreen)' : (energyFlow.battery.power < 0 ? 'url(#reactorPlasmaGold)' : 'url(#reactorPlasmaGray)')" opacity="0.8" rx="4"/>
                        <rect x="48" y="20" width="4" height="33" fill="#fff" opacity="0.3" rx="2">
                            <animate attributeName="opacity" values="0.2;0.5;0.2" dur="0.8s" repeatCount="indefinite"/>
                        </rect>

                        <!-- Rotating energy ring (top) -->
                        <g transform="translate(50, 25)">
                            <ellipse cx="0" cy="0" rx="22" ry="8" fill="none" stroke="#22c55e" stroke-width="2" stroke-dasharray="8,4" opacity="0.9">
                                <animateTransform attributeName="transform" type="rotate" from="0" to="360" dur="8s" repeatCount="indefinite"/>
                            </ellipse>
                            <ellipse cx="0" cy="0" rx="16" ry="6" fill="none" stroke="#fbbf24" stroke-width="1.5" stroke-dasharray="6,6" opacity="0.7">
                                <animateTransform attributeName="transform" type="rotate" from="360" to="0" dur="6s" repeatCount="indefinite"/>
                            </ellipse>
                        </g>

                        <!-- Rotating energy ring (middle) -->
                        <g transform="translate(50, 42)">
                            <ellipse cx="0" cy="0" rx="26" ry="10" fill="none" stroke="#22c55e" stroke-width="1.5" stroke-dasharray="10,5" opacity="0.6">
                                <animateTransform attributeName="transform" type="rotate" from="0" to="360" dur="10s" repeatCount="indefinite"/>
                            </ellipse>
                        </g>

                        <!-- Energy level arcs (SOC indicator) -->
                        <g transform="translate(50, 78)">
                            <!-- Background arc -->
                            <ellipse cx="0" cy="0" rx="38" ry="14" fill="none" stroke="#1a4a3a" stroke-width="4" opacity="0.5"/>
                            <!-- Filled arc based on SOC -->
                            <ellipse cx="0" cy="0" rx="38" ry="14" fill="none" stroke="#22c55e" stroke-width="4"
                                :stroke-dasharray="(energyFlow.battery.soc || 0) * 2.4 + ' 240'"
                                stroke-linecap="round" filter="url(#glowGreen)"/>
                        </g>

                        <!-- Corner energy nodes -->
                        <circle cx="10" cy="55" r="3" fill="#fbbf24" filter="url(#glowYellow)">
                            <animate attributeName="r" values="2;3;2" dur="2s" repeatCount="indefinite"/>
                        </circle>
                        <circle cx="90" cy="55" r="3" fill="#fbbf24" filter="url(#glowYellow)">
                            <animate attributeName="r" values="2;3;2" dur="2s" repeatCount="indefinite" begin="0.5s"/>
                        </circle>
                        <circle cx="50" cy="37" r="3" fill="#22c55e" filter="url(#glowGreen)">
                            <animate attributeName="r" values="2;4;2" dur="1.5s" repeatCount="indefinite"/>
                        </circle>

                        <!-- Percentage display -->
                        <rect x="30" y="85" width="40" height="18" fill="rgba(0,0,0,0.8)" rx="3" stroke="#22c55e" stroke-width="0.5"/>
                        <text x="50" y="98" fill="#22c55e" font-size="12" font-weight="bold" text-anchor="middle" filter="url(#glowGreen)">
                            {{ energyFlow.battery.soc?.toFixed(0) || '0' }}%
                        </text>

                        <!-- Status indicator (top) -->
                        <circle cx="50" cy="8" r="5" :fill="energyFlow.battery.power > 0 ? '#22c55e' : (energyFlow.battery.power < 0 ? '#fbbf24' : '#64748b')" filter="url(#glowGreen)">
                            <animate attributeName="opacity" values="1;0.4;1" dur="1s" repeatCount="indefinite"/>
                        </circle>
                    </g>

                    <!-- Battery label - left of battery -->
                    <text v-if="hasBattery" x="130" y="450" fill="#22c55e" font-size="18" font-weight="bold" text-anchor="end" filter="url(#glowGreen)">
                        {{ energyFlow.battery.power > 0 ? '+' : '' }}{{ energyFlow.battery.power?.toFixed(0) || '0' }} W
                    </text>

                    <!-- ========== ISOMETRIC CYBER POWER TOWER (Bottom-Right - Grid Connection) ========== -->
                    <g class="iso-grid iso-element-clickable" @click="openGridModal" transform="translate(690, 340) scale(1.3)">
                        <!-- Tower shadow -->
                        <ellipse cx="45" cy="120" rx="40" ry="12" fill="#000" opacity="0.5"/>

                        <!-- Base platform (hexagonal - matching reactor style) -->
                        <polygon points="45,115 85,97 85,75 45,57 5,75 5,97" fill="rgba(30, 20, 50, 0.8)" stroke="#8b5cf6" stroke-width="1.5"/>
                        <polygon points="45,57 85,75 85,97 45,115 5,97 5,75" fill="none" stroke="#ff2e97" stroke-width="0.5" opacity="0.5"/>

                        <!-- Main tower structure (truss style) -->
                        <!-- Left leg -->
                        <line x1="25" y1="75" x2="35" y2="0" stroke="#8b5cf6" stroke-width="3"/>
                        <line x1="25" y1="75" x2="35" y2="0" stroke="#c4b5fd" stroke-width="1" opacity="0.5"/>
                        <!-- Right leg -->
                        <line x1="65" y1="75" x2="55" y2="0" stroke="#8b5cf6" stroke-width="3"/>
                        <line x1="65" y1="75" x2="55" y2="0" stroke="#c4b5fd" stroke-width="1" opacity="0.5"/>

                        <!-- Cross braces -->
                        <line x1="28" y1="60" x2="62" y2="60" stroke="#8b5cf6" stroke-width="2"/>
                        <line x1="31" y1="45" x2="59" y2="45" stroke="#8b5cf6" stroke-width="2"/>
                        <line x1="34" y1="30" x2="56" y2="30" stroke="#8b5cf6" stroke-width="1.5"/>
                        <line x1="37" y1="15" x2="53" y2="15" stroke="#8b5cf6" stroke-width="1.5"/>

                        <!-- Diagonal braces -->
                        <line x1="28" y1="60" x2="59" y2="45" stroke="#8b5cf6" stroke-width="1" opacity="0.7"/>
                        <line x1="62" y1="60" x2="31" y2="45" stroke="#8b5cf6" stroke-width="1" opacity="0.7"/>
                        <line x1="31" y1="45" x2="56" y2="30" stroke="#8b5cf6" stroke-width="1" opacity="0.7"/>
                        <line x1="59" y1="45" x2="34" y2="30" stroke="#8b5cf6" stroke-width="1" opacity="0.7"/>

                        <!-- Top cross arm -->
                        <rect x="20" y="-2" width="50" height="6" fill="#3a2a5a" stroke="#8b5cf6" stroke-width="1.5" rx="1"/>

                        <!-- Insulators with energy rings -->
                        <!-- Left insulator -->
                        <g transform="translate(25, -5)">
                            <ellipse cx="0" cy="0" rx="6" ry="8" fill="#1a1a3a" stroke="#00ffff" stroke-width="1.5"/>
                            <ellipse cx="0" cy="0" rx="8" ry="3" fill="none" :stroke="energyFlow.flows.grid_to_house > 0 ? '#ff2e97' : (energyFlow.flows.house_to_grid > 0 ? '#00ffff' : '#8b5cf6')" stroke-width="1" stroke-dasharray="3,3" opacity="0.8">
                                <animateTransform attributeName="transform" type="rotate" from="0" to="360" dur="3s" repeatCount="indefinite"/>
                            </ellipse>
                        </g>
                        <!-- Center insulator -->
                        <g transform="translate(45, -5)">
                            <ellipse cx="0" cy="0" rx="6" ry="8" fill="#1a1a3a" stroke="#00ffff" stroke-width="1.5"/>
                            <ellipse cx="0" cy="0" rx="8" ry="3" fill="none" :stroke="energyFlow.flows.grid_to_house > 0 ? '#ff2e97' : (energyFlow.flows.house_to_grid > 0 ? '#00ffff' : '#8b5cf6')" stroke-width="1" stroke-dasharray="3,3" opacity="0.8">
                                <animateTransform attributeName="transform" type="rotate" from="360" to="0" dur="4s" repeatCount="indefinite"/>
                            </ellipse>
                        </g>
                        <!-- Right insulator -->
                        <g transform="translate(65, -5)">
                            <ellipse cx="0" cy="0" rx="6" ry="8" fill="#1a1a3a" stroke="#00ffff" stroke-width="1.5"/>
                            <ellipse cx="0" cy="0" rx="8" ry="3" fill="none" :stroke="energyFlow.flows.grid_to_house > 0 ? '#ff2e97' : (energyFlow.flows.house_to_grid > 0 ? '#00ffff' : '#8b5cf6')" stroke-width="1" stroke-dasharray="3,3" opacity="0.8">
                                <animateTransform attributeName="transform" type="rotate" from="0" to="360" dur="3.5s" repeatCount="indefinite"/>
                            </ellipse>
                        </g>

                        <!-- Power lines going outward -->
                        <path d="M25,-10 Q10,-20 -5,-15" fill="none" stroke="#8b5cf6" stroke-width="2" opacity="0.8"/>
                        <path d="M65,-10 Q80,-20 95,-15" fill="none" stroke="#8b5cf6" stroke-width="2" opacity="0.8"/>

                        <!-- Animated energy on power lines -->
                        <circle cx="10" cy="-18" r="2" :fill="energyFlow.flows.grid_to_house > 0 ? '#ff2e97' : (energyFlow.flows.house_to_grid > 0 ? '#00ffff' : '#8b5cf6')">
                            <animate attributeName="opacity" values="0;1;0" dur="0.8s" repeatCount="indefinite"/>
                        </circle>
                        <circle cx="80" cy="-18" r="2" :fill="energyFlow.flows.grid_to_house > 0 ? '#ff2e97' : (energyFlow.flows.house_to_grid > 0 ? '#00ffff' : '#8b5cf6')">
                            <animate attributeName="opacity" values="0;1;0" dur="0.8s" repeatCount="indefinite" begin="0.4s"/>
                        </circle>

                        <!-- Transformer box -->
                        <rect x="30" y="62" width="30" height="22" fill="url(#gridBoxGrad)" stroke="#8b5cf6" stroke-width="1.5" rx="2"/>
                        <rect x="33" y="65" width="24" height="10" fill="#0a0a1a" stroke="#8b5cf6" stroke-width="0.5"/>

                        <!-- Status display on transformer -->
                        <text x="45" y="73" :fill="(energyFlow.flows.grid_to_house > 0 || energyFlow.flows.grid_to_battery > 0) ? '#ff2e97' : (energyFlow.flows.house_to_grid > 0 ? '#00ffff' : '#8b5cf6')" font-size="7" font-weight="bold" text-anchor="middle">
                            {{ (energyFlow.flows.grid_to_house > 0 || energyFlow.flows.grid_to_battery > 0) ? 'IMPORT' : (energyFlow.flows.house_to_grid > 0 ? 'EXPORT' : 'IDLE') }}
                        </text>

                        <!-- Indicator LEDs on transformer -->
                        <circle cx="35" cy="80" r="2.5" :fill="(energyFlow.flows.grid_to_house > 0 || energyFlow.flows.grid_to_battery > 0) ? '#ff2e97' : '#3a2a5a'" filter="url(#glowPurple)">
                            <animate attributeName="opacity" values="0.5;1;0.5" dur="0.8s" repeatCount="indefinite"/>
                        </circle>
                        <circle cx="45" cy="80" r="2.5" fill="#22c55e" opacity="0.8">
                            <animate attributeName="opacity" values="0.4;1;0.4" dur="2s" repeatCount="indefinite"/>
                        </circle>
                        <circle cx="55" cy="80" r="2.5" :fill="energyFlow.flows.house_to_grid > 0 ? '#00ffff' : '#3a2a5a'" filter="url(#glowCyan)">
                            <animate attributeName="opacity" values="0.5;1;0.5" dur="0.8s" repeatCount="indefinite" begin="0.4s"/>
                        </circle>

                        <!-- Lightning bolt symbol at top (iconic grid symbol) -->
                        <g transform="translate(45, -18)">
                            <path d="M0,-8 L4,0 L0,0 L4,8 L-4,0 L0,0 Z" :fill="energyFlow.flows.grid_to_house > 0 ? '#ff2e97' : (energyFlow.flows.house_to_grid > 0 ? '#00ffff' : '#fbbf24')" filter="url(#glowYellow)">
                                <animate attributeName="opacity" values="0.7;1;0.7" dur="0.5s" repeatCount="indefinite"/>
                            </path>
                        </g>

                        <!-- Electric sparks when active -->
                        <g v-if="energyFlow.flows.grid_to_house > 0 || energyFlow.flows.grid_to_battery > 0 || energyFlow.flows.house_to_grid > 0">
                            <circle cx="25" cy="-10" r="1.5" fill="#00ffff">
                                <animate attributeName="opacity" values="0;1;0" dur="0.3s" repeatCount="indefinite"/>
                                <animate attributeName="r" values="1;2.5;1" dur="0.3s" repeatCount="indefinite"/>
                            </circle>
                            <circle cx="45" cy="-10" r="1.5" fill="#00ffff">
                                <animate attributeName="opacity" values="0;1;0" dur="0.25s" repeatCount="indefinite" begin="0.1s"/>
                                <animate attributeName="r" values="1;2.5;1" dur="0.25s" repeatCount="indefinite" begin="0.1s"/>
                            </circle>
                            <circle cx="65" cy="-10" r="1.5" fill="#00ffff">
                                <animate attributeName="opacity" values="0;1;0" dur="0.35s" repeatCount="indefinite" begin="0.2s"/>
                                <animate attributeName="r" values="1;2.5;1" dur="0.35s" repeatCount="indefinite" begin="0.2s"/>
                            </circle>
                        </g>

                        <!-- Corner energy nodes on base -->
                        <circle cx="5" cy="75" r="3" fill="#ff2e97" filter="url(#glowPurple)">
                            <animate attributeName="r" values="2;3.5;2" dur="1.8s" repeatCount="indefinite"/>
                        </circle>
                        <circle cx="85" cy="75" r="3" fill="#00ffff" filter="url(#glowCyan)">
                            <animate attributeName="r" values="2;3.5;2" dur="1.8s" repeatCount="indefinite" begin="0.6s"/>
                        </circle>
                        <circle cx="45" cy="57" r="3" fill="#8b5cf6" filter="url(#glowPurple)">
                            <animate attributeName="r" values="2;4;2" dur="1.5s" repeatCount="indefinite"/>
                        </circle>
                    </g>

                    <!-- Grid power label - right of grid tower -->
                    <text x="830" y="450" fill="#8b5cf6" font-size="18" font-weight="bold" text-anchor="start" filter="url(#glowPurple)">
                        {{ getGridPower() }} W
                    </text>
                    <text x="830" y="468" fill="#94a3b8" font-size="12" text-anchor="start">{{ getGridLabel() }}</text>

                    <!-- ========== CONSUMERS (W√§rmepumpe, Heizstab, Wallbox) - Below House ========== -->
                    <g v-if="energyFlow.consumers && (energyFlow.consumers.heatpump || energyFlow.consumers.heatingrod || energyFlow.consumers.wallbox)" class="iso-consumers iso-element-clickable" @click="openConsumerModal" transform="translate(450, 280)" style="cursor: pointer;">

                        <!-- Consumer Platform (subtle) -->
                        <ellipse cx="0" cy="85" rx="160" ry="25" fill="rgba(0, 212, 255, 0.05)" stroke="#00d4ff" stroke-width="0.5" opacity="0.5"/>

                        <!-- W√§rmepumpe (Heat Pump) - Left -->
                        <g v-if="energyFlow.consumers.heatpump" transform="translate(-100, 20)" class="consumer-item">
                            <!-- Outer glow ring -->
                            <circle cx="30" cy="30" r="32" fill="none" stroke="#ff6b6b" stroke-width="1" opacity="0.3" filter="url(#glowCyan)"/>
                            <!-- Main ring -->
                            <circle cx="30" cy="30" r="28" fill="rgba(255, 107, 107, 0.1)" stroke="#ff6b6b" stroke-width="2"/>
                            <!-- Inner circle -->
                            <circle cx="30" cy="30" r="20" fill="rgba(13, 17, 23, 0.8)" stroke="#ff6b6b" stroke-width="1"/>
                            <!-- Icon -->
                            <text x="30" y="36" fill="#ff6b6b" font-size="18" text-anchor="middle">üî•</text>
                            <!-- Power value -->
                            <text x="30" y="75" fill="#ff6b6b" font-size="12" font-weight="bold" text-anchor="middle" filter="url(#glowCyan)">
                                {{ energyFlow.consumers.heatpump.power?.toFixed(0) || '0' }} W
                            </text>
                            <!-- Label -->
                            <text x="30" y="90" fill="#94a3b8" font-size="9" text-anchor="middle">W√§rmepumpe</text>
                        </g>

                        <!-- Heizstab (Heating Rod) - Center -->
                        <g v-if="energyFlow.consumers.heatingrod" transform="translate(-30, 20)" class="consumer-item">
                            <!-- Outer glow ring -->
                            <circle cx="30" cy="30" r="32" fill="none" stroke="#fbbf24" stroke-width="1" opacity="0.3" filter="url(#glowYellow)"/>
                            <!-- Main ring -->
                            <circle cx="30" cy="30" r="28" fill="rgba(251, 191, 36, 0.1)" stroke="#fbbf24" stroke-width="2"/>
                            <!-- Inner circle -->
                            <circle cx="30" cy="30" r="20" fill="rgba(13, 17, 23, 0.8)" stroke="#fbbf24" stroke-width="1"/>
                            <!-- Icon -->
                            <text x="30" y="36" fill="#fbbf24" font-size="18" text-anchor="middle">üå°Ô∏è</text>
                            <!-- Power value -->
                            <text x="30" y="75" fill="#fbbf24" font-size="12" font-weight="bold" text-anchor="middle" filter="url(#glowYellow)">
                                {{ energyFlow.consumers.heatingrod.power?.toFixed(0) || '0' }} W
                            </text>
                            <!-- Label -->
                            <text x="30" y="90" fill="#94a3b8" font-size="9" text-anchor="middle">Heizstab</text>
                        </g>

                        <!-- Wallbox (EV Charger) - Right -->
                        <g v-if="energyFlow.consumers.wallbox" transform="translate(40, 20)" class="consumer-item">
                            <!-- Outer glow ring -->
                            <circle cx="30" cy="30" r="32" fill="none" :stroke="energyFlow.consumers.wallbox.state === 'charging' ? '#22c55e' : '#64748b'" stroke-width="1" opacity="0.3" filter="url(#glowGreen)"/>
                            <!-- Main ring -->
                            <circle cx="30" cy="30" r="28" :fill="energyFlow.consumers.wallbox.state === 'charging' ? 'rgba(34, 197, 94, 0.1)' : 'rgba(100, 116, 139, 0.1)'" :stroke="energyFlow.consumers.wallbox.state === 'charging' ? '#22c55e' : '#64748b'" stroke-width="2"/>
                            <!-- Inner circle -->
                            <circle cx="30" cy="30" r="20" fill="rgba(13, 17, 23, 0.8)" :stroke="energyFlow.consumers.wallbox.state === 'charging' ? '#22c55e' : '#64748b'" stroke-width="1"/>
                            <!-- Icon -->
                            <text x="30" y="36" :fill="energyFlow.consumers.wallbox.state === 'charging' ? '#22c55e' : '#64748b'" font-size="18" text-anchor="middle">üöó</text>
                            <!-- Charging indicator -->
                            <text v-if="energyFlow.consumers.wallbox.state === 'charging'" x="42" y="18" fill="#22c55e" font-size="10">‚ö°</text>
                            <!-- Power value -->
                            <text x="30" y="75" :fill="energyFlow.consumers.wallbox.state === 'charging' ? '#22c55e' : '#64748b'" font-size="12" font-weight="bold" text-anchor="middle" filter="url(#glowGreen)">
                                {{ energyFlow.consumers.wallbox.power?.toFixed(0) || '0' }} W
                            </text>
                            <!-- Label -->
                            <text x="30" y="90" fill="#94a3b8" font-size="9" text-anchor="middle">Wallbox</text>
                        </g>

                        <!-- Total consumption display -->
                        <g transform="translate(-40, 105)">
                            <rect x="0" y="0" width="80" height="22" rx="4" fill="rgba(0, 212, 255, 0.1)" stroke="#00d4ff" stroke-width="1"/>
                            <text x="40" y="15" fill="#00d4ff" font-size="11" font-weight="bold" text-anchor="middle">
                                Œ£ {{ ((energyFlow.consumers.heatpump?.power || 0) + (energyFlow.consumers.heatingrod?.power || 0) + (energyFlow.consumers.wallbox?.power || 0)).toFixed(0) }} W
                            </text>
                        </g>
                    </g>

                    <!-- ========== ANIMATED FLOW LINES (Cyberpunk Style) ========== -->

                    <!-- Solar to House flow - from solar panels to house -->
                    <g v-if="energyFlow.flows.solar_to_house > 0">
                        <path d="M180,220 Q300,150 400,150" fill="none" stroke="#ffdd00" stroke-width="3" class="flow-line-animated flow-glow-yellow" stroke-linecap="round"/>
                    </g>

                    <!-- Solar to Battery flow - from solar to battery -->
                    <g v-if="hasBattery && energyFlow.flows.solar_to_battery > 0">
                        <path d="M150,280 Q140,360 180,420" fill="none" stroke="#ffdd00" stroke-width="3" class="flow-line-animated flow-glow-yellow" stroke-linecap="round"/>
                    </g>

                    <!-- Battery to House flow - from battery to house -->
                    <g v-if="hasBattery && energyFlow.flows.battery_to_house > 0">
                        <path d="M280,420 Q350,300 430,220" fill="none" stroke="#22c55e" stroke-width="3.5" class="flow-line-animated flow-glow-green" stroke-linecap="round"/>
                    </g>

                    <!-- Grid to House flow - from power pole to house -->
                    <g v-if="energyFlow.flows.grid_to_house > 0">
                        <path d="M710,390 Q600,300 500,220" fill="none" stroke="#ff2e97" stroke-width="3.5" stroke-dasharray="10,5" class="flow-line-animated-reverse flow-glow-purple" stroke-linecap="round"/>
                    </g>

                    <!-- House to Grid (Export) flow - from house to power pole -->
                    <g v-if="energyFlow.flows.house_to_grid > 0">
                        <path d="M500,220 Q600,300 710,390" fill="none" stroke="#00ffff" stroke-width="3.5" class="flow-line-animated flow-glow-cyan" stroke-linecap="round"/>
                    </g>

                    <!-- Grid to Battery flow -->
                    <g v-if="hasBattery && energyFlow.flows.grid_to_battery > 0">
                        <path d="M735,455 Q460,500 190,440" fill="none" stroke="#8b5cf6" stroke-width="2.5" stroke-dasharray="8,4" class="flow-line-animated-reverse flow-glow-purple"/>
                    </g>

                    <!-- House to Consumers flow - from house down to consumers -->
                    <g v-if="energyFlow.consumers && (energyFlow.consumers.heatpump?.power > 0 || energyFlow.consumers.heatingrod?.power > 0 || energyFlow.consumers.wallbox?.power > 0)">
                        <path d="M450,220 L450,280" fill="none" stroke="#00d4ff" stroke-width="3" class="flow-line-animated flow-glow-cyan" stroke-linecap="round"/>
                        <!-- Branching lines to each consumer -->
                        <path d="M450,280 Q400,300 380,320" fill="none" stroke="#00d4ff" stroke-width="2" class="flow-line-animated flow-glow-cyan" stroke-linecap="round" opacity="0.7"/>
                        <path d="M450,280 L450,320" fill="none" stroke="#00d4ff" stroke-width="2" class="flow-line-animated flow-glow-cyan" stroke-linecap="round" opacity="0.7"/>
                        <path d="M450,280 Q500,300 520,320" fill="none" stroke="#00d4ff" stroke-width="2" class="flow-line-animated flow-glow-cyan" stroke-linecap="round" opacity="0.7"/>
                    </g>

                    <!-- ========== FLOW LABELS (rendered last to be on top) ========== -->
                    <g class="flow-labels">
                        <!-- Solar to House label -->
                        <text v-if="energyFlow.flows.solar_to_house > 0" x="280" y="140" fill="#ffdd00" font-size="13" font-weight="bold" text-anchor="middle" filter="url(#glowYellow)">
                            {{ energyFlow.flows.solar_to_house.toFixed(0) }} W
                        </text>
                        <!-- Solar to Battery label -->
                        <text v-if="hasBattery && energyFlow.flows.solar_to_battery > 0" x="120" y="350" fill="#ffdd00" font-size="12" font-weight="bold" text-anchor="middle" filter="url(#glowYellow)">
                            {{ energyFlow.flows.solar_to_battery.toFixed(0) }} W
                        </text>
                        <!-- Battery to House label -->
                        <text v-if="hasBattery && energyFlow.flows.battery_to_house > 0" x="280" y="320" fill="#22c55e" font-size="13" font-weight="bold" text-anchor="middle" filter="url(#glowGreen)">
                            {{ energyFlow.flows.battery_to_house.toFixed(0) }} W
                        </text>
                        <!-- Grid to House label -->
                        <text v-if="energyFlow.flows.grid_to_house > 0" x="580" y="320" fill="#ff2e97" font-size="13" font-weight="bold" text-anchor="middle" filter="url(#glowPurple)">
                            {{ energyFlow.flows.grid_to_house.toFixed(0) }} W
                        </text>
                        <!-- House to Grid label -->
                        <text v-if="energyFlow.flows.house_to_grid > 0" x="580" y="300" fill="#00ffff" font-size="13" font-weight="bold" text-anchor="middle" filter="url(#glowCyan)">
                            {{ energyFlow.flows.house_to_grid.toFixed(0) }} W
                        </text>
                        <!-- Grid to Battery label -->
                        <text v-if="hasBattery && energyFlow.flows.grid_to_battery > 0" x="500" y="485" fill="#8b5cf6" font-size="11" font-weight="bold" text-anchor="middle">
                            {{ energyFlow.flows.grid_to_battery.toFixed(0) }} W
                        </text>
                    </g>

                    <!-- Info panels removed as per user request -->

                </svg>

                <!-- ========== CLASSIC 2D ENERGY FLOW DIAGRAM ========== -->
                <svg v-show="!isSectionCollapsed('energyFlow') && dashboardStyle === '2d'" class="energy-flow-svg" viewBox="0 0 500 370" preserveAspectRatio="xMidYMid meet">
                    <!-- Definitions -->
                    <defs>
                        <!-- Glow Filters -->
                        <filter id="glow2dYellow" x="-50%" y="-50%" width="200%" height="200%">
                            <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                            <feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge>
                        </filter>
                        <filter id="glow2dGreen" x="-50%" y="-50%" width="200%" height="200%">
                            <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                            <feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge>
                        </filter>
                        <filter id="glow2dCyan" x="-50%" y="-50%" width="200%" height="200%">
                            <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                            <feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge>
                        </filter>
                        <filter id="glow2dPurple" x="-50%" y="-50%" width="200%" height="200%">
                            <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                            <feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge>
                        </filter>
                    </defs>

                    <!-- LAYOUT: Solar(70,45), Home(250,95), Consumers(250,215), Battery(70,280), Grid(430,280) -->

                    <!-- ========== FLOW LINES ========== -->
                    <!-- Solar to Home (diagonal right-down) -->
                    <path d="M105,55 L215,85"
                          stroke="#ffdd00" stroke-width="3" stroke-linecap="round" fill="none"
                          :opacity="energyFlow.flows.solar_to_house > 0 ? 1 : 0"/>

                    <!-- Solar to Battery (vertical down) -->
                    <path v-if="hasBattery" d="M70,80 L70,245"
                          stroke="#ffdd00" stroke-width="2" stroke-linecap="round" fill="none"
                          :opacity="energyFlow.flows.solar_to_battery > 0 ? 1 : 0"/>

                    <!-- Battery to Home (diagonal up-right) -->
                    <path v-if="hasBattery" d="M105,265 L215,110"
                          stroke="#22c55e" stroke-width="3" stroke-linecap="round" fill="none"
                          :opacity="energyFlow.flows.battery_to_house > 0 ? 1 : 0"/>

                    <!-- Grid to Home (curved arc) - Grid TOP center to Home right center -->
                    <path d="M430,248 Q480,160 285,95"
                          stroke="#8b5cf6" stroke-width="2" stroke-linecap="round" fill="none" stroke-dasharray="5,5"
                          :opacity="energyFlow.flows.grid_to_house > 0 ? 1 : 0"/>

                    <!-- Home to Grid (Export - curved arc) - Home right center to Grid TOP center -->
                    <path d="M285,95 Q480,160 430,248"
                          stroke="#00ffff" stroke-width="3" stroke-linecap="round" fill="none"
                          :opacity="energyFlow.flows.house_to_grid > 0 ? 1 : 0"/>

                    <!-- Grid to Battery (curved arc below) -->
                    <path v-if="hasBattery" d="M395,280 Q250,340 105,280"
                          stroke="#8b5cf6" stroke-width="2" stroke-linecap="round" fill="none" stroke-dasharray="5,5"
                          :opacity="energyFlow.flows.grid_to_battery > 0 ? 1 : 0"/>

                    <!-- Home to Consumers (vertical down) -->
                    <path v-if="energyFlow.consumers && (energyFlow.consumers.heatpump || energyFlow.consumers.heatingrod || energyFlow.consumers.wallbox)"
                          d="M250,130 L250,199"
                          stroke="#00d4ff" stroke-width="2" stroke-linecap="round" fill="none"
                          :opacity="(energyFlow.consumers.heatpump?.power || 0) + (energyFlow.consumers.heatingrod?.power || 0) + (energyFlow.consumers.wallbox?.power || 0) > 0 ? 1 : 0.3"/>

                    <!-- ========== ANIMATED PARTICLES ========== -->
                    <!-- Solar to Home -->
                    <circle v-if="energyFlow.flows.solar_to_house > 0" r="5" fill="#ffdd00" filter="url(#glow2dYellow)">
                        <animateMotion dur="1.2s" repeatCount="indefinite" path="M105,55 L215,85"/>
                    </circle>

                    <!-- Solar to Battery -->
                    <circle v-if="hasBattery && energyFlow.flows.solar_to_battery > 0" r="4" fill="#ffdd00" filter="url(#glow2dYellow)">
                        <animateMotion dur="1.5s" repeatCount="indefinite" path="M70,80 L70,245"/>
                    </circle>

                    <!-- Battery to Home -->
                    <circle v-if="hasBattery && energyFlow.flows.battery_to_house > 0" r="5" fill="#22c55e" filter="url(#glow2dGreen)">
                        <animateMotion dur="1.3s" repeatCount="indefinite" path="M105,265 L215,110"/>
                    </circle>

                    <!-- Grid to Home -->
                    <circle v-if="energyFlow.flows.grid_to_house > 0" r="5" fill="#8b5cf6" filter="url(#glow2dPurple)">
                        <animateMotion dur="1.5s" repeatCount="indefinite" path="M430,248 Q480,160 285,95"/>
                    </circle>

                    <!-- Home to Grid -->
                    <circle v-if="energyFlow.flows.house_to_grid > 0" r="5" fill="#00ffff" filter="url(#glow2dCyan)">
                        <animateMotion dur="1.5s" repeatCount="indefinite" path="M285,95 Q480,160 430,248"/>
                    </circle>

                    <!-- Grid to Battery -->
                    <circle v-if="hasBattery && energyFlow.flows.grid_to_battery > 0" r="4" fill="#8b5cf6" filter="url(#glow2dPurple)">
                        <animateMotion dur="2s" repeatCount="indefinite" path="M395,280 Q250,340 105,280"/>
                    </circle>

                    <!-- ========== FLOW LABELS ========== -->
                    <!-- Solar to Home Label -->
                    <text v-if="energyFlow.flows.solar_to_house > 0" x="155" y="60"
                          fill="#ffdd00" font-size="10" font-weight="bold" text-anchor="middle">
                        {{ energyFlow.flows.solar_to_house?.toFixed(0) }} W
                    </text>

                    <!-- Solar to Battery Label -->
                    <text v-if="hasBattery && energyFlow.flows.solar_to_battery > 0" x="50" y="165"
                          fill="#ffdd00" font-size="10" font-weight="bold" text-anchor="middle">
                        {{ energyFlow.flows.solar_to_battery?.toFixed(0) }} W
                    </text>

                    <!-- Battery to Home Label -->
                    <text v-if="hasBattery && energyFlow.flows.battery_to_house > 0" x="155" y="185"
                          fill="#22c55e" font-size="10" font-weight="bold" text-anchor="middle">
                        {{ energyFlow.flows.battery_to_house?.toFixed(0) }} W
                    </text>

                    <!-- Grid to Home Label (on curved arc) -->
                    <text v-if="energyFlow.flows.grid_to_house > 0" x="380" y="185"
                          fill="#8b5cf6" font-size="10" font-weight="bold" text-anchor="middle">
                        {{ energyFlow.flows.grid_to_house?.toFixed(0) }} W
                    </text>

                    <!-- Home to Grid (Export) Label (on curved arc) -->
                    <text v-if="energyFlow.flows.house_to_grid > 0" x="380" y="170"
                          fill="#00ffff" font-size="10" font-weight="bold" text-anchor="middle">
                        {{ energyFlow.flows.house_to_grid?.toFixed(0) }} W
                    </text>

                    <!-- Grid to Battery Label (on curved arc) -->
                    <text v-if="hasBattery && energyFlow.flows.grid_to_battery > 0" x="250" y="330"
                          fill="#8b5cf6" font-size="9" font-weight="bold" text-anchor="middle">
                        {{ energyFlow.flows.grid_to_battery?.toFixed(0) }} W
                    </text>

                    <!-- ========== SOLAR NODE (left top) ========== -->
                    <g class="node-glow-solar node-clickable" :class="{ active: energyFlow.flows.solar_power > 0 }" @click="openSolarModal">
                        <circle cx="70" cy="45" r="32" fill="rgba(251, 191, 36, 0.15)" stroke="#ffdd00" stroke-width="2"/>
                        <g transform="translate(70, 45)">
                            <circle r="10" fill="#ffdd00"/>
                            <g stroke="#ffdd00" stroke-width="2" stroke-linecap="round">
                                <line x1="0" y1="-15" x2="0" y2="-20"/>
                                <line x1="0" y1="15" x2="0" y2="20"/>
                                <line x1="-15" y1="0" x2="-20" y2="0"/>
                                <line x1="15" y1="0" x2="20" y2="0"/>
                                <line x1="-11" y1="-11" x2="-14" y2="-14"/>
                                <line x1="11" y1="-11" x2="14" y2="-14"/>
                                <line x1="-11" y1="11" x2="-14" y2="14"/>
                                <line x1="11" y1="11" x2="14" y2="14"/>
                            </g>
                        </g>
                    </g>
                    <text x="70" y="90" fill="#ffdd00" font-size="12" font-weight="bold" text-anchor="middle">
                        {{ energyFlow.flows.solar_power?.toFixed(0) || '0' }} W
                    </text>

                    <!-- ========== HOME NODE (center - higher) ========== -->
                    <g class="node-glow-home node-clickable" :class="{ active: energyFlow.home.consumption > 0 }" @click="openHouseModal">
                        <circle cx="250" cy="95" r="35" fill="rgba(0, 255, 255, 0.15)" stroke="#00ffff" stroke-width="2"/>
                        <g transform="translate(250, 95)">
                            <path d="M-18,0 L0,-16 L18,0" fill="none" stroke="#00ffff" stroke-width="2" stroke-linejoin="round"/>
                            <rect x="-14" y="0" width="28" height="18" fill="none" stroke="#00ffff" stroke-width="1.5"/>
                            <rect x="-4" y="6" width="8" height="12" fill="rgba(0, 255, 255, 0.3)" stroke="#00ffff" stroke-width="1"/>
                            <rect x="-12" y="3" width="6" height="6" fill="rgba(0, 255, 255, 0.2)" stroke="#00ffff" stroke-width="0.8"/>
                            <rect x="6" y="3" width="6" height="6" fill="rgba(0, 255, 255, 0.2)" stroke="#00ffff" stroke-width="0.8"/>
                        </g>
                    </g>
                    <text x="310" y="75" fill="#00ffff" font-size="12" font-weight="bold" text-anchor="start">
                        {{ energyFlow.home.consumption?.toFixed(0) || '‚Äî' }} W
                    </text>
                    <text x="310" y="88" fill="#94a3b8" font-size="9" text-anchor="start">Verbrauch</text>

                    <!-- ========== BATTERY NODE (left bottom - deeper) ========== -->
                    <g v-if="hasBattery" class="node-glow-battery node-clickable" :class="{ active: energyFlow.battery.power !== 0 }" @click="openBatteryModal">
                        <circle cx="70" cy="280" r="32" fill="rgba(34, 197, 94, 0.15)" stroke="#22c55e" stroke-width="2"/>
                        <circle v-if="energyFlow.battery.soc !== null" cx="70" cy="280" r="36" fill="none"
                                stroke="rgba(34,197,94,0.2)" stroke-width="3"/>
                        <circle v-if="energyFlow.battery.soc !== null" cx="70" cy="280" r="36" fill="none"
                                stroke="#22c55e" stroke-width="3"
                                :stroke-dasharray="226.2"
                                :stroke-dashoffset="226.2 - (226.2 * (energyFlow.battery.soc || 0) / 100)"
                                stroke-linecap="round"
                                transform="rotate(-90 70 280)"/>
                        <g transform="translate(70, 280)">
                            <rect x="-10" y="-14" width="20" height="28" rx="2" fill="none" stroke="#22c55e" stroke-width="1.5"/>
                            <rect x="-4" y="-17" width="8" height="3" rx="1" fill="#22c55e"/>
                            <rect x="-7" y="11" width="14" :height="Math.max(0, (energyFlow.battery.soc || 0) / 100 * 22)"
                                  :transform="'translate(0, ' + (-((energyFlow.battery.soc || 0) / 100 * 22)) + ')'"
                                  fill="#22c55e" opacity="0.5" rx="1"/>
                        </g>
                    </g>
                    <text v-if="hasBattery" x="70" y="325" fill="#22c55e" font-size="12" font-weight="bold" text-anchor="middle">
                        {{ energyFlow.battery.soc?.toFixed(0) || '‚Äî' }} %
                    </text>
                    <text v-if="hasBattery" x="70" y="338" fill="#94a3b8" font-size="9" text-anchor="middle">Batterie</text>

                    <!-- ========== GRID NODE (right bottom - deeper, same height as battery) ========== -->
                    <g class="node-glow-grid node-clickable" :class="{ active: (energyFlow.flows.grid_to_house > 0 || energyFlow.flows.house_to_grid > 0) }" @click="openGridModal">
                        <circle cx="430" cy="280" r="32" fill="rgba(139, 92, 246, 0.15)" stroke="#8b5cf6" stroke-width="2"/>
                        <g transform="translate(430, 280)">
                            <line x1="0" y1="-18" x2="0" y2="18" stroke="#8b5cf6" stroke-width="2.5"/>
                            <line x1="-14" y1="-14" x2="14" y2="-14" stroke="#8b5cf6" stroke-width="2"/>
                            <line x1="-10" y1="-6" x2="10" y2="-6" stroke="#8b5cf6" stroke-width="1.5"/>
                            <circle cx="-12" cy="-14" r="2.5" fill="#8b5cf6" opacity="0.6"/>
                            <circle cx="12" cy="-14" r="2.5" fill="#8b5cf6" opacity="0.6"/>
                            <circle cx="0" cy="-14" r="2.5" fill="#8b5cf6" opacity="0.6"/>
                        </g>
                    </g>
                    <text x="430" y="325" fill="#8b5cf6" font-size="12" font-weight="bold" text-anchor="middle">
                        {{ getGridPower() }} W
                    </text>
                    <text x="430" y="338" fill="#94a3b8" font-size="9" text-anchor="middle">{{ getGridLabel() }}</text>
                    <text x="430" y="350" fill="#64748b" font-size="8" text-anchor="middle">
                        {{ currentPrice.total_price?.toFixed(2) || '‚Äî' }} ct
                    </text>

                    <!-- ========== CONSUMERS (2D) - Above Battery/Grid line ========== -->
                    <g v-if="energyFlow.consumers && (energyFlow.consumers.heatpump || energyFlow.consumers.heatingrod || energyFlow.consumers.wallbox)" class="consumers-2d iso-element-clickable" @click="openConsumerModal" transform="translate(250, 215)" style="cursor: pointer;">

                        <!-- W√§rmepumpe (left) - Simple circle -->
                        <g v-if="energyFlow.consumers.heatpump" transform="translate(-35, 0)">
                            <circle r="16" fill="rgba(255, 107, 107, 0.15)" stroke="#ff6b6b" stroke-width="2"/>
                            <text y="4" fill="#ff6b6b" font-size="12" text-anchor="middle">üî•</text>
                        </g>
                        <text v-if="energyFlow.consumers.heatpump" x="-35" y="26" fill="#ff6b6b" font-size="8" font-weight="bold" text-anchor="middle">
                            {{ (energyFlow.consumers.heatpump.power || 0).toFixed(0) }}W
                        </text>

                        <!-- Heizstab (center) - Simple circle -->
                        <g v-if="energyFlow.consumers.heatingrod" transform="translate(0, 0)">
                            <circle r="16" fill="rgba(251, 191, 36, 0.15)" stroke="#fbbf24" stroke-width="2"/>
                            <text y="4" fill="#fbbf24" font-size="12" text-anchor="middle">üå°Ô∏è</text>
                        </g>
                        <text v-if="energyFlow.consumers.heatingrod" x="0" y="26" fill="#fbbf24" font-size="8" font-weight="bold" text-anchor="middle">
                            {{ (energyFlow.consumers.heatingrod.power || 0).toFixed(0) }}W
                        </text>

                        <!-- Wallbox (right) - Simple circle -->
                        <g v-if="energyFlow.consumers.wallbox" transform="translate(35, 0)">
                            <circle r="16" :fill="energyFlow.consumers.wallbox.state === 'charging' ? 'rgba(34, 197, 94, 0.15)' : 'rgba(100, 116, 139, 0.15)'" :stroke="energyFlow.consumers.wallbox.state === 'charging' ? '#22c55e' : '#64748b'" stroke-width="2"/>
                            <text y="4" :fill="energyFlow.consumers.wallbox.state === 'charging' ? '#22c55e' : '#64748b'" font-size="12" text-anchor="middle">üöó</text>
                        </g>
                        <text v-if="energyFlow.consumers.wallbox" x="35" y="26" :fill="energyFlow.consumers.wallbox.state === 'charging' ? '#22c55e' : '#64748b'" font-size="8" font-weight="bold" text-anchor="middle">
                            {{ (energyFlow.consumers.wallbox.power || 0).toFixed(0) }}W
                        </text>

                        <!-- Total -->
                        <text y="42" fill="#00d4ff" font-size="9" font-weight="bold" text-anchor="middle">
                            Œ£ {{ ((energyFlow.consumers.heatpump?.power || 0) + (energyFlow.consumers.heatingrod?.power || 0) + (energyFlow.consumers.wallbox?.power || 0)).toFixed(0) }}W
                        </text>
                    </g>
                </svg>

                <!-- ========== LIST VIEW (Kompakte Listenansicht) ========== -->
                <div v-show="!isSectionCollapsed('energyFlow') && dashboardStyle === 'list'" class="energy-list-view">
                    <div class="energy-list-grid">
                        <!-- Solar -->
                        <div class="energy-list-card" @click="openSolarModal" style="cursor: pointer; border-color: #ffdd00;">
                            <div class="energy-list-icon">‚òÄÔ∏è</div>
                            <div class="energy-list-content">
                                <div class="energy-list-label">Solar-Produktion</div>
                                <div class="energy-list-value" style="color: #ffdd00;">{{ energyFlow.flows.solar_power?.toFixed(0) || '0' }} W</div>
                                <div class="energy-list-sub">Heute: {{ energyFlow.statistics.solar_yield_daily?.toFixed(2) || '0' }} kWh</div>
                            </div>
                            <div class="energy-list-flows">
                                <div v-if="energyFlow.flows.solar_to_house > 0">‚Üí Haus: {{ energyFlow.flows.solar_to_house?.toFixed(0) }} W</div>
                                <div v-if="hasBattery && energyFlow.flows.solar_to_battery > 0">‚Üí Akku: {{ energyFlow.flows.solar_to_battery?.toFixed(0) }} W</div>
                            </div>
                        </div>

                        <!-- Batterie -->
                        <div v-if="hasBattery" class="energy-list-card" @click="openBatteryModal" style="cursor: pointer; border-color: #22c55e;">
                            <div class="energy-list-icon">üîã</div>
                            <div class="energy-list-content">
                                <div class="energy-list-label">Batterie</div>
                                <div class="energy-list-value" style="color: #22c55e;">{{ energyFlow.battery.soc?.toFixed(0) || '‚Äî' }}%</div>
                                <div class="energy-list-sub">{{ energyFlow.battery.power?.toFixed(0) || '0' }} W</div>
                            </div>
                            <div class="energy-list-flows">
                                <div v-if="energyFlow.flows.battery_to_house > 0" style="color: #22c55e;">‚Üí Haus: {{ energyFlow.flows.battery_to_house?.toFixed(0) }} W</div>
                                <div v-if="energyFlow.flows.solar_to_battery > 0" style="color: #ffdd00;">‚Üê Solar: {{ energyFlow.flows.solar_to_battery?.toFixed(0) }} W</div>
                            </div>
                        </div>

                        <!-- Haus -->
                        <div class="energy-list-card" @click="openHouseModal" style="cursor: pointer; border-color: #00d4ff;">
                            <div class="energy-list-icon">üè†</div>
                            <div class="energy-list-content">
                                <div class="energy-list-label">Hausverbrauch</div>
                                <div class="energy-list-value" style="color: #00d4ff;">{{ energyFlow.home.consumption?.toFixed(0) || '0' }} W</div>
                                <div class="energy-list-sub">Netz heute: {{ energyFlow.statistics.grid_import_daily?.toFixed(2) || '0' }} kWh</div>
                            </div>
                            <div class="energy-list-flows">
                                <div v-if="energyFlow.flows.solar_to_house > 0" style="color: #ffdd00;">‚Üê Solar: {{ energyFlow.flows.solar_to_house?.toFixed(0) }} W</div>
                                <div v-if="hasBattery && energyFlow.flows.battery_to_house > 0" style="color: #22c55e;">‚Üê Akku: {{ energyFlow.flows.battery_to_house?.toFixed(0) }} W</div>
                                <div v-if="energyFlow.flows.grid_to_house > 0" style="color: #8b5cf6;">‚Üê Netz: {{ energyFlow.flows.grid_to_house?.toFixed(0) }} W</div>
                            </div>
                        </div>

                        <!-- Netz -->
                        <div class="energy-list-card" @click="openGridModal" style="cursor: pointer; border-color: #8b5cf6;">
                            <div class="energy-list-icon">‚ö°</div>
                            <div class="energy-list-content">
                                <div class="energy-list-label">Stromnetz</div>
                                <div class="energy-list-value" :style="{color: energyFlow.flows.house_to_grid > 0 ? '#00ffff' : '#8b5cf6'}">
                                    {{ energyFlow.flows.house_to_grid > 0 ? '-' : '' }}{{ Math.abs(energyFlow.flows.grid_to_house - energyFlow.flows.house_to_grid)?.toFixed(0) || '0' }} W
                                </div>
                                <div class="energy-list-sub">{{ energyFlow.flows.house_to_grid > 0 ? 'Einspeisung' : 'Bezug' }}</div>
                            </div>
                            <div class="energy-list-flows">
                                <div v-if="energyFlow.flows.grid_to_house > 0" style="color: #8b5cf6;">Import: {{ energyFlow.flows.grid_to_house?.toFixed(0) }} W</div>
                                <div v-if="energyFlow.flows.house_to_grid > 0" style="color: #00ffff;">Export: {{ energyFlow.flows.house_to_grid?.toFixed(0) }} W</div>
                            </div>
                        </div>

                        <!-- Verbraucher (falls vorhanden) -->
                        <div v-if="energyFlow.consumers && (energyFlow.consumers.heatpump || energyFlow.consumers.heatingrod || energyFlow.consumers.wallbox)"
                             class="energy-list-card" @click="openConsumerModal" style="cursor: pointer; border-color: #ec4899;">
                            <div class="energy-list-icon">üîå</div>
                            <div class="energy-list-content">
                                <div class="energy-list-label">Verbraucher</div>
                                <div class="energy-list-value" style="color: #ec4899;">
                                    {{ ((energyFlow.consumers.heatpump?.power || 0) + (energyFlow.consumers.heatingrod?.power || 0) + (energyFlow.consumers.wallbox?.power || 0)).toFixed(0) }} W
                                </div>
                                <div class="energy-list-sub">Gesamtverbrauch</div>
                            </div>
                            <div class="energy-list-flows">
                                <div v-if="energyFlow.consumers.heatpump?.power > 0">WP: {{ energyFlow.consumers.heatpump.power?.toFixed(0) }} W</div>
                                <div v-if="energyFlow.consumers.heatingrod?.power > 0">Heizstab: {{ energyFlow.consumers.heatingrod.power?.toFixed(0) }} W</div>
                                <div v-if="energyFlow.consumers.wallbox?.power > 0">Wallbox: {{ energyFlow.consumers.wallbox.power?.toFixed(0) }} W</div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Solar Power Live Card - Header klickbar f√ºr Modal -->
            <section class="power-sources-card collapsible-section sortable-item" data-section="powerSources">
                <div class="section-header-inline">
                    <div class="power-sources-header" @click="openPowerSourcesModal" style="cursor: pointer; flex: 1;">
                        <div class="power-sources-title">
                            <span>‚òÄÔ∏è</span>
                            <span>Deflektorschild-Kollektor</span>
                            <span v-if="energyFlow.flows.solar_power !== null" style="margin-left: 12px; font-size: 1.3rem; color: #facc15;">{{ Math.round(energyFlow.flows.solar_power || 0) }} W</span>
                            <span v-if="stats.peaks.today?.power_w" style="margin-left: 16px; font-size: 0.85rem; color: #94a3b8;">
                                Peak: <span style="color: #4ade80;">{{ Math.round(stats.peaks.today.power_w) }} W</span>
                                <span v-if="stats.peaks.today?.at" style="color: #64748b;"> ({{ formatTimeShort(stats.peaks.today.at) }})</span>
                            </span>
                            <span v-if="stats.production_time" style="margin-left: 16px; font-size: 0.85rem; color: #94a3b8;">
                                ‚è±Ô∏è <span style="color: #38bdf8;">{{ stats.production_time }}</span>
                            </span>
                        </div>
                        <div class="power-sources-subtitle">Klicken f√ºr Kollektor-Diagnostik ‚Ä¢ Live-Daten</div>
                    </div>
                    <button class="section-collapse-btn" @click.stop="toggleSection('powerSources')" :title="isSectionCollapsed('powerSources') ? 'Ausklappen' : 'Einklappen'">
                        {{ isSectionCollapsed('powerSources') ? '+' : '‚àí' }}
                    </button>
                </div>
                <div v-show="!isSectionCollapsed('powerSources')" class="power-sources-chart-container" ref="powerSourcesPreviewChart"></div>
                <div v-show="!isSectionCollapsed('powerSources')" class="power-sources-legend">
                    <div class="power-sources-legend-item">
                        <div class="power-sources-legend-dot solar"></div>
                        <span>PV-Leistung</span>
                    </div>
                </div>

                <!-- Panel Grid - Individuelle PV-Panels -->
                <div v-show="!isSectionCollapsed('powerSources')" class="panel-grid" v-if="energyFlow.panels && energyFlow.panels.length > 0">
                    <div class="panel-card" v-for="panel in energyFlow.panels" :key="panel.id">
                        <div class="panel-card-header">
                            <!-- Solar Panel SVG Icon -->
                            <svg class="panel-card-icon" viewBox="0 0 24 24" fill="none" stroke="#ffdd00" stroke-width="1.5">
                                <rect x="3" y="6" width="18" height="12" rx="1" fill="rgba(255,221,0,0.2)"/>
                                <line x1="3" y1="10" x2="21" y2="10"/>
                                <line x1="3" y1="14" x2="21" y2="14"/>
                                <line x1="9" y1="6" x2="9" y2="18"/>
                                <line x1="15" y1="6" x2="15" y2="18"/>
                                <circle cx="12" cy="3" r="1.5" fill="#ffdd00" stroke="none"/>
                                <line x1="12" y1="4.5" x2="12" y2="6" stroke="#ffdd00"/>
                            </svg>
                            <span class="panel-card-name">{{ panel.name }}</span>
                        </div>
                        <div class="panel-card-power">{{ panel.power?.toFixed(0) || '0' }} <span class="panel-card-unit">W</span></div>
                    </div>
                </div>
            </section>

            <!-- Prognose-√úbersicht: Heute, Morgen, √úbermorgen -->
            <section class="forecast-overview-container collapsible-section sortable-item" data-section="forecast">
                <div class="forecast-overview-header">
                    <div style="flex: 1;">
                        <div class="forecast-overview-title">üì° Langstrecken-Scanner</div>
                        <div class="forecast-overview-subtitle">Energievorhersage f√ºr die n√§chsten 3 Sternentage</div>
                    </div>
                    <button class="forecast-comparison-btn" @click="openShadowAnalyticsModal" title="Schatten-Analyse anzeigen" style="background: linear-gradient(135deg, rgba(100,100,120,0.3), rgba(60,60,80,0.3)); border-color: #8b8ba0;">
                        <span>üåë</span>
                        <span>Schatten</span>
                    </button>
                    <button class="forecast-comparison-btn" @click="openForecastComparisonModal" title="7-Tage Prognose-Vergleich anzeigen">
                        <span>üìä</span>
                        <span>7-Tage Vergleich</span>
                    </button>
                    <button class="section-collapse-btn" @click="toggleSection('forecast')" :title="isSectionCollapsed('forecast') ? 'Ausklappen' : 'Einklappen'">
                        {{ isSectionCollapsed('forecast') ? '+' : '‚àí' }}
                    </button>
                </div>
                <div v-show="!isSectionCollapsed('forecast')" class="forecast-days-grid">
                    <!-- Heute -->
                    <div class="forecast-day-card today">
                        <div class="forecast-day-header">
                            <span class="forecast-day-label">Heute</span>
                            <span class="forecast-day-total">{{ forecast.todayTotal?.toFixed(2) || '‚Äî' }} kWh</span>
                        </div>
                        <div class="forecast-day-details">
                            <span class="forecast-detail"><span style="color: var(--neon-green);">‚úì</span> Ertrag: {{ energyFlow.statistics.solar_yield_daily?.toFixed(2) || '0.00' }} kWh</span>
                            <span class="forecast-detail"><span style="color: var(--neon-cyan);">‚Üª</span> Rest: {{ forecast.todayRemaining?.toFixed(2) || '0.00' }} kWh</span>
                        </div>
                        <div class="forecast-hourly-bars">
                            <div v-for="h in forecast.todayHours" :key="'today-'+h.hour" class="forecast-bar-wrapper" :title="h.hour + ':00 - ' + h.kwh.toFixed(2) + ' kWh'">
                                <div class="forecast-bar today-bar" :style="{height: (h.kwh / forecast.maxHourly * 100) + '%'}"></div>
                                <span class="forecast-bar-label">{{ h.hour }}</span>
                            </div>
                        </div>
                    </div>
                    <!-- Morgen -->
                    <div class="forecast-day-card tomorrow">
                        <div class="forecast-day-header">
                            <span class="forecast-day-label">Morgen</span>
                            <span class="forecast-day-total">{{ forecast.tomorrowTotal?.toFixed(2) || '‚Äî' }} kWh</span>
                        </div>
                        <div class="forecast-day-details">
                            <span class="forecast-detail" v-if="forecast.tomorrowHours.length > 0">
                                <span style="color: var(--neon-yellow);">üèÜ</span> Beste: {{ Math.max(...forecast.tomorrowHours.map(h => h.kwh)).toFixed(2) }} kWh
                            </span>
                        </div>
                        <div class="forecast-hourly-bars">
                            <div v-for="h in forecast.tomorrowHours" :key="'tomorrow-'+h.hour" class="forecast-bar-wrapper" :title="h.hour + ':00 - ' + h.kwh.toFixed(2) + ' kWh'">
                                <div class="forecast-bar tomorrow-bar" :style="{height: (h.kwh / forecast.maxHourly * 100) + '%'}"></div>
                                <span class="forecast-bar-label">{{ h.hour }}</span>
                            </div>
                            <div v-if="forecast.tomorrowHours.length === 0" class="forecast-no-data">Keine Daten</div>
                        </div>
                    </div>
                    <!-- √úbermorgen -->
                    <div class="forecast-day-card day-after-tomorrow">
                        <div class="forecast-day-header">
                            <span class="forecast-day-label">√úbermorgen</span>
                            <span class="forecast-day-total">{{ forecast.dayAfterTomorrowTotal?.toFixed(2) || '‚Äî' }} kWh</span>
                        </div>
                        <div class="forecast-day-details">
                            <span class="forecast-detail" v-if="forecast.dayAfterTomorrowHours.length > 0">
                                <span style="color: var(--neon-yellow);">üèÜ</span> Beste: {{ Math.max(...forecast.dayAfterTomorrowHours.map(h => h.kwh)).toFixed(2) }} kWh
                            </span>
                        </div>
                        <div class="forecast-hourly-bars">
                            <div v-for="h in forecast.dayAfterTomorrowHours" :key="'dayafter-'+h.hour" class="forecast-bar-wrapper" :title="h.hour + ':00 - ' + h.kwh.toFixed(2) + ' kWh'">
                                <div class="forecast-bar dayafter-bar" :style="{height: (h.kwh / forecast.maxHourly * 100) + '%'}"></div>
                                <span class="forecast-bar-label">{{ h.hour }}</span>
                            </div>
                            <div v-if="forecast.dayAfterTomorrowHours.length === 0" class="forecast-no-data">Keine Daten</div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Tagesproduktion Chart (direkt unter Energiefluss) -->
            <section class="chart-card sortable-item" data-section="todayProduction" style="margin-bottom: var(--spacing-lg);">
                <div class="chart-header" @click="openProductionTodayModal" style="cursor: pointer;">
                    <div class="chart-title">üìÖ Tages-Energieertrag (Echtzeit-Scan)</div>
                    <div class="chart-stats">
                        <span class="chart-stat" style="color: #00ff88;">Ertrag: {{ energyFlow.statistics.solar_yield_daily?.toFixed(2) || '‚Äî' }} kWh</span>
                        <span class="chart-stat" style="color: #8b5cf6;">Prognose: {{ forecast.todayTotal?.toFixed(2) || '‚Äî' }} kWh</span>
                        <span class="chart-stat" :style="{color: todayAccuracy >= 80 ? '#00ff88' : todayAccuracy >= 50 ? '#ffdd00' : '#ef4444'}">
                            Genauigkeit: {{ todayAccuracy?.toFixed(0) || '‚Äî' }}%
                        </span>
                    </div>
                </div>
                <div class="chart-container tall" ref="todayProductionChart"></div>
            </section>

            <!-- Panel-Gruppen Produktion (Prognose vs IST pro Gruppe) -->
            <section class="collapsible-section sortable-item" data-section="panelGroups" style="margin-bottom: var(--spacing-lg);" v-if="panelGroups.available">
                <div class="section-header" @click="toggleSection('panelGroups')">
                    <span class="section-title">‚òÄÔ∏è Panel-Gruppen</span>
                    <span class="section-toggle">{{ isSectionCollapsed('panelGroups') ? '+' : '‚àí' }}</span>
                </div>
                <!-- Validierungswarnung -->
                <div v-if="!panelGroupsValidation.valid && !isSectionCollapsed('panelGroups')" class="validation-warning">
                    ‚ö†Ô∏è Abweichung: Gruppen-Summe ({{ panelGroupsValidation.groupSum }} kWh) vs. Tagesertrag ({{ panelGroupsValidation.solarDaily }} kWh) = {{ panelGroupsValidation.deviation }}%
                </div>
                <div class="top-row" v-show="!isSectionCollapsed('panelGroups')">
                    <template v-for="(group, groupName) in panelGroups.groups" :key="groupName">
                        <div class="chart-card panel-group-chart">
                            <div class="chart-header" @click="openPanelGroupModal(groupName)" style="cursor: pointer;">
                                <div class="chart-title">‚òÄÔ∏è {{ groupName }}</div>
                                <div class="chart-stats">
                                    <span class="chart-stat" style="color: #00ff88;">IST: {{ group.actual_total_kwh?.toFixed(3) || '0.000' }} kWh</span>
                                    <span class="chart-stat" style="color: #8b5cf6;">Prognose: {{ group.prediction_total_kwh?.toFixed(3) || '0.000' }} kWh</span>
                                    <span class="chart-stat" :style="{color: (group.accuracy_percent || 0) >= 80 ? '#00ff88' : (group.accuracy_percent || 0) >= 50 ? '#ffdd00' : '#ef4444'}">
                                        {{ group.accuracy_percent?.toFixed(0) || '‚Äî' }}%
                                    </span>
                                </div>
                            </div>
                            <div class="chart-container" :ref="el => panelGroupChartRefs[groupName] = el" style="height: 200px;"></div>
                        </div>
                    </template>
                </div>
            </section>

            <!-- Live Energy Flow Widgets - Stil wie Wetter -->
            <section class="collapsible-section sortable-item" data-section="liveWidgets" style="margin-bottom: var(--spacing-lg);">
                <div class="section-header" @click="toggleSection('liveWidgets')">
                    <span class="section-title">‚ö° Live Energie-Widgets</span>
                    <span class="section-toggle">{{ isSectionCollapsed('liveWidgets') ? '+' : '‚àí' }}</span>
                </div>
                <div v-show="!isSectionCollapsed('liveWidgets')" class="top-row">
                    <!-- Gruppe 1: Solar Live -->
                    <div class="widget-group-container">
                    <span class="widget-group-label">‚òÄÔ∏è Fusionsreaktor</span>
                    <!-- Solar ‚Üí Haus -->
                    <div class="weather-widget" style="border-color: #ffdd00;">
                        <div class="weather-main">
                            <div class="weather-icon">‚òÄÔ∏èüè†</div>
                            <div>
                                <div class="weather-temp" style="color: #ffdd00;">{{ energyFlow.flows.solar_to_house?.toFixed(0) || '0' }} W</div>
                                <div style="color: var(--text-muted); font-size: 0.8rem;">Solar ‚Üí Haus</div>
                            </div>
                        </div>
                        <div class="weather-details">
                            <div class="weather-detail"><span>‚ö°</span><span>{{ energyFlow.flows.solar_power?.toFixed(0) || '0' }} W total</span></div>
                            <div class="weather-detail"><span>üìä</span><span>{{ energyFlow.statistics.solar_yield_daily?.toFixed(2) || '0' }} kWh</span></div>
                        </div>
                    </div>
                    <!-- Solar ‚Üí Akku -->
                    <div v-if="hasBattery" class="weather-widget" style="border-color: #ffdd00;">
                        <div class="weather-main">
                            <div class="weather-icon">‚òÄÔ∏èüîã</div>
                            <div>
                                <div class="weather-temp" style="color: #ffdd00;">{{ energyFlow.flows.solar_to_battery?.toFixed(0) || '0' }} W</div>
                                <div style="color: var(--text-muted); font-size: 0.8rem;">Solar ‚Üí Akku</div>
                            </div>
                        </div>
                        <div class="weather-details">
                            <div class="weather-detail"><span>üîã</span><span>{{ energyFlow.battery.soc?.toFixed(0) || '0' }}% SOC</span></div>
                            <div class="weather-detail"><span>üìà</span><span>{{ energyFlow.statistics.battery_charge_solar_daily?.toFixed(2) || '0' }} kWh</span></div>
                        </div>
                    </div>
                </div>

                <!-- Gruppe 2: Akku Live (nur wenn Batterie vorhanden) -->
                <div v-if="hasBattery" class="widget-group-container">
                    <span class="widget-group-label">üîã Dilithium-Kammer</span>
                    <!-- Akku ‚Üí Haus -->
                    <div class="weather-widget" style="border-color: #22c55e;">
                        <div class="weather-main">
                            <div class="weather-icon">üîãüè†</div>
                            <div>
                                <div class="weather-temp" style="color: #22c55e;">{{ energyFlow.flows.battery_to_house?.toFixed(0) || '0' }} W</div>
                                <div style="color: var(--text-muted); font-size: 0.8rem;">Akku ‚Üí Haus</div>
                            </div>
                        </div>
                        <div class="weather-details">
                            <div class="weather-detail"><span>üîã</span><span>{{ energyFlow.battery.soc?.toFixed(0) || '0' }}% SOC</span></div>
                            <div class="weather-detail"><span>‚ö°</span><span>{{ energyFlow.battery.power?.toFixed(0) || '0' }} W</span></div>
                        </div>
                    </div>
                    <!-- Netz ‚Üí Akku -->
                    <div class="weather-widget" style="border-color: #22c55e;">
                        <div class="weather-main">
                            <div class="weather-icon">‚ö°üîã</div>
                            <div>
                                <div class="weather-temp" style="color: #22c55e;">{{ energyFlow.flows.grid_to_battery?.toFixed(0) || '0' }} W</div>
                                <div style="color: var(--text-muted); font-size: 0.8rem;">Netz ‚Üí Akku</div>
                            </div>
                        </div>
                        <div class="weather-details">
                            <div class="weather-detail"><span>üìà</span><span>{{ energyFlow.statistics.battery_charge_grid_daily?.toFixed(2) || '0' }} kWh</span></div>
                            <div class="weather-detail"><span>üí∞</span><span>{{ currentPrice.total_price?.toFixed(2) || '‚Äî' }} ct/kWh</span></div>
                        </div>
                    </div>
                </div>

                <!-- Gruppe 3: Netz Live -->
                <div class="widget-group-container">
                    <span class="widget-group-label">‚ö° Energienetz</span>
                    <!-- Netz ‚Üí Haus -->
                    <div class="weather-widget" style="border-color: #8b5cf6;">
                        <div class="weather-main">
                            <div class="weather-icon">‚ö°üè†</div>
                            <div>
                                <div class="weather-temp" style="color: #8b5cf6;">{{ energyFlow.flows.grid_to_house?.toFixed(0) || '0' }} W</div>
                                <div style="color: var(--text-muted); font-size: 0.8rem;">Netz ‚Üí Haus</div>
                            </div>
                        </div>
                        <div class="weather-details">
                            <div class="weather-detail"><span>üìä</span><span>{{ energyFlow.statistics.grid_import_daily?.toFixed(2) || '0' }} kWh heute</span></div>
                            <div class="weather-detail"><span>üí∞</span><span>{{ currentPrice.total_price?.toFixed(2) || '‚Äî' }} ct/kWh</span></div>
                        </div>
                    </div>
                    <!-- Einspeisung -->
                    <div class="weather-widget" style="border-color: #00ffff;">
                        <div class="weather-main">
                            <div class="weather-icon">üè†‚ö°</div>
                            <div>
                                <div class="weather-temp" style="color: #00ffff;">{{ energyFlow.flows.house_to_grid?.toFixed(0) || '0' }} W</div>
                                <div style="color: var(--text-muted); font-size: 0.8rem;">Einspeisung</div>
                            </div>
                        </div>
                        <div class="weather-details">
                            <div class="weather-detail"><span>üè†</span><span>{{ energyFlow.home.consumption?.toFixed(0) || '0' }} W Verbrauch</span></div>
                            <div class="weather-detail"><span>üíµ</span><span>{{ energyFlow.feed_in_tariff?.toFixed(1) || '8.1' }} ct/kWh Verg√ºtung</span></div>
                        </div>
                    </div>
                </div>

                <!-- Gruppe 4: Haus Live -->
                <div class="widget-group-container">
                    <span class="widget-group-label">üè† Lebenserhaltung</span>
                    <!-- Verbrauch -->
                    <div class="weather-widget" style="border-color: #00ffff;">
                        <div class="weather-main">
                            <div class="weather-icon">üè†</div>
                            <div>
                                <div class="weather-temp" style="color: #00ffff;">{{ energyFlow.home.consumption?.toFixed(0) || '0' }} W</div>
                                <div style="color: var(--text-muted); font-size: 0.8rem;">Verbrauch</div>
                            </div>
                        </div>
                        <div class="weather-details">
                            <div class="weather-detail"><span>‚òÄÔ∏è</span><span>{{ energyFlow.flows.solar_to_house?.toFixed(0) || '0' }} W Solar</span></div>
                            <div v-if="hasBattery" class="weather-detail"><span>üîã</span><span>{{ energyFlow.flows.battery_to_house?.toFixed(0) || '0' }} W Akku</span></div>
                            <div class="weather-detail"><span>‚ö°</span><span>{{ energyFlow.flows.grid_to_house?.toFixed(0) || '0' }} W Netz</span></div>
                        </div>
                    </div>
                    <!-- Autarkie -->
                    <div class="weather-widget" style="border-color: #00ff88;">
                        <div class="weather-main">
                            <div class="weather-icon">üå±</div>
                            <div>
                                <div class="weather-temp" style="color: #00ff88;">{{ energyFlow.home.consumption > 0 ? Math.min(100, Math.max(0, (1 - (energyFlow.flows.grid_to_house || 0) / energyFlow.home.consumption) * 100)).toFixed(0) : '0' }}%</div>
                                <div style="color: var(--text-muted); font-size: 0.8rem;">Autarkie</div>
                            </div>
                        </div>
                        <div class="weather-details">
                            <div class="weather-detail"><span>‚òÄÔ∏è</span><span>{{ energyFlow.statistics.solar_yield_daily?.toFixed(2) || '0' }} kWh Ertrag</span></div>
                            <div class="weather-detail"><span>üìä</span><span>{{ energyFlow.statistics.grid_import_daily?.toFixed(2) || '0' }} kWh Bezug</span></div>
                        </div>
                    </div>
                </div>
                </div><!-- Ende v-show liveWidgets -->
            </section>

            <!-- ========== ENERGIE-BILANZ WIDGET (JAHRESBILANZ) ========== -->
            <section class="energy-balance-container collapsible-section sortable-item" data-section="energyBalance">
                <div class="energy-balance-header">
                    <div class="energy-balance-title">
                        <span>üí∞</span> Sternenflotten-Abrechnung
                    </div>
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <a href="/api/sfml_stats/tariffs" class="tariff-link-btn" title="Monatliche Tarife verwalten (EEG/Energy Sharing)">
                            üìä Tarife
                        </a>
                        <div class="energy-balance-period">
                            <span v-if="energyBalance.periodStart">
                                üìÖ {{ energyBalance.periodStart }} bis {{ energyBalance.periodEnd }}
                            </span>
                            <span v-else>üìÖ Missions-Zeitraum</span>
                        </div>
                        <button class="section-collapse-btn" @click="toggleSection('energyBalance')" :title="isSectionCollapsed('energyBalance') ? 'Ausklappen' : 'Einklappen'">
                            {{ isSectionCollapsed('energyBalance') ? '+' : '‚àí' }}
                        </button>
                    </div>
                </div>

                <!-- Einklappbarer Inhalt -->
                <div v-show="!isSectionCollapsed('energyBalance')">
                    <!-- Fortschrittsbalken f√ºr Abrechnungszeitraum -->
                    <div style="margin-bottom: var(--spacing-md);">
                        <div style="display: flex; justify-content: space-between; font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px;">
                            <span>Tag {{ energyBalance.daysElapsed }} von {{ energyBalance.daysTotal }}</span>
                            <span>{{ energyBalance.periodProgress?.toFixed(0) || 0 }}% des Abrechnungsjahres</span>
                        </div>
                        <div style="height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden;">
                            <div :style="{width: energyBalance.periodProgress + '%', height: '100%', background: 'linear-gradient(90deg, #00ff88, #00ffff)', borderRadius: '3px', transition: 'width 0.5s'}"></div>
                        </div>
                    </div>

                    <!-- ===== BLOCK 1: HAUSHALT ===== -->
                <div style="margin-bottom: var(--spacing-md);">
                    <div style="font-size: 0.9rem; font-weight: 600; color: var(--neon-cyan); margin-bottom: var(--spacing-sm); display: flex; align-items: center; gap: 8px;">
                        <span>üè†</span> Gesamtverbrauch Haushalt
                    </div>
                    <div class="energy-balance-grid">
                        <div class="energy-balance-item total">
                            <div class="energy-balance-icon">üè†</div>
                            <div class="energy-balance-value yellow">{{ energyBalance.homeConsumption?.toFixed(1) || '0.0' }}</div>
                            <div class="energy-balance-label">kWh Gesamt</div>
                            <div class="energy-balance-sub">Verbrauch im Zeitraum</div>
                        </div>
                        <div class="energy-balance-item solar">
                            <div class="energy-balance-icon">‚òÄÔ∏èüè†</div>
                            <div class="energy-balance-value yellow">{{ energyBalance.solarToHouse?.toFixed(1) || '0.0' }}</div>
                            <div class="energy-balance-label">davon Solar</div>
                            <div class="energy-balance-sub">Direktverbrauch</div>
                        </div>
                        <div class="energy-balance-item battery">
                            <div class="energy-balance-icon">üîãüè†</div>
                            <div class="energy-balance-value green">{{ energyBalance.batteryToHouse?.toFixed(1) || '0.0' }}</div>
                            <div class="energy-balance-label">davon Akku</div>
                            <div class="energy-balance-sub">Aus Speicher</div>
                        </div>
                        <div class="energy-balance-item grid">
                            <div class="energy-balance-icon">‚ö°üè†</div>
                            <div class="energy-balance-value purple">{{ energyBalance.gridToHouse?.toFixed(1) || '0.0' }}</div>
                            <div class="energy-balance-label">davon Netz</div>
                            <div class="energy-balance-sub">Bezahlt!</div>
                        </div>
                    </div>
                </div>

                <!-- ===== BLOCK 2: AKKU (nur wenn Batterie vorhanden) ===== -->
                <div v-if="hasBattery" style="margin-bottom: var(--spacing-md);">
                    <div style="font-size: 0.9rem; font-weight: 600; color: var(--neon-green); margin-bottom: var(--spacing-sm); display: flex; align-items: center; gap: 8px;">
                        <span>üîã</span> Gesamtladung Akku
                    </div>
                    <div class="energy-balance-grid">
                        <div class="energy-balance-item battery">
                            <div class="energy-balance-icon">üîã</div>
                            <div class="energy-balance-value green">{{ energyBalance.batteryChargeTotal?.toFixed(1) || '0.0' }}</div>
                            <div class="energy-balance-label">kWh Gesamt</div>
                            <div class="energy-balance-sub">Geladen im Zeitraum</div>
                        </div>
                        <div class="energy-balance-item solar">
                            <div class="energy-balance-icon">‚òÄÔ∏èüîã</div>
                            <div class="energy-balance-value yellow">{{ energyBalance.solarToBattery?.toFixed(1) || '0.0' }}</div>
                            <div class="energy-balance-label">davon Solar</div>
                            <div class="energy-balance-sub">Kostenlos!</div>
                        </div>
                        <div class="energy-balance-item grid">
                            <div class="energy-balance-icon">‚ö°üîã</div>
                            <div class="energy-balance-value purple">{{ energyBalance.gridToBattery?.toFixed(1) || '0.0' }}</div>
                            <div class="energy-balance-label">davon Netz</div>
                            <div class="energy-balance-sub">Bezahlt!</div>
                        </div>
                    </div>
                </div>

                <!-- ===== BLOCK 3: GESAMT & FINANZEN ===== -->
                <div style="margin-bottom: var(--spacing-md);">
                    <div style="font-size: 0.9rem; font-weight: 600; color: var(--neon-yellow); margin-bottom: var(--spacing-sm); display: flex; align-items: center; gap: 8px;">
                        <span>üìä</span> √úbersicht & Finanzen
                    </div>
                    <div class="energy-balance-grid">
                        <div class="energy-balance-item solar">
                            <div class="energy-balance-icon">‚òÄÔ∏è</div>
                            <div class="energy-balance-value yellow">{{ energyBalance.solarProduction?.toFixed(1) || '0.0' }}</div>
                            <div class="energy-balance-label">kWh Solar Gesamt</div>
                            <div class="energy-balance-sub">√ò {{ energyBalance.avgDailyProduction?.toFixed(1) || 0 }} kWh/Tag</div>
                        </div>
                        <div class="energy-balance-item grid">
                            <div class="energy-balance-icon">‚ö°</div>
                            <div class="energy-balance-value purple">{{ energyBalance.gridImport?.toFixed(1) || '0.0' }}</div>
                            <div class="energy-balance-label">kWh Netz Gesamt</div>
                            <div class="energy-balance-sub">Haus + Akkuladung</div>
                        </div>
                        <div class="energy-balance-item grid" v-if="energyBalance.gridExport > 0">
                            <div class="energy-balance-icon">‚ö°‚ÜóÔ∏è</div>
                            <div class="energy-balance-value cyan">{{ energyBalance.gridExport?.toFixed(1) || '0.0' }}</div>
                            <div class="energy-balance-label">kWh Einspeisung</div>
                            <div class="energy-balance-sub">Ins Netz</div>
                        </div>

                        <!-- Autarkie Donut -->
                        <div class="energy-balance-item autarkie autarkie-donut-container">
                            <div class="autarkie-donut">
                                <svg width="100" height="100" viewBox="0 0 120 120">
                                    <circle class="autarkie-donut-bg" cx="60" cy="60" r="50"/>
                                    <circle class="autarkie-donut-progress" cx="60" cy="60" r="50"
                                        :stroke-dasharray="314.16"
                                        :stroke-dashoffset="314.16 - (314.16 * (energyBalance.autarkiePercent || 0) / 100)"
                                        :style="{stroke: energyBalance.autarkiePercent >= 70 ? '#00ff88' : energyBalance.autarkiePercent >= 40 ? '#ffdd00' : '#8b5cf6'}"/>
                                </svg>
                                <div class="autarkie-donut-text">
                                    <div class="autarkie-donut-value" :style="{color: energyBalance.autarkiePercent >= 70 ? '#00ff88' : energyBalance.autarkiePercent >= 40 ? '#ffdd00' : '#8b5cf6'}">
                                        {{ energyBalance.autarkiePercent?.toFixed(0) || 0 }}%
                                    </div>
                                    <div class="autarkie-donut-label">Autarkie</div>
                                </div>
                            </div>
                        </div>

                        <div class="energy-balance-item cost" v-if="energyBalance.priceMode !== 'none'">
                            <div class="energy-balance-icon">üí∞</div>
                            <div class="energy-balance-value purple">{{ energyBalance.estimatedCost?.toFixed(2) || '0.00' }}</div>
                            <div class="energy-balance-label">‚Ç¨ Stromkosten</div>
                            <div class="energy-balance-sub">√ò {{ energyBalance.avgPrice?.toFixed(1) || 35 }} ct/kWh</div>
                        </div>
                        <div class="energy-balance-item savings" v-if="energyBalance.priceMode !== 'none'">
                            <div class="energy-balance-icon">üíö</div>
                            <div class="energy-balance-value green">{{ energyBalance.savings?.toFixed(2) || '0.00' }}</div>
                            <div class="energy-balance-label">‚Ç¨ gespart</div>
                            <div class="energy-balance-sub">durch {{ energyBalance.savedKwh?.toFixed(0) || 0 }} kWh Solar</div>
                        </div>
                        <div class="energy-balance-item projection" v-if="energyBalance.priceMode !== 'none' && energyBalance.projectedYearlySavings">
                            <div class="energy-balance-icon">üìà</div>
                            <div class="energy-balance-value cyan">{{ energyBalance.projectedYearlySavings?.toFixed(0) || '‚Äî' }}</div>
                            <div class="energy-balance-label">‚Ç¨ Hochrechnung</div>
                            <div class="energy-balance-sub">Jahres-Ersparnis</div>
                        </div>
                    </div>
                </div>

                <!-- Recorder Info -->
                <div v-if="energyBalance.recorderAvailable" style="font-size: 0.7rem; color: var(--text-muted); text-align: center; margin-top: var(--spacing-sm);">
                    üìä {{ energyBalance.recorderSamples?.toLocaleString() || 0 }} Datenpunkte aus Recorder
                </div>

                <!-- Verbrauch-Breakdown Bar (Prozent-Anteile) -->
                <div class="energy-breakdown" v-if="energyBalance.homeConsumption > 0">
                    <div class="energy-breakdown-title">Stromherkunft im Zeitraum</div>
                    <div class="energy-breakdown-bar">
                        <div class="energy-breakdown-segment solar"
                             :style="{width: energyBalance.solarSelfPercent + '%'}"
                             v-if="energyBalance.solarSelfPercent > 3">
                            {{ energyBalance.solarSelfPercent?.toFixed(0) }}%
                        </div>
                        <div class="energy-breakdown-segment battery"
                             :style="{width: energyBalance.batteryPercent + '%'}"
                             v-if="energyBalance.batteryPercent > 3">
                            {{ energyBalance.batteryPercent?.toFixed(0) }}%
                        </div>
                        <div class="energy-breakdown-segment grid"
                             :style="{width: energyBalance.gridPercent + '%'}"
                             v-if="energyBalance.gridPercent > 3">
                            {{ energyBalance.gridPercent?.toFixed(0) }}%
                        </div>
                    </div>
                    <div class="energy-breakdown-legend">
                        <div class="energy-breakdown-legend-item">
                            <span class="energy-breakdown-legend-dot solar"></span>
                            <span>Solar direkt</span>
                        </div>
                        <div class="energy-breakdown-legend-item">
                            <span class="energy-breakdown-legend-dot battery"></span>
                            <span>√úber Akku</span>
                        </div>
                        <div class="energy-breakdown-legend-item">
                            <span class="energy-breakdown-legend-dot grid"></span>
                            <span>Aus Netz</span>
                        </div>
                    </div>
                </div>

                    <!-- Hinweis zur Konfiguration -->
                    <div v-if="!energyBalance.periodStart" style="margin-top: var(--spacing-md); padding: var(--spacing-sm); background: rgba(139, 92, 246, 0.1); border-radius: var(--radius-sm); font-size: 0.75rem; color: var(--text-muted); text-align: center;">
                        üí° Konfiguriere deinen Abrechnungszeitraum in den Integrationseinstellungen unter "Stromrechnung & Abrechnung"
                    </div>
                </div><!-- Ende v-show energyBalance -->
            </section>

            <!-- KPIs -->
            <section class="kpi-grid collapsible-section sortable-item" data-section="kpis">
                <div class="section-header" @click="toggleSection('kpis')" style="grid-column: 1 / -1;">
                    <span class="section-title">üìä Wochen-KPIs</span>
                    <span class="section-toggle">{{ isSectionCollapsed('kpis') ? '+' : '‚àí' }}</span>
                </div>
                <div v-show="!isSectionCollapsed('kpis')" class="kpi-card solar">
                    <div class="kpi-value">{{ kpis.weekProduction?.toFixed(2) || '‚Äî' }}</div>
                    <div class="kpi-label">kWh diese Woche</div>
                </div>
                <div v-show="!isSectionCollapsed('kpis')" class="kpi-card accuracy">
                    <div class="kpi-value">{{ kpis.avgAccuracy?.toFixed(0) || '‚Äî' }}%</div>
                    <div class="kpi-label">√ò Genauigkeit</div>
                </div>
                <div v-show="!isSectionCollapsed('kpis')" class="kpi-card price">
                    <div class="kpi-value">{{ kpis.priceMin?.toFixed(0) || '‚Äî' }}-{{ kpis.priceMax?.toFixed(0) || '‚Äî' }}</div>
                    <div class="kpi-label">ct/kWh Spanne</div>
                </div>
                <div v-show="!isSectionCollapsed('kpis')" class="kpi-card forecast">
                    <div class="kpi-value">{{ kpis.forecastWeek?.toFixed(1) || '‚Äî' }}</div>
                    <div class="kpi-label">kWh Prognose</div>
                </div>
            </section>

            <!-- Charts -->
            <section class="charts-grid collapsible-section sortable-item" data-section="mainCharts">
                <div class="section-header" @click="toggleSection('mainCharts')" style="grid-column: 1 / -1;">
                    <span class="section-title">üìà Haupt-Charts</span>
                    <span class="section-toggle">{{ isSectionCollapsed('mainCharts') ? '+' : '‚àí' }}</span>
                </div>
                <div v-show="!isSectionCollapsed('mainCharts')" class="chart-card">
                    <div class="chart-title">Produktion vs. Vorhersage</div>
                    <div class="chart-container" ref="productionChart"></div>
                </div>
                <div v-show="!isSectionCollapsed('mainCharts')" class="chart-card">
                    <div class="chart-header">
                        <div class="chart-title">üìä Prognose-Abweichung (0 = Treffer)</div>
                        <div class="chart-stats">
                            <span class="chart-stat" style="color: #00ff88;">+ Mehr produziert als prognostiziert</span>
                            <span class="chart-stat" style="color: #ef4444;">‚àí Weniger produziert</span>
                        </div>
                    </div>
                    <div class="chart-container" ref="accuracyChart"></div>
                </div>
                <div v-show="!isSectionCollapsed('mainCharts')" v-if="energyBalance.priceMode === 'dynamic'" class="chart-card">
                    <div class="chart-header">
                        <div class="chart-title">Strompreise Heute vs. Morgen (Endpreis)</div>
                        <div class="chart-stats">
                            <span class="chart-stat" style="color: #ff0080;">Heute: {{ priceStats.min }}-{{ priceStats.max }} ct</span>
                            <span class="chart-stat" style="color: #00ffff;">Morgen: {{ priceStatsTomorrow.min }}-{{ priceStatsTomorrow.max }} ct</span>
                        </div>
                    </div>
                    <div class="chart-container" ref="priceChart"></div>
                </div>
                <div v-show="!isSectionCollapsed('mainCharts')" class="chart-card full-width">
                    <div class="chart-title">Wochenverlauf</div>
                    <div class="chart-container tall" ref="timelineChart"></div>
                </div>
            </section>

            <!-- KI-Status -->
            <section v-if="aiStatus.loaded" class="collapsible-section sortable-item" data-section="aiStatus" style="margin-top: var(--spacing-lg);">
                <div class="section-header" @click="toggleSection('aiStatus')">
                    <span class="section-title">üß† KI-Status</span>
                    <span class="section-toggle">{{ isSectionCollapsed('aiStatus') ? '+' : '‚àí' }}</span>
                </div>
                <div v-show="!isSectionCollapsed('aiStatus')" class="ai-status-bar">
                    <div class="ai-status-item">
                        <span class="ai-status-label">Modell</span>
                        <span class="ai-status-value" style="color: #a78bfa;">{{ aiStatus.model }}</span>
                    </div>
                    <div class="ai-status-item">
                        <span class="ai-status-label">Genauigkeit</span>
                        <span class="ai-status-value" style="color: #10b981;">{{ aiStatus.accuracy }}%</span>
                    </div>
                    <div class="ai-status-item">
                        <span class="ai-status-label">RMSE</span>
                        <span class="ai-status-value">{{ aiStatus.rmse }}</span>
                    </div>
                    <div class="ai-status-item">
                        <span class="ai-status-label">Samples</span>
                        <span class="ai-status-value" style="color: #38bdf8;">{{ aiStatus.samples }}</span>
                    </div>
                    <div class="ai-status-item">
                        <span class="ai-status-label">Datenpunkte</span>
                        <span class="ai-status-value">{{ aiStatus.dataPoints }}</span>
                    </div>
                    <div class="ai-status-item">
                        <span class="ai-status-label">Letztes Training</span>
                        <span class="ai-status-value">{{ aiStatus.lastTrained }}</span>
                    </div>
                    <div class="ai-status-item">
                        <span class="ai-status-label">Grid Search</span>
                        <span class="ai-status-value">{{ aiStatus.gridRuns }} Runs</span>
                    </div>
                    <div class="ai-status-item">
                        <span class="ai-status-label">Drift-Events (7d)</span>
                        <span class="ai-status-value" :style="{ color: aiStatus.driftEvents > 0 ? '#f59e0b' : '#10b981' }">{{ aiStatus.driftEvents }}</span>
                    </div>
                </div>
            </section>
        </main>

        <!-- Solar Analytics Modal -->
        <div v-if="solarModal.isOpen" class="modal-overlay" @click.self="closeSolarModal">
            <div class="modal-container">
                <div class="modal-header">
                    <h2 class="modal-title">
                        <span>‚òÄÔ∏è</span>
                        <span>Solar Analytics</span>
                    </h2>
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <button class="modal-export-btn" @click="exportSolarAnalytics" :disabled="solarModal.exporting">
                            <span v-if="!solarModal.exporting">üìä PNG Export</span>
                            <span v-else>‚è≥ Exportiere...</span>
                        </button>
                        <button class="modal-close" @click="closeSolarModal">√ó</button>
                    </div>
                </div>
                <div class="modal-body">
                    <!-- Quick Stats -->
                    <div class="modal-stats-grid">
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ solarModal.stats.weekTotal?.toFixed(2) || '‚Äî' }} kWh</div>
                            <div class="modal-stat-label">Diese Woche</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ solarModal.stats.monthTotal?.toFixed(2) || '‚Äî' }} kWh</div>
                            <div class="modal-stat-label">Dieser Monat</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ solarModal.stats.yearTotal?.toFixed(2) || '‚Äî' }} kWh</div>
                            <div class="modal-stat-label">Dieses Jahr</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ solarModal.stats.avgAccuracy?.toFixed(1) || '‚Äî' }}%</div>
                            <div class="modal-stat-label">√ò Genauigkeit</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ solarModal.stats.peakPower?.toFixed(0) || '‚Äî' }} W</div>
                            <div class="modal-stat-label">Peak Leistung</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ solarModal.stats.avgDaily?.toFixed(2) || '‚Äî' }} kWh</div>
                            <div class="modal-stat-label">√ò pro Tag</div>
                        </div>
                    </div>

                    <!-- Tabs -->
                    <div class="modal-tabs">
                        <button class="modal-tab" :class="{ active: solarModal.activeTab === 'week' }" @click="solarModal.activeTab = 'week'">
                            Letzte 7 Tage
                        </button>
                        <button class="modal-tab" :class="{ active: solarModal.activeTab === 'month' }" @click="solarModal.activeTab = 'month'">
                            Letzter Monat
                        </button>
                        <button class="modal-tab" :class="{ active: solarModal.activeTab === 'year' }" @click="solarModal.activeTab = 'year'">
                            Dieses Jahr
                        </button>
                    </div>

                    <!-- Charts -->
                    <div class="modal-chart-grid">
                        <!-- Production Chart -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>üìä</span>
                                <span>Produktion vs. Prognose</span>
                            </div>
                            <div id="solar-production-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Peak Times Heatmap -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>üî•</span>
                                <span>Peak-Zeiten Heatmap</span>
                            </div>
                            <div id="solar-heatmap-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Accuracy Timeline -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>üéØ</span>
                                <span>Prognose-Genauigkeit</span>
                            </div>
                            <div id="solar-accuracy-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Panel Group Performance (nur bei mehr als 1 Gruppe anzeigen) -->
                        <div class="modal-chart-container" v-if="panelGroups.available && !hasSinglePanelGroup">
                            <div class="modal-chart-title">
                                <span>‚ö°</span>
                                <span>Panel-Gruppen Performance</span>
                            </div>
                            <div id="solar-panel-group-chart" style="height: 350px;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ===== BATTERY MODAL ===== -->
        <div v-if="batteryModal.isOpen" class="modal-overlay" @click.self="closeBatteryModal">
            <div class="modal-container battery-modal">
                <div class="modal-header">
                    <h2 class="modal-title">
                        <span>üîã</span>
                        <span>Battery Analytics</span>
                    </h2>
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <button class="modal-export-btn" @click="exportBatteryAnalytics" :disabled="batteryModal.exporting">
                            <span v-if="!batteryModal.exporting">üìä PNG Export</span>
                            <span v-else>‚è≥ Exportiere...</span>
                        </button>
                        <button class="modal-close" @click="closeBatteryModal">√ó</button>
                    </div>
                </div>
                <div class="modal-body">
                    <!-- Quick Stats -->
                    <div class="modal-stats-grid">
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ batteryModal.stats.weekCharged?.toFixed(2) || '‚Äî' }} kWh</div>
                            <div class="modal-stat-label">Geladen (Mo-So)</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ batteryModal.stats.weekDischarged?.toFixed(2) || '‚Äî' }} kWh</div>
                            <div class="modal-stat-label">Entladen (Mo-So)</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ batteryModal.stats.avgSOC?.toFixed(0) || '‚Äî' }}%</div>
                            <div class="modal-stat-label">Aktueller SOC</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ batteryModal.stats.efficiency?.toFixed(1) || '‚Äî' }}%</div>
                            <div class="modal-stat-label">Wirkungsgrad</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ batteryModal.stats.cycles?.toFixed(1) || '‚Äî' }}</div>
                            <div class="modal-stat-label">Zyklen (Monat)</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ batteryModal.stats.solarShare?.toFixed(0) || '‚Äî' }}%</div>
                            <div class="modal-stat-label">Solar-Anteil</div>
                        </div>
                    </div>

                    <!-- Tabs -->
                    <div class="modal-tabs">
                        <button class="modal-tab" :class="{ active: batteryModal.activeTab === 'week' }" @click="batteryModal.activeTab = 'week'">
                            Letzte 7 Tage
                        </button>
                        <button class="modal-tab" :class="{ active: batteryModal.activeTab === 'month' }" @click="batteryModal.activeTab = 'month'">
                            Letzter Monat
                        </button>
                        <button class="modal-tab" :class="{ active: batteryModal.activeTab === 'year' }" @click="batteryModal.activeTab = 'year'">
                            Dieses Jahr
                        </button>
                    </div>

                    <!-- Charts -->
                    <div class="modal-chart-grid">
                        <!-- Charge Sources Chart -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>üìä</span>
                                <span>Ladequellen (Solar vs Netz)</span>
                            </div>
                            <div id="battery-soc-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Charge/Discharge Chart -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>‚ö°</span>
                                <span>Laden / Entladen</span>
                            </div>
                            <div id="battery-charge-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Efficiency Chart -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>üéØ</span>
                                <span>Wirkungsgrad</span>
                            </div>
                            <div id="battery-efficiency-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Charge/Discharge Sources per Day -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>üìà</span>
                                <span>Lade-/Entlade-Verlauf</span>
                            </div>
                            <div id="battery-power-chart" style="height: 350px;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ===== HOUSE MODAL ===== -->
        <div v-if="houseModal.isOpen" class="modal-overlay" @click.self="closeHouseModal">
            <div class="modal-container house-modal">
                <div class="modal-header">
                    <h2 class="modal-title">
                        <span>üè†</span>
                        <span>Haus Analytics</span>
                    </h2>
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <button class="modal-export-btn" @click="exportHouseAnalytics" :disabled="houseModal.exporting">
                            <span v-if="!houseModal.exporting">üìä PNG Export</span>
                            <span v-else>‚è≥ Exportiere...</span>
                        </button>
                        <button class="modal-close" @click="closeHouseModal">√ó</button>
                    </div>
                </div>
                <div class="modal-body">
                    <!-- Quick Stats -->
                    <div class="modal-stats-grid">
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ houseModal.stats.weekConsumption?.toFixed(2) || '‚Äî' }} kWh</div>
                            <div class="modal-stat-label">Verbrauch (Mo-So)</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ houseModal.stats.avgDaily?.toFixed(2) || '‚Äî' }} kWh</div>
                            <div class="modal-stat-label">√ò pro Tag</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ houseModal.stats.autarky?.toFixed(1) || '‚Äî' }}%</div>
                            <div class="modal-stat-label">Autarkie</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ houseModal.stats.selfConsumption?.toFixed(1) || '‚Äî' }}%</div>
                            <div class="modal-stat-label">Eigenverbrauch</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ houseModal.stats.solarCoverage?.toFixed(1) || '‚Äî' }}%</div>
                            <div class="modal-stat-label">Solar-Abdeckung</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ houseModal.stats.peakPower?.toFixed(0) || '‚Äî' }} Wh</div>
                            <div class="modal-stat-label">Peak Stunde</div>
                        </div>
                    </div>

                    <!-- Tabs -->
                    <div class="modal-tabs">
                        <button class="modal-tab" :class="{ active: houseModal.activeTab === 'week' }" @click="houseModal.activeTab = 'week'">
                            Letzte 7 Tage
                        </button>
                        <button class="modal-tab" :class="{ active: houseModal.activeTab === 'month' }" @click="houseModal.activeTab = 'month'">
                            Letzter Monat
                        </button>
                        <button class="modal-tab" :class="{ active: houseModal.activeTab === 'year' }" @click="houseModal.activeTab = 'year'">
                            Dieses Jahr
                        </button>
                    </div>

                    <!-- Charts -->
                    <div class="modal-chart-grid">
                        <!-- Consumption Chart -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>üìä</span>
                                <span>Verbrauch Timeline</span>
                            </div>
                            <div id="house-consumption-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Autarky Chart -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>üéØ</span>
                                <span>Autarkie & Eigenverbrauch</span>
                            </div>
                            <div id="house-autarky-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Energy Sources -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>‚ö°</span>
                                <span>Energiequellen</span>
                            </div>
                            <div id="house-sources-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Peak Times -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>üî•</span>
                                <span>Verbrauch Peak-Zeiten</span>
                            </div>
                            <div id="house-peak-chart" style="height: 350px;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ===== GRID MODAL ===== -->
        <div v-if="gridModal.isOpen" class="modal-overlay" @click.self="closeGridModal">
            <div class="modal-container grid-modal">
                <div class="modal-header">
                    <h2 class="modal-title">
                        <span>‚ö°</span>
                        <span>Netz Analytics</span>
                    </h2>
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <button class="modal-export-btn" @click="exportGridAnalytics" :disabled="gridModal.exporting">
                            <span v-if="!gridModal.exporting">üìä PNG Export</span>
                            <span v-else>‚è≥ Exportiere...</span>
                        </button>
                        <button class="modal-close" @click="closeGridModal">√ó</button>
                    </div>
                </div>
                <div class="modal-body">
                    <!-- Quick Stats -->
                    <div class="modal-stats-grid">
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ gridModal.stats.weekImport?.toFixed(2) || '‚Äî' }} kWh</div>
                            <div class="modal-stat-label">Bezug (Mo-So)</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ gridModal.stats.weekExport?.toFixed(2) || '‚Äî' }} kWh</div>
                            <div class="modal-stat-label">Einspeisung (Mo-So)</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ gridModal.stats.netBalance?.toFixed(2) || '‚Äî' }} kWh</div>
                            <div class="modal-stat-label">Netto Balance</div>
                        </div>
                        <div class="modal-stat-card" v-if="energyBalance.priceMode !== 'none'">
                            <div class="modal-stat-value">{{ gridModal.stats.avgPrice?.toFixed(2) || '‚Äî' }} ct/kWh</div>
                            <div class="modal-stat-label">√ò Strompreis</div>
                        </div>
                        <div class="modal-stat-card" v-if="energyBalance.priceMode !== 'none'">
                            <div class="modal-stat-value">{{ gridModal.stats.costs?.toFixed(2) || '‚Äî' }} ‚Ç¨</div>
                            <div class="modal-stat-label">Kosten (Mo-So)</div>
                        </div>
                        <div class="modal-stat-card" v-if="energyBalance.priceMode !== 'none'">
                            <div class="modal-stat-value">{{ gridModal.stats.revenue?.toFixed(2) || '‚Äî' }} ‚Ç¨</div>
                            <div class="modal-stat-label">Erl√∂se (Mo-So)</div>
                        </div>
                    </div>

                    <!-- Tabs -->
                    <div class="modal-tabs">
                        <button class="modal-tab" :class="{ active: gridModal.activeTab === 'week' }" @click="gridModal.activeTab = 'week'">
                            Letzte 7 Tage
                        </button>
                        <button class="modal-tab" :class="{ active: gridModal.activeTab === 'month' }" @click="gridModal.activeTab = 'month'">
                            Letzter Monat
                        </button>
                        <button class="modal-tab" :class="{ active: gridModal.activeTab === 'year' }" @click="gridModal.activeTab = 'year'">
                            Dieses Jahr
                        </button>
                    </div>

                    <!-- Charts -->
                    <div class="modal-chart-grid">
                        <!-- Import/Export Chart -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>üìä</span>
                                <span>Bezug / Einspeisung</span>
                            </div>
                            <div id="grid-flow-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Price Timeline -->
                        <div class="modal-chart-container" v-if="energyBalance.priceMode === 'dynamic'">
                            <div class="modal-chart-title">
                                <span>üí∞</span>
                                <span>Strompreis Verlauf</span>
                            </div>
                            <div id="grid-price-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Cost/Revenue Analysis -->
                        <div class="modal-chart-container" v-if="energyBalance.priceMode !== 'none'">
                            <div class="modal-chart-title">
                                <span>üí∂</span>
                                <span>Kosten / Erl√∂se</span>
                            </div>
                            <div id="grid-money-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Usage Patterns -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>üî•</span>
                                <span>Nutzungsmuster</span>
                            </div>
                            <div id="grid-pattern-chart" style="height: 350px;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ===== CONSUMER ANALYTICS MODAL (W√§rmepumpe, Heizstab, Wallbox) ===== -->
        <div v-if="consumerModal.isOpen" class="modal-overlay" @click.self="closeConsumerModal">
            <div class="modal-container consumer-modal">
                <div class="modal-header">
                    <h2 class="modal-title">
                        <span>üîå</span>
                        <span>Verbraucher Analytics</span>
                    </h2>
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <button class="modal-close" @click="closeConsumerModal">√ó</button>
                    </div>
                </div>
                <div class="modal-body">
                    <!-- Consumer Cards Grid -->
                    <div class="modal-stats-grid" style="grid-template-columns: repeat(3, 1fr);">
                        <!-- W√§rmepumpe -->
                        <div class="modal-stat-card" v-if="energyFlow.consumers?.heatpump?.configured" style="border-left: 3px solid #ff6b6b;">
                            <div class="modal-stat-value" style="color: #ff6b6b; font-size: 1.1em;">üå°Ô∏è W√§rmepumpe</div>
                            <div style="margin-top: 8px; display: flex; flex-direction: column; gap: 4px;">
                                <div style="display: flex; justify-content: space-between;">
                                    <span class="modal-stat-label">Leistung:</span>
                                    <span style="color: #f0f6fc;">{{ consumerModal.stats.heatpump.power?.toFixed(0) || 0 }} W</span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span class="modal-stat-label">Heute:</span>
                                    <span style="color: #f0f6fc;">{{ consumerModal.stats.heatpump.daily_kwh?.toFixed(2) || 0 }} kWh</span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span class="modal-stat-label">COP:</span>
                                    <span style="color: #22c55e;">{{ consumerModal.stats.heatpump.cop?.toFixed(1) || 3.5 }}</span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span class="modal-stat-label">W√§rme:</span>
                                    <span style="color: #fbbf24;">{{ (consumerModal.stats.heatpump.daily_kwh * consumerModal.stats.heatpump.cop)?.toFixed(2) || 0 }} kWh</span>
                                </div>
                                <div v-if="energyBalance.priceMode !== 'none'" style="display: flex; justify-content: space-between; margin-top: 4px; padding-top: 4px; border-top: 1px solid #30363d;">
                                    <span class="modal-stat-label">Kosten:</span>
                                    <span style="color: #f87171;">{{ consumerModal.stats.heatpump.cost_today?.toFixed(2) || 0 }} ‚Ç¨</span>
                                </div>
                            </div>
                        </div>
                        <div class="modal-stat-card" v-else style="opacity: 0.5; border-left: 3px solid #4a5568;">
                            <div class="modal-stat-value" style="color: #94a3b8;">üå°Ô∏è W√§rmepumpe</div>
                            <div class="modal-stat-label" style="margin-top: 8px;">Nicht konfiguriert</div>
                        </div>

                        <!-- Heizstab -->
                        <div class="modal-stat-card" v-if="energyFlow.consumers?.heatingrod?.configured" style="border-left: 3px solid #fbbf24;">
                            <div class="modal-stat-value" style="color: #fbbf24; font-size: 1.1em;">üî• Heizstab</div>
                            <div style="margin-top: 8px; display: flex; flex-direction: column; gap: 4px;">
                                <div style="display: flex; justify-content: space-between;">
                                    <span class="modal-stat-label">Leistung:</span>
                                    <span style="color: #f0f6fc;">{{ consumerModal.stats.heatingrod.power?.toFixed(0) || 0 }} W</span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span class="modal-stat-label">Heute:</span>
                                    <span style="color: #f0f6fc;">{{ consumerModal.stats.heatingrod.daily_kwh?.toFixed(2) || 0 }} kWh</span>
                                </div>
                                <div v-if="energyBalance.priceMode !== 'none'" style="display: flex; justify-content: space-between; margin-top: 4px; padding-top: 4px; border-top: 1px solid #30363d;">
                                    <span class="modal-stat-label">Kosten:</span>
                                    <span style="color: #f87171;">{{ consumerModal.stats.heatingrod.cost_today?.toFixed(2) || 0 }} ‚Ç¨</span>
                                </div>
                            </div>
                        </div>
                        <div class="modal-stat-card" v-else style="opacity: 0.5; border-left: 3px solid #4a5568;">
                            <div class="modal-stat-value" style="color: #94a3b8;">üî• Heizstab</div>
                            <div class="modal-stat-label" style="margin-top: 8px;">Nicht konfiguriert</div>
                        </div>

                        <!-- Wallbox -->
                        <div class="modal-stat-card" v-if="energyFlow.consumers?.wallbox?.configured" style="border-left: 3px solid #22c55e;">
                            <div class="modal-stat-value" style="color: #22c55e; font-size: 1.1em;">üöó Wallbox</div>
                            <div style="margin-top: 8px; display: flex; flex-direction: column; gap: 4px;">
                                <div style="display: flex; justify-content: space-between;">
                                    <span class="modal-stat-label">Leistung:</span>
                                    <span style="color: #f0f6fc;">{{ consumerModal.stats.wallbox.power?.toFixed(0) || 0 }} W</span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span class="modal-stat-label">Heute:</span>
                                    <span style="color: #f0f6fc;">{{ consumerModal.stats.wallbox.daily_kwh?.toFixed(2) || 0 }} kWh</span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span class="modal-stat-label">Status:</span>
                                    <span :style="{ color: consumerModal.stats.wallbox.state === 'charging' ? '#22c55e' : '#94a3b8' }">
                                        {{ consumerModal.stats.wallbox.state === 'charging' ? '‚ö° L√§dt' : 'üí§ Bereit' }}
                                    </span>
                                </div>
                                <div v-if="energyBalance.priceMode !== 'none'" style="display: flex; justify-content: space-between; margin-top: 4px; padding-top: 4px; border-top: 1px solid #30363d;">
                                    <span class="modal-stat-label">Kosten:</span>
                                    <span style="color: #f87171;">{{ consumerModal.stats.wallbox.cost_today?.toFixed(2) || 0 }} ‚Ç¨</span>
                                </div>
                            </div>
                        </div>
                        <div class="modal-stat-card" v-else style="opacity: 0.5; border-left: 3px solid #4a5568;">
                            <div class="modal-stat-value" style="color: #94a3b8;">üöó Wallbox</div>
                            <div class="modal-stat-label" style="margin-top: 8px;">Nicht konfiguriert</div>
                        </div>
                    </div>

                    <!-- Totals Row -->
                    <div class="modal-stats-grid" style="grid-template-columns: repeat(2, 1fr); margin-top: 16px;">
                        <div class="modal-stat-card" style="background: linear-gradient(135deg, rgba(34, 197, 94, 0.15), rgba(34, 197, 94, 0.05));">
                            <div class="modal-stat-value" style="color: #22c55e;">{{ consumerModal.stats.total_daily_kwh?.toFixed(2) || 0 }} kWh</div>
                            <div class="modal-stat-label">Verbraucher gesamt heute</div>
                        </div>
                        <div class="modal-stat-card" v-if="energyBalance.priceMode !== 'none'" style="background: linear-gradient(135deg, rgba(248, 113, 113, 0.15), rgba(248, 113, 113, 0.05));">
                            <div class="modal-stat-value" style="color: #f87171;">{{ consumerModal.stats.total_cost_today?.toFixed(2) || 0 }} ‚Ç¨</div>
                            <div class="modal-stat-label">Gesamtkosten heute</div>
                        </div>
                    </div>

                    <!-- Bar Chart -->
                    <div class="modal-chart-container" style="margin-top: 20px;">
                        <div class="modal-chart-title">
                            <span>üìä</span>
                            <span>Verbrauch heute (kWh)</span>
                        </div>
                        <div id="consumerBarChart" style="height: 280px;"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ===== POWER SOURCES MODAL ===== -->
        <div v-if="powerSourcesModal.isOpen" class="modal-overlay" @click.self="closePowerSourcesModal">
            <div class="modal-container power-sources-modal">
                <div class="modal-header">
                    <h2 class="modal-title">
                        <span>‚ö°</span>
                        <span>Energiequellen Analytics</span>
                    </h2>
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <button class="modal-export-btn" @click="exportPowerSourcesAnalytics" :disabled="powerSourcesModal.exporting">
                            <span v-if="!powerSourcesModal.exporting">üìä PNG Export</span>
                            <span v-else>‚è≥ Exportiere...</span>
                        </button>
                        <button class="modal-close" @click="closePowerSourcesModal">√ó</button>
                    </div>
                </div>
                <div class="modal-body">
                    <!-- Quick Stats - 7 Cards -->
                    <div class="modal-stats-grid" style="grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));">
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #FFD700;">{{ powerSourcesModal.stats.solarTotal?.toFixed(2) || '‚Äî' }} kWh</div>
                            <div class="modal-stat-label">Solar gesamt</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #facc15;">{{ powerSourcesModal.stats.solarToHouse?.toFixed(2) || '‚Äî' }} kWh</div>
                            <div class="modal-stat-label">Solar ‚Üí Haus</div>
                        </div>
                        <div v-if="hasBattery" class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #9ACD32;">{{ powerSourcesModal.stats.solarToBattery?.toFixed(2) || '‚Äî' }} kWh</div>
                            <div class="modal-stat-label">Solar ‚Üí Batterie</div>
                        </div>
                        <div v-if="hasBattery" class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #4DD0E1;">{{ powerSourcesModal.stats.batteryTotal?.toFixed(2) || '‚Äî' }} kWh</div>
                            <div class="modal-stat-label">Batterie ‚Üí Haus</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #90CAF9;">{{ powerSourcesModal.stats.gridTotal?.toFixed(2) || '‚Äî' }} kWh</div>
                            <div class="modal-stat-label">Netz ‚Üí Haus</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #FF8C00;">{{ powerSourcesModal.stats.consumptionTotal?.toFixed(2) || '‚Äî' }} kWh</div>
                            <div class="modal-stat-label">Verbrauch gesamt</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: var(--neon-green);">{{ powerSourcesModal.stats.autarky?.toFixed(1) || '‚Äî' }}%</div>
                            <div class="modal-stat-label">Autarkie</div>
                        </div>
                    </div>

                    <!-- Tabs and Date Picker -->
                    <div class="modal-tabs" style="flex-wrap: wrap; gap: 8px;">
                        <button class="modal-tab" :class="{ active: powerSourcesModal.activeTab === 'today' }" @click="changePowerSourcesTab('today')">
                            Heute
                        </button>
                        <button class="modal-tab" :class="{ active: powerSourcesModal.activeTab === 'yesterday' }" @click="changePowerSourcesTab('yesterday')">
                            Gestern
                        </button>
                        <button class="modal-tab" :class="{ active: powerSourcesModal.activeTab === 'week' }" @click="changePowerSourcesTab('week')">
                            Letzte 7 Tage
                        </button>
                        <button class="modal-tab" :class="{ active: powerSourcesModal.activeTab === 'custom' }" @click="changePowerSourcesTab('custom')" style="border-color: #8b5cf6;">
                            üìÖ Benutzerdefiniert
                        </button>
                    </div>

                    <!-- Custom Date Range Picker -->
                    <div v-if="powerSourcesModal.activeTab === 'custom'" class="date-range-picker" style="display: flex; gap: 16px; align-items: center; margin-bottom: 16px; padding: 12px; background: rgba(139, 92, 246, 0.1); border-radius: 8px; border: 1px solid rgba(139, 92, 246, 0.3);">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <label style="color: #94a3b8; font-size: 0.85rem;">Von:</label>
                            <input type="date" v-model="powerSourcesModal.customStartDate"
                                   style="background: #1e1e3e; border: 1px solid #404040; color: #fff; padding: 6px 10px; border-radius: 6px; font-size: 0.9rem;">
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <label style="color: #94a3b8; font-size: 0.85rem;">Bis:</label>
                            <input type="date" v-model="powerSourcesModal.customEndDate"
                                   style="background: #1e1e3e; border: 1px solid #404040; color: #fff; padding: 6px 10px; border-radius: 6px; font-size: 0.9rem;">
                        </div>
                        <button @click="loadPowerSourcesCustomRange"
                                style="background: linear-gradient(135deg, #8b5cf6, #6366f1); color: #fff; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: 500;">
                            Laden
                        </button>
                    </div>

                    <!-- Main Chart -->
                    <div class="modal-chart-grid">
                        <!-- Stacked Area Chart -->
                        <div class="modal-chart-container" style="grid-column: 1 / -1;">
                            <div class="modal-chart-title">
                                <span>üìä</span>
                                <span>Energiequellen im Zeitverlauf</span>
                            </div>
                            <div id="power-sources-main-chart" style="height: 450px;"></div>
                        </div>

                        <!-- Battery SOC -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>üîã</span>
                                <span>Batterie-Ladestand</span>
                            </div>
                            <div id="power-sources-soc-chart" style="height: 250px;"></div>
                        </div>

                        <!-- Energy Distribution Pie -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>ü•ß</span>
                                <span>Energieverteilung</span>
                            </div>
                            <div id="power-sources-pie-chart" style="height: 250px;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ===== PANEL GROUP MODAL ===== -->
        <div v-if="panelGroupModal.isOpen" class="modal-overlay" @click.self="closePanelGroupModal">
            <div class="modal-container" style="max-width: 800px;">
                <div class="modal-header">
                    <h2 class="modal-title">
                        <span>‚òÄÔ∏è</span>
                        <span>{{ panelGroupModal.groupName }} - Details</span>
                    </h2>
                    <button class="modal-close" @click="closePanelGroupModal">√ó</button>
                </div>
                <div class="modal-body">
                    <!-- Quick Stats -->
                    <div class="modal-stats-grid" style="grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); margin-bottom: 20px;">
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #00ff88;">{{ panelGroupModal.groupData?.actual_total_kwh?.toFixed(3) || '0.000' }} kWh</div>
                            <div class="modal-stat-label">IST Gesamt</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #8b5cf6;">{{ panelGroupModal.groupData?.prediction_total_kwh?.toFixed(3) || '0.000' }} kWh</div>
                            <div class="modal-stat-label">Prognose Gesamt</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" :style="{color: (panelGroupModal.groupData?.accuracy_percent || 0) >= 80 ? '#00ff88' : (panelGroupModal.groupData?.accuracy_percent || 0) >= 50 ? '#ffdd00' : '#ef4444'}">
                                {{ panelGroupModal.groupData?.accuracy_percent?.toFixed(1) || '‚Äî' }}%
                            </div>
                            <div class="modal-stat-label">Genauigkeit</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" :style="{color: getPanelGroupDeviation() >= 0 ? '#00ff88' : '#ef4444'}">
                                {{ getPanelGroupDeviation() >= 0 ? '+' : '' }}{{ getPanelGroupDeviation()?.toFixed(1) || '0.0' }}%
                            </div>
                            <div class="modal-stat-label">Abweichung</div>
                        </div>
                    </div>

                    <!-- Hourly Data Table -->
                    <div class="modal-chart-container">
                        <div class="modal-chart-title">
                            <span>üìä</span>
                            <span>St√ºndliche √úbersicht</span>
                        </div>
                        <div style="max-height: 400px; overflow-y: auto;">
                            <table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
                                <thead style="position: sticky; top: 0; background: #1e1e3e;">
                                    <tr style="border-bottom: 2px solid #404040;">
                                        <th style="padding: 10px; text-align: left; color: #94a3b8;">Stunde</th>
                                        <th style="padding: 10px; text-align: right; color: #00ff88;">IST (kWh)</th>
                                        <th style="padding: 10px; text-align: right; color: #8b5cf6;">Prognose (kWh)</th>
                                        <th style="padding: 10px; text-align: right; color: #94a3b8;">Abweichung</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="hour in getPanelGroupHourlyData()" :key="hour.hour"
                                        style="border-bottom: 1px solid #2a2a4a;"
                                        :style="{ background: hour.hour === new Date().getHours() ? 'rgba(255, 221, 0, 0.1)' : 'transparent' }">
                                        <td style="padding: 8px 10px; color: #e2e8f0;">
                                            {{ hour.hour }}:00
                                            <span v-if="hour.hour === new Date().getHours()" style="color: #ffdd00; font-size: 0.8rem;"> (aktuell)</span>
                                        </td>
                                        <td style="padding: 8px 10px; text-align: right; color: #00ff88; font-family: monospace;">
                                            {{ hour.actual?.toFixed(4) || '0.0000' }}
                                        </td>
                                        <td style="padding: 8px 10px; text-align: right; color: #8b5cf6; font-family: monospace;">
                                            {{ hour.prediction?.toFixed(4) || '0.0000' }}
                                        </td>
                                        <td style="padding: 8px 10px; text-align: right; font-family: monospace;"
                                            :style="{ color: hour.deviation >= 0 ? '#00ff88' : '#ef4444' }">
                                            {{ hour.deviation >= 0 ? '+' : '' }}{{ hour.deviation?.toFixed(1) || '0.0' }}%
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ===== PRODUCTION TODAY MODAL ===== -->
        <div v-if="productionTodayModal.isOpen" class="modal-overlay" @click.self="closeProductionTodayModal">
            <div class="modal-container" style="max-width: 900px;">
                <div class="modal-header">
                    <h2 class="modal-title">
                        <span>üìÖ</span>
                        <span>Produktion Heute - Details</span>
                    </h2>
                    <button class="modal-close" @click="closeProductionTodayModal">√ó</button>
                </div>
                <div class="modal-body">
                    <!-- Quick Stats -->
                    <div class="modal-stats-grid" style="grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); margin-bottom: 20px;">
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #00ff88;">{{ energyFlow.statistics.solar_yield_daily?.toFixed(2) || '0.00' }} kWh</div>
                            <div class="modal-stat-label">Ertrag Heute</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #8b5cf6;">{{ forecast.todayTotal?.toFixed(2) || '0.00' }} kWh</div>
                            <div class="modal-stat-label">Prognose Heute</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" :style="{color: (todayAccuracy || 0) >= 80 ? '#00ff88' : (todayAccuracy || 0) >= 50 ? '#ffdd00' : '#ef4444'}">
                                {{ todayAccuracy?.toFixed(1) || '‚Äî' }}%
                            </div>
                            <div class="modal-stat-label">Genauigkeit</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" :style="{color: getProductionTodayDeviation() >= 0 ? '#00ff88' : '#ef4444'}">
                                {{ getProductionTodayDeviation() >= 0 ? '+' : '' }}{{ getProductionTodayDeviation()?.toFixed(1) || '0.0' }}%
                            </div>
                            <div class="modal-stat-label">Abweichung</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #ffdd00;">{{ forecast.todayRemaining?.toFixed(2) || '0.00' }} kWh</div>
                            <div class="modal-stat-label">Verbleibend</div>
                        </div>
                    </div>

                    <!-- Hourly Data Table -->
                    <div class="modal-chart-container">
                        <div class="modal-chart-title">
                            <span>üìä</span>
                            <span>St√ºndliche √úbersicht</span>
                        </div>
                        <div style="max-height: 450px; overflow-y: auto;">
                            <table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
                                <thead style="position: sticky; top: 0; background: #1e1e3e;">
                                    <tr style="border-bottom: 2px solid #404040;">
                                        <th style="padding: 10px; text-align: left; color: #94a3b8;">Stunde</th>
                                        <th style="padding: 10px; text-align: right; color: #00ff88;">IST (kWh)</th>
                                        <th style="padding: 10px; text-align: right; color: #8b5cf6;">Prognose (kWh)</th>
                                        <th style="padding: 10px; text-align: right; color: #94a3b8;">Abweichung</th>
                                        <th style="padding: 10px; text-align: right; color: #94a3b8;">Genauigkeit</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="hour in getProductionTodayHourlyData()" :key="hour.hour"
                                        style="border-bottom: 1px solid #2a2a4a;"
                                        :style="{ background: hour.hour === new Date().getHours() ? 'rgba(255, 221, 0, 0.1)' : 'transparent' }">
                                        <td style="padding: 8px 10px; color: #e2e8f0;">
                                            {{ hour.hour }}:00
                                            <span v-if="hour.hour === new Date().getHours()" style="color: #ffdd00; font-size: 0.8rem;"> (aktuell)</span>
                                        </td>
                                        <td style="padding: 8px 10px; text-align: right; color: #00ff88; font-family: monospace;">
                                            {{ hour.actual?.toFixed(3) || '0.000' }}
                                        </td>
                                        <td style="padding: 8px 10px; text-align: right; color: #8b5cf6; font-family: monospace;">
                                            {{ hour.prediction?.toFixed(3) || '0.000' }}
                                        </td>
                                        <td style="padding: 8px 10px; text-align: right; font-family: monospace;"
                                            :style="{ color: hour.deviation >= 0 ? '#00ff88' : '#ef4444' }">
                                            {{ hour.deviation >= 0 ? '+' : '' }}{{ hour.deviation?.toFixed(1) || '0.0' }}%
                                        </td>
                                        <td style="padding: 8px 10px; text-align: right; font-family: monospace;"
                                            :style="{ color: hour.accuracy >= 80 ? '#00ff88' : hour.accuracy >= 50 ? '#ffdd00' : '#ef4444' }">
                                            {{ hour.accuracy?.toFixed(0) || '‚Äî' }}%
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ===== WEATHER MODAL ===== -->
        <div v-if="weatherModal.isOpen" class="modal-overlay" @click.self="closeWeatherModal">
            <div class="modal-container weather-modal">
                <div class="modal-header">
                    <h2 class="modal-title">
                        <span>üå§Ô∏è</span>
                        <span>Wetter Analytics</span>
                    </h2>
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <button class="modal-export-btn" @click="exportWeatherAnalytics" :disabled="weatherModal.exporting">
                            <span v-if="!weatherModal.exporting">üìä PNG Export</span>
                            <span v-else>‚è≥ Exportiere...</span>
                        </button>
                        <button class="modal-close" @click="closeWeatherModal">√ó</button>
                    </div>
                </div>
                <div class="modal-body">
                    <!-- Quick Stats -->
                    <div class="modal-stats-grid">
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ weatherModal.stats.avgTemp?.toFixed(1) || '‚Äî' }}¬∞C</div>
                            <div class="modal-stat-label">√ò Temperatur (Woche)</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ weatherModal.stats.maxTemp?.toFixed(1) || '‚Äî' }}¬∞C</div>
                            <div class="modal-stat-label">H√∂chsttemperatur</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ weatherModal.stats.minTemp?.toFixed(1) || '‚Äî' }}¬∞C</div>
                            <div class="modal-stat-label">Tiefsttemperatur</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ weatherModal.stats.totalRain?.toFixed(1) || '‚Äî' }} mm</div>
                            <div class="modal-stat-label">Niederschlag (Monat)</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ weatherModal.stats.avgWind?.toFixed(1) || '‚Äî' }} m/s</div>
                            <div class="modal-stat-label">√ò Wind</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ weatherModal.stats.sunHours?.toFixed(0) || '‚Äî' }} h</div>
                            <div class="modal-stat-label">Sonnenstunden (Monat)</div>
                        </div>
                    </div>

                    <!-- Tabs -->
                    <div class="modal-tabs">
                        <button class="modal-tab" :class="{ active: weatherModal.activeTab === 'week' }" @click="weatherModal.activeTab = 'week'">
                            Letzte 7 Tage
                        </button>
                        <button class="modal-tab" :class="{ active: weatherModal.activeTab === 'month' }" @click="weatherModal.activeTab = 'month'">
                            Letzter Monat
                        </button>
                        <button class="modal-tab" :class="{ active: weatherModal.activeTab === 'year' }" @click="weatherModal.activeTab = 'year'">
                            Dieses Jahr
                        </button>
                        <button class="modal-tab" :class="{ active: weatherModal.activeTab === 'comparison' }" @click="weatherModal.activeTab = 'comparison'" style="border-color: #8b5cf6;">
                            ü§ñ IST vs KI
                        </button>
                    </div>

                    <!-- Historical Charts (Week/Month/Year) -->
                    <div v-if="weatherModal.activeTab !== 'comparison'" class="modal-chart-grid">
                        <!-- Temperature Chart -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>üå°Ô∏è</span>
                                <span>Temperatur Verlauf</span>
                            </div>
                            <div id="weather-temp-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Radiation & Solar Correlation -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>‚òÄÔ∏è</span>
                                <span>Einstrahlung & Solar-Produktion</span>
                            </div>
                            <div id="weather-radiation-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Rain & Humidity -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>üíß</span>
                                <span>Niederschlag & Luftfeuchtigkeit</span>
                            </div>
                            <div id="weather-rain-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Wind Chart -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>üå¨Ô∏è</span>
                                <span>Wind Geschwindigkeit</span>
                            </div>
                            <div id="weather-wind-chart" style="height: 350px;"></div>
                        </div>
                    </div>

                    <!-- IST vs KI Comparison Charts -->
                    <div v-if="weatherModal.activeTab === 'comparison'" class="modal-chart-grid">
                        <!-- Temperature IST vs KI -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>üå°Ô∏è</span>
                                <span>Temperatur: IST vs KI</span>
                            </div>
                            <div id="weather-temp-comparison-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Radiation IST vs KI -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>‚òÄÔ∏è</span>
                                <span>Einstrahlung (W/m¬≤): IST vs KI</span>
                            </div>
                            <div id="weather-radiation-comparison-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Clouds IST vs KI -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>‚òÅÔ∏è</span>
                                <span>Wolken (%): IST vs KI</span>
                            </div>
                            <div id="weather-clouds-comparison-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Accuracy Analysis -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>üéØ</span>
                                <span>KI-Genauigkeit</span>
                            </div>
                            <div id="weather-accuracy-chart" style="height: 350px;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ===== FORECAST COMPARISON MODAL ===== -->
        <div v-if="forecastComparisonModal.isOpen" class="modal-overlay" @click.self="closeForecastComparisonModal">
            <div class="modal-container forecast-comparison-modal">
                <div class="modal-header">
                    <h2 class="modal-title" style="background: linear-gradient(135deg, #a855f7, #00d4ff); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
                        <span style="-webkit-text-fill-color: initial;">üìä</span>
                        <span>7-Tage Prognose-Vergleich</span>
                    </h2>
                    <button class="modal-close" @click="closeForecastComparisonModal">√ó</button>
                </div>
                <div class="modal-body">
                    <!-- Quick Stats -->
                    <div class="modal-stats-grid">
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #10b981;">{{ forecastComparisonModal.stats.daysWithActual || '‚Äî' }}</div>
                            <div class="modal-stat-label">Tage mit Daten</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #a855f7;">{{ forecastComparisonModal.stats.sfmlAccuracy?.toFixed(1) || '‚Äî' }}%</div>
                            <div class="modal-stat-label">SFML Genauigkeit</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #00d4ff;">{{ forecastComparisonModal.stats.ext1Accuracy?.toFixed(1) || '‚Äî' }}%</div>
                            <div class="modal-stat-label">{{ forecastComparisonModal.stats.ext1Name || 'Extern 1' }}</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #ff9500;">{{ forecastComparisonModal.stats.ext2Accuracy?.toFixed(1) || '‚Äî' }}%</div>
                            <div class="modal-stat-label">{{ forecastComparisonModal.stats.ext2Name || 'Extern 2' }}</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #22c55e;">{{ forecastComparisonModal.stats.bestForecast || '‚Äî' }}</div>
                            <div class="modal-stat-label">Beste Prognose</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ forecastComparisonModal.stats.totalActual?.toFixed(2) || '‚Äî' }} kWh</div>
                            <div class="modal-stat-label">Gesamt Ertrag</div>
                        </div>
                    </div>

                    <!-- Main Comparison Chart -->
                    <div class="modal-chart-grid" style="grid-template-columns: 1fr;">
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>üìà</span>
                                <span>Tats√§chlich vs. Prognosen (7 Tage)</span>
                            </div>
                            <div id="forecast-comparison-chart" style="height: 400px;"></div>
                        </div>
                    </div>

                    <!-- Legend -->
                    <div style="display: flex; gap: 24px; justify-content: center; padding: 16px; flex-wrap: wrap;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div style="width: 24px; height: 3px; background: #10b981; border-radius: 2px;"></div>
                            <span style="color: var(--text-muted); font-size: 0.85rem;">Tats√§chlich</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div style="width: 24px; height: 3px; background: #a855f7; border-radius: 2px; border-style: dashed; border-width: 0 0 3px 0;"></div>
                            <span style="color: var(--text-muted); font-size: 0.85rem;">SFML Prognose</span>
                        </div>
                        <div v-if="forecastComparisonModal.stats.ext1Name" style="display: flex; align-items: center; gap: 8px;">
                            <div style="width: 24px; height: 3px; background: #00d4ff; border-radius: 2px;"></div>
                            <span style="color: var(--text-muted); font-size: 0.85rem;">{{ forecastComparisonModal.stats.ext1Name }}</span>
                        </div>
                        <div v-if="forecastComparisonModal.stats.ext2Name" style="display: flex; align-items: center; gap: 8px;">
                            <div style="width: 24px; height: 3px; background: #ff9500; border-radius: 2px;"></div>
                            <span style="color: var(--text-muted); font-size: 0.85rem;">{{ forecastComparisonModal.stats.ext2Name }}</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ===== SHADOW ANALYTICS MODAL ===== -->
        <div v-if="shadowModal.isOpen" class="modal-overlay" @click.self="closeShadowAnalyticsModal">
            <div class="modal-container shadow-analytics-modal">
                <div class="modal-header">
                    <h2 class="modal-title" style="background: linear-gradient(135deg, #8b8ba0, #c0c0d0); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
                        <span style="-webkit-text-fill-color: initial;">üåë</span>
                        <span>Schatten-Analyse</span>
                    </h2>
                    <button class="modal-close" @click="closeShadowAnalyticsModal">&times;</button>
                </div>
                <div class="modal-body">
                    <!-- Quick Stats -->
                    <div class="modal-stats-grid">
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #ef4444;">{{ shadowModal.stats.totalLoss?.toFixed(1) || '‚Äî' }}</div>
                            <div class="modal-stat-label">Verlust kWh</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #f59e0b;">{{ shadowModal.stats.shadowHours || '‚Äî' }}</div>
                            <div class="modal-stat-label">Schatten-Stunden</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #8b8ba0;">{{ shadowModal.stats.avgEfficiency != null ? (shadowModal.stats.avgEfficiency * 100).toFixed(0) + '%' : '‚Äî' }}</div>
                            <div class="modal-stat-label">&Oslash; Effizienz</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #a78bfa;">{{ shadowModal.stats.dominantCauseLabel || '‚Äî' }}</div>
                            <div class="modal-stat-label">Hauptursache</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #64748b;">{{ shadowModal.stats.daysWithShadow || '‚Äî' }} / {{ shadowModal.stats.daysAnalyzed || '‚Äî' }}</div>
                            <div class="modal-stat-label">Tage mit Schatten</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value" style="color: #06b6d4;">{{ shadowModal.stats.daysLearned || '‚Äî' }}</div>
                            <div class="modal-stat-label">KI Lerntage</div>
                        </div>
                    </div>

                    <!-- Charts Grid -->
                    <div class="modal-chart-grid">
                        <!-- Heatmap -->
                        <div class="modal-chart-container" style="grid-column: 1 / -1;">
                            <div class="modal-chart-title">
                                <span>üó∫Ô∏è</span>
                                <span>Schatten-Intensit&auml;t (Stunde &times; Tag)</span>
                            </div>
                            <div id="shadow-heatmap-chart" style="height: 350px;"></div>
                        </div>

                        <!-- Causes Donut -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>üîç</span>
                                <span>Schatten-Ursachen</span>
                            </div>
                            <div id="shadow-causes-chart" style="height: 280px;"></div>
                        </div>

                        <!-- Daily Loss -->
                        <div class="modal-chart-container">
                            <div class="modal-chart-title">
                                <span>üìâ</span>
                                <span>T&auml;glicher Verlust</span>
                            </div>
                            <div id="shadow-daily-loss-chart" style="height: 280px;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ===== CLOTHING RECOMMENDATION MODAL ===== -->
        <div v-if="clothingModal.isOpen" class="modal-overlay" @click.self="closeClothingModal">
            <div class="modal-container clothing-modal">
                <div class="modal-header">
                    <h2 class="modal-title">
                        <span>üëî</span>
                        <span>{{ clothingModal.title }}</span>
                    </h2>
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <button class="modal-close" @click="closeClothingModal">√ó</button>
                    </div>
                </div>
                <div class="modal-body">
                    <!-- Weather Summary -->
                    <div class="modal-stats-grid">
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ clothingModal.weather.temperature?.toFixed(1) || '‚Äî' }}¬∞C</div>
                            <div class="modal-stat-label">{{ clothingModal.labels.temperature }}</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ clothingModal.weather.feels_like?.toFixed(1) || '‚Äî' }}¬∞C</div>
                            <div class="modal-stat-label">{{ clothingModal.labels.feels_like }}</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ clothingModal.weather.humidity?.toFixed(0) || '‚Äî' }}%</div>
                            <div class="modal-stat-label">{{ clothingModal.labels.humidity }}</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ clothingModal.weather.wind_speed?.toFixed(1) || '‚Äî' }} km/h</div>
                            <div class="modal-stat-label">{{ clothingModal.labels.wind }}</div>
                        </div>
                        <div class="modal-stat-card">
                            <div class="modal-stat-value">{{ clothingModal.weather.rain_probability || '‚Äî' }}%</div>
                            <div class="modal-stat-label">{{ clothingModal.labels.rain_prob }}</div>
                        </div>
                    </div>

                    <!-- Recommendation Text -->
                    <div class="clothing-text-container">
                        <p class="clothing-recommendation-text">{{ clothingModal.text }}</p>
                    </div>

                    <!-- Clothing Items Grid -->
                    <div class="clothing-items-grid">
                        <div class="clothing-item">
                            <div class="clothing-item-icon">{{ clothingModal.recommendation.unterbekleidung?.icon }}</div>
                            <div class="clothing-item-name">{{ clothingModal.recommendation.unterbekleidung?.name }}</div>
                            <div class="clothing-item-label">{{ clothingModal.labels.pants }}</div>
                        </div>
                        <div class="clothing-item">
                            <div class="clothing-item-icon">{{ clothingModal.recommendation.oberbekleidung?.icon }}</div>
                            <div class="clothing-item-name">{{ clothingModal.recommendation.oberbekleidung?.name }}</div>
                            <div class="clothing-item-label">{{ clothingModal.labels.top }}</div>
                        </div>
                        <div class="clothing-item">
                            <div class="clothing-item-icon">{{ clothingModal.recommendation.jacke?.icon }}</div>
                            <div class="clothing-item-name">{{ clothingModal.recommendation.jacke?.name }}</div>
                            <div class="clothing-item-label">{{ clothingModal.labels.jacket }}</div>
                        </div>
                        <div class="clothing-item">
                            <div class="clothing-item-icon">{{ clothingModal.recommendation.kopfbedeckung?.icon }}</div>
                            <div class="clothing-item-name">{{ clothingModal.recommendation.kopfbedeckung?.name }}</div>
                            <div class="clothing-item-label">{{ clothingModal.labels.headwear }}</div>
                        </div>
                    </div>

                    <!-- Accessories -->
                    <div class="clothing-accessories" v-if="clothingModal.recommendation.zusaetze?.length > 0">
                        <div class="clothing-accessories-title">{{ clothingModal.labels.accessories }}</div>
                        <div class="clothing-accessories-list">
                            <span class="clothing-accessory" v-for="(item, index) in clothingModal.recommendation.zusaetze" :key="index">
                                {{ item.icon }} {{ item.name }}
                            </span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <footer class="footer">
            <div class="footer-tags">
                <span class="footer-tag">ML-Powered</span>
                <span class="footer-tag">Real-Time</span>
                <span class="footer-tag">Local</span>
            </div>
            <span>SFML Stats v2.0</span>
        </footer>
    </div>

    <script>
        const { createApp, ref, reactive, computed, onMounted, onUnmounted, watch, nextTick } = Vue;

        // ============================================================
        // Toast Notification System
        // ============================================================
        const Toast = {
            container: null,

            init() {
                this.container = document.getElementById('toast-container');
            },

            show(message, type = 'info', title = null, duration = 5000) {
                if (!this.container) this.init();

                const icons = {
                    success: '‚úì',
                    error: '‚úï',
                    warning: '‚ö†',
                    info: '‚Ñπ'
                };

                const titles = {
                    success: 'Erfolg',
                    error: 'Fehler',
                    warning: 'Warnung',
                    info: 'Info'
                };

                const toast = document.createElement('div');
                toast.className = `toast toast-${type}`;
                toast.innerHTML = `
                    <span class="toast-icon">${icons[type] || icons.info}</span>
                    <div class="toast-content">
                        <div class="toast-title">${title || titles[type]}</div>
                        <div class="toast-message">${message}</div>
                    </div>
                    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
                `;

                this.container.appendChild(toast);

                // Auto-remove after duration
                if (duration > 0) {
                    setTimeout(() => {
                        toast.classList.add('toast-exit');
                        setTimeout(() => toast.remove(), 300);
                    }, duration);
                }

                return toast;
            },

            success(message, title = null) {
                return this.show(message, 'success', title, 4000);
            },

            error(message, title = null) {
                return this.show(message, 'error', title, 8000);
            },

            warning(message, title = null) {
                return this.show(message, 'warning', title, 6000);
            },

            info(message, title = null) {
                return this.show(message, 'info', title, 5000);
            }
        };

        // ============================================================
        // API Client with Caching
        // ============================================================
        const SFMLApi = {
            cache: new Map(),
            cacheTTL: 30000, // 30 seconds default TTL
            pendingRequests: new Map(), // Prevent duplicate concurrent requests

            async fetch(endpoint, options = {}) {
                const {
                    useCache = true,
                    cacheTTL = this.cacheTTL,
                    showError = true,
                    method = 'GET',
                    body = null
                } = options;

                const url = endpoint.startsWith('/') ? endpoint : `/api/sfml_stats/${endpoint}`;
                const cacheKey = `${method}:${url}`;

                // Check cache for GET requests
                if (method === 'GET' && useCache) {
                    const cached = this.cache.get(cacheKey);
                    if (cached && Date.now() - cached.time < cacheTTL) {
                        return cached.data;
                    }
                }

                // Prevent duplicate concurrent requests
                if (method === 'GET' && this.pendingRequests.has(cacheKey)) {
                    return this.pendingRequests.get(cacheKey);
                }

                const fetchPromise = (async () => {
                    try {
                        const fetchOptions = { method };
                        if (body) {
                            fetchOptions.body = JSON.stringify(body);
                            fetchOptions.headers = { 'Content-Type': 'application/json' };
                        }

                        const response = await fetch(url, fetchOptions);

                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }

                        const contentType = response.headers.get('content-type');
                        let data;

                        if (contentType && contentType.includes('application/json')) {
                            data = await response.json();
                        } else {
                            // Handle blob responses (for file downloads)
                            data = await response.blob();
                        }

                        // Cache successful GET responses
                        if (method === 'GET' && useCache) {
                            this.cache.set(cacheKey, { data, time: Date.now() });
                        }

                        return data;
                    } catch (error) {
                        console.error(`API Error [${url}]:`, error);
                        if (showError) {
                            Toast.error(error.message, 'API-Fehler');
                        }
                        throw error;
                    } finally {
                        this.pendingRequests.delete(cacheKey);
                    }
                })();

                if (method === 'GET') {
                    this.pendingRequests.set(cacheKey, fetchPromise);
                }

                return fetchPromise;
            },

            // Convenience methods
            async get(endpoint, options = {}) {
                return this.fetch(endpoint, { ...options, method: 'GET' });
            },

            async post(endpoint, body, options = {}) {
                return this.fetch(endpoint, { ...options, method: 'POST', body });
            },

            // Clear cache
            clearCache(endpoint = null) {
                if (endpoint) {
                    const url = endpoint.startsWith('/') ? endpoint : `/api/sfml_stats/${endpoint}`;
                    this.cache.delete(`GET:${url}`);
                } else {
                    this.cache.clear();
                }
            },

            // Download helper for exports
            async download(endpoint, filename) {
                try {
                    Toast.info('Export wird vorbereitet...', 'Download');

                    const response = await fetch(
                        endpoint.startsWith('/') ? endpoint : `/api/sfml_stats/${endpoint}`
                    );

                    if (!response.ok) {
                        throw new Error(`Export fehlgeschlagen: ${response.statusText}`);
                    }

                    const blob = await response.blob();
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    Toast.success(`${filename} wurde heruntergeladen`, 'Export erfolgreich');
                    return true;
                } catch (error) {
                    console.error('Download error:', error);
                    Toast.error(error.message, 'Export fehlgeschlagen');
                    throw error;
                }
            }
        };

        // ============================================================
        // Loading State Helper
        // ============================================================
        function createLoadingState() {
            const isLoading = ref(false);
            const error = ref(null);

            async function withLoading(asyncFn) {
                isLoading.value = true;
                error.value = null;
                try {
                    return await asyncFn();
                } catch (e) {
                    error.value = e.message;
                    throw e;
                } finally {
                    isLoading.value = false;
                }
            }

            return { isLoading, error, withLoading };
        }

        createApp({
            setup() {
                const lastUpdate = ref('‚Äî');

                // Theme Toggle
                const isDarkTheme = ref(localStorage.getItem('sfml-theme') !== 'light');

                function toggleTheme() {
                    isDarkTheme.value = !isDarkTheme.value;
                    if (isDarkTheme.value) {
                        document.documentElement.classList.remove('light-theme');
                        localStorage.setItem('sfml-theme', 'dark');
                    } else {
                        document.documentElement.classList.add('light-theme');
                        localStorage.setItem('sfml-theme', 'light');
                    }
                }

                // Initialize theme on load
                if (!isDarkTheme.value) {
                    document.documentElement.classList.add('light-theme');
                }

                // Dashboard Style Toggle (2D/3D)
                const dashboardStyle = ref(localStorage.getItem('sfml-dashboard-style') || '3d');
                const dashboardStyles = ['3d', '2d', 'list'];

                function toggleDashboardStyle() {
                    const currentIndex = dashboardStyles.indexOf(dashboardStyle.value);
                    const nextIndex = (currentIndex + 1) % dashboardStyles.length;
                    dashboardStyle.value = dashboardStyles[nextIndex];
                    localStorage.setItem('sfml-dashboard-style', dashboardStyle.value);
                }

                function getDashboardStyleIcon() {
                    if (dashboardStyle.value === '3d') return 'üé≤';
                    if (dashboardStyle.value === '2d') return '‚¨ú';
                    return 'üìã';
                }

                function getDashboardStyleLabel() {
                    if (dashboardStyle.value === '3d') return '3D';
                    if (dashboardStyle.value === '2d') return '2D';
                    return 'Liste';
                }

                // LCARS Navigation
                function goToLcars() {
                    localStorage.setItem('sfml-dashboard-style', 'lcars');
                    window.location.href = '/api/sfml_stats/lcars';
                }

                // Collapsible Sections
                const collapsedSections = reactive(
                    JSON.parse(localStorage.getItem('sfml-collapsed-sections') || '{}')
                );

                function toggleSection(sectionName) {
                    collapsedSections[sectionName] = !collapsedSections[sectionName];
                    localStorage.setItem('sfml-collapsed-sections', JSON.stringify(collapsedSections));
                    // Resize charts after section is expanded (v-show causes 0-size init)
                    if (!collapsedSections[sectionName]) {
                        nextTick(() => {
                            setTimeout(() => {
                                Object.values(charts).forEach(c => c?.resize());
                                Object.values(panelGroupCharts).forEach(c => c?.resize());
                            }, 50);
                        });
                    }
                }

                function isSectionCollapsed(sectionName) {
                    return !!collapsedSections[sectionName];
                }

                // Section Sorting with SortableJS
                const sortableContainer = ref(null);
                let sortableInstance = null;
                const defaultSectionOrder = [
                    'weather', 'energyMatrix', 'powerSources', 'forecast', 'todayProduction',
                    'panelGroups', 'liveWidgets', 'energyBalance', 'stats', 'kpis', 'mainCharts', 'extendedCharts'
                ];

                function initSortable() {
                    if (!sortableContainer.value || sortableInstance) return;

                    sortableInstance = Sortable.create(sortableContainer.value, {
                        animation: 150,
                        handle: '.section-header, .energy-flow-header, .power-sources-header, .forecast-overview-header, .chart-header, .energy-balance-header, .stats-container-header',
                        draggable: '.sortable-item',
                        ghostClass: 'sortable-ghost',
                        chosenClass: 'sortable-chosen',
                        dragClass: 'sortable-drag',
                        delay: 2000,              // 2 Sekunden gedr√ºckt halten
                        delayOnTouchOnly: true,   // Nur auf Touch-Ger√§ten (Tablet/Handy)
                        touchStartThreshold: 5,   // Kleine Bewegung erlaubt w√§hrend Delay
                        onEnd: saveSectionOrder
                    });

                    // Restore saved order
                    restoreSectionOrder();
                }

                // Storage Helper (localStorage + Cookie Fallback f√ºr HA Companion App)
                function storageSet(key, value) {
                    const data = JSON.stringify(value);
                    try {
                        localStorage.setItem(key, data);
                        // Verify it was saved
                        if (localStorage.getItem(key) === data) {
                            return true;
                        }
                    } catch (e) {
                        console.warn('localStorage failed:', e);
                    }
                    // Fallback: Cookie (365 Tage)
                    try {
                        const expires = new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toUTCString();
                        document.cookie = `${key}=${encodeURIComponent(data)}; expires=${expires}; path=/; SameSite=Lax`;
                        console.log('Saved to cookie:', key);
                        return true;
                    } catch (e) {
                        console.error('Cookie fallback failed:', e);
                        return false;
                    }
                }

                function storageGet(key) {
                    // Try localStorage first
                    try {
                        const data = localStorage.getItem(key);
                        if (data) {
                            return JSON.parse(data);
                        }
                    } catch (e) {
                        console.warn('localStorage read failed:', e);
                    }
                    // Fallback: Cookie
                    try {
                        const cookies = document.cookie.split(';');
                        for (const cookie of cookies) {
                            const [name, ...valueParts] = cookie.trim().split('=');
                            if (name === key) {
                                const value = decodeURIComponent(valueParts.join('='));
                                return JSON.parse(value);
                            }
                        }
                    } catch (e) {
                        console.warn('Cookie read failed:', e);
                    }
                    return null;
                }

                function storageRemove(key) {
                    try {
                        localStorage.removeItem(key);
                    } catch (e) {}
                    // Also remove cookie
                    document.cookie = `${key}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/`;
                }

                function saveSectionOrder() {
                    if (!sortableContainer.value) return;
                    const items = sortableContainer.value.querySelectorAll('.sortable-item[data-section]');
                    const order = [...items].map(el => el.dataset.section);
                    if (storageSet('sfml-section-order', order)) {
                        console.log('Section order saved:', order);
                    }
                }

                function restoreSectionOrder() {
                    const savedOrder = storageGet('sfml-section-order') || [];
                    if (!savedOrder.length || !sortableContainer.value) return;

                    const container = sortableContainer.value;
                    const items = [...container.querySelectorAll('.sortable-item[data-section]')];

                    savedOrder.forEach(sectionId => {
                        const item = items.find(el => el.dataset.section === sectionId);
                        if (item) {
                            container.appendChild(item);
                        }
                    });
                    console.log('Section order restored:', savedOrder);
                }

                function resetSectionOrder() {
                    storageRemove('sfml-section-order');
                    if (!sortableContainer.value) return;

                    const container = sortableContainer.value;
                    defaultSectionOrder.forEach(sectionId => {
                        const item = container.querySelector(`.sortable-item[data-section="${sectionId}"]`);
                        if (item) {
                            container.appendChild(item);
                        }
                    });
                    Toast.success('Sektions-Reihenfolge zur√ºckgesetzt', 'Layout');
                }

                // Hold-to-Drag Visual Feedback (Mobile)
                const dragHoldIndicator = document.getElementById('drag-hold-indicator');
                let holdTimeout = null;
                let currentTouchTarget = null;

                function initDragHoldFeedback() {
                    if (!sortableContainer.value) return;

                    const handles = sortableContainer.value.querySelectorAll(
                        '.section-header, .energy-flow-header, .power-sources-header, ' +
                        '.forecast-overview-header, .chart-header, .energy-balance-header, .stats-container-header'
                    );

                    handles.forEach(handle => {
                        handle.addEventListener('touchstart', onDragHoldStart, { passive: true });
                        handle.addEventListener('touchend', onDragHoldEnd);
                        handle.addEventListener('touchcancel', onDragHoldEnd);
                        handle.addEventListener('touchmove', onDragHoldMove, { passive: true });
                    });
                }

                function onDragHoldStart(e) {
                    if (!e.touches || e.touches.length === 0) return;

                    const touch = e.touches[0];
                    currentTouchTarget = e.target;

                    // Position indicator at touch point
                    dragHoldIndicator.style.left = touch.clientX + 'px';
                    dragHoldIndicator.style.top = touch.clientY + 'px';
                    dragHoldIndicator.classList.remove('complete');
                    dragHoldIndicator.classList.add('active');

                    // After 2 seconds, show completion effect
                    holdTimeout = setTimeout(() => {
                        dragHoldIndicator.classList.remove('active');
                        dragHoldIndicator.classList.add('complete');
                        // Haptic feedback if available
                        if (navigator.vibrate) {
                            navigator.vibrate(50);
                        }
                        setTimeout(() => {
                            dragHoldIndicator.classList.remove('complete');
                        }, 300);
                    }, 2000);
                }

                function onDragHoldEnd() {
                    if (holdTimeout) {
                        clearTimeout(holdTimeout);
                        holdTimeout = null;
                    }
                    dragHoldIndicator.classList.remove('active');
                    currentTouchTarget = null;
                }

                function onDragHoldMove(e) {
                    if (!e.touches || e.touches.length === 0 || !dragHoldIndicator.classList.contains('active')) return;

                    const touch = e.touches[0];
                    const startX = parseFloat(dragHoldIndicator.style.left);
                    const startY = parseFloat(dragHoldIndicator.style.top);
                    const moveDistance = Math.sqrt(
                        Math.pow(touch.clientX - startX, 2) +
                        Math.pow(touch.clientY - startY, 2)
                    );

                    // Cancel if moved more than 20px (scrolling)
                    if (moveDistance > 20) {
                        onDragHoldEnd();
                    }
                }

                // Load dashboard settings from API on init
                async function loadDashboardSettings() {
                    try {
                        const response = await fetch('/api/sfml_stats/dashboard_settings');
                        const data = await response.json();
                        if (data.success && data.data) {
                            // Only apply from API if not set in localStorage (user preference takes priority)
                            if (!localStorage.getItem('sfml-dashboard-style') && data.data.dashboard_style) {
                                dashboardStyle.value = data.data.dashboard_style;
                            }
                        }
                    } catch (e) {
                        console.warn('Could not load dashboard settings:', e);
                    }
                }
                loadDashboardSettings();
                const weather = reactive({ temperature: null, radiation: null, humidity: null, wind: null, clouds: null });
                const weatherCorrected = reactive({ temperature: null, radiation: null, humidity: null, wind: null, clouds: null });
                const weatherHA = reactive({ state: null, temperature: null, humidity: null, wind_speed: null, cloud_coverage: null, pressure: null });
                const live = reactive({ power: 0, yield: 0, price: null });
                const currentPrice = reactive({ total_price: null, net_price: null, hour: null });
                const hasBattery = ref(false);  // True if battery sensor is configured

                // Helper: Parse sunrise/sunset time string to minutes since midnight
                function parseSunMinutes(timeStr) {
                    if (!timeStr) return null;
                    const parts = timeStr.includes('T') ? timeStr.split('T')[1].split(':') : timeStr.split(':');
                    return parseInt(parts[0]) * 60 + parseInt(parts[1]);
                }

                // Helper: Parse hour from sunrise/sunset time string
                function parseSunHour(timeStr) {
                    if (!timeStr) return null;
                    return parseInt(timeStr.includes('T') ? timeStr.split('T')[1].split(':')[0] : timeStr.split(':')[0]);
                }

                // Helper: Get production hour range from sunrise/sunset (¬±2h buffer)
                function getProductionHourRange() {
                    let startHour = 6, endHour = 20; // Fallbacks
                    const sunriseH = parseSunHour(sunPosition.sunrise);
                    const sunsetH = parseSunHour(sunPosition.sunset);
                    if (sunriseH !== null) startHour = Math.max(0, sunriseH - 2);
                    if (sunsetH !== null) endHour = Math.min(23, sunsetH + 2);
                    return { startHour, endHour };
                }

                // Day/Night mode based on sunrise/sunset
                const isNightTime = computed(() => {
                    const sunriseMin = parseSunMinutes(sunPosition.sunrise);
                    const sunsetMin = parseSunMinutes(sunPosition.sunset);
                    if (sunriseMin === null || sunsetMin === null) return false;
                    const currentMin = new Date().getHours() * 60 + new Date().getMinutes();
                    return currentMin < sunriseMin || currentMin > sunsetMin;
                });
                const forecast = reactive({ todayTotal: 0, todayTotalCorrected: null, todayRemaining: 0, tomorrowTotal: 0, dayAfterTomorrowTotal: 0, todayHours: [], tomorrowHours: [], dayAfterTomorrowHours: [], maxHourly: 0.5 });
                const todayAccuracy = ref(null);  // Tagesgenauigkeit in %
                const bestHour = reactive({ hour: null, prediction_kwh: null });
                const kpis = reactive({ weekProduction: 0, avgAccuracy: 0, priceMin: 0, priceMax: 0, forecastWeek: 0 });

                // NEW: Energy Flow & Statistics
                const energyFlow = reactive({
                    flows: { solar_power: null, solar_to_house: null, solar_to_battery: null, battery_to_house: null, grid_to_house: null, grid_to_battery: null, house_to_grid: null },
                    battery: { soc: null, power: null },
                    home: { consumption: null },
                    statistics: { solar_yield_daily: null, grid_import_daily: null, grid_import_yearly: null, battery_charge_solar_daily: null, battery_charge_grid_daily: null, price_total: null },
                    panels: [],  // Individual PV panels [{id, name, power, max_today}, ...]
                    consumers: { heatpump: null, heatingrod: null, wallbox: null }  // Consumer sensors (WP, Heizstab, Wallbox)
                });

                // Production Time & Sun Times
                const productionTime = reactive({ active: false, start_time: null, end_time: null, duration_seconds: 0 });
                const sunTimes = reactive({ sunrise: null, sunset: null });

                // Sun Position (from astronomy_cache.json)
                const sunPosition = reactive({ elevation_deg: null, azimuth_deg: null, direction: null, sunrise: null, sunset: null, daylight_hours: null });

                // Price Stats for Chart Header (Heute & Morgen)
                const priceStats = reactive({ max: '‚Äî', maxHour: '‚Äî', min: '‚Äî', minHour: '‚Äî' });
                const priceStatsTomorrow = reactive({ max: '‚Äî', maxHour: '‚Äî', min: '‚Äî', minHour: '‚Äî' });

                const stats = reactive({
                    peaks: { today: {}, all_time: {} },
                    production: { today: {}, tomorrow: {} },
                    statistics: { current_week: {}, current_month: {}, last_7_days: {}, last_30_days: {}, last_365_days: {} },
                    production_time: null
                });

                // Panel Groups (Prognose + IST pro Gruppe)
                const panelGroups = reactive({
                    available: false,
                    groups: {}
                });

                // Panel Groups Validation (Summe vs. solar_yield_daily)
                const panelGroupsValidation = computed(() => {
                    if (!panelGroups.available || !panelGroups.groups) return { valid: true, deviation: 0 };
                    const groupSum = Object.values(panelGroups.groups).reduce((sum, g) => sum + (g.actual_total_kwh || 0), 0);
                    const solarDaily = energyFlow.statistics?.solar_yield_daily || 0;
                    if (solarDaily === 0 || groupSum === 0) return { valid: true, deviation: 0, groupSum, solarDaily };
                    const deviation = Math.abs(groupSum - solarDaily) / solarDaily * 100;
                    return { valid: deviation <= 10, deviation: deviation.toFixed(1), groupSum: groupSum.toFixed(3), solarDaily: solarDaily.toFixed(3) };
                });

                // Check if only one panel group exists (to avoid duplicate charts)
                const hasSinglePanelGroup = computed(() => {
                    return panelGroups.available && Object.keys(panelGroups.groups).length === 1;
                });

                // Panel Group Modal
                const panelGroupModal = reactive({
                    isOpen: false,
                    groupName: '',
                    groupData: null
                });

                // Production Today Modal
                const productionTodayModal = reactive({
                    isOpen: false,
                    hourlyData: []
                });

                // History Stats f√ºr erweiterte Charts
                const historyStats = reactive({
                    avgProduction: null,
                    avgForecast: null,
                    avgAccuracy: null,
                    totalProduction: null,
                    allTimePeak: null,
                    monthPeak: null,
                    weeklySavings: null
                });

                // Energy Balance - Stromrechnung & Autarkie (Jahresbilanz)
                const energyBalance = reactive({
                    period: 'year',  // Jetzt immer Jahresbilanz
                    periodStart: null,  // Start des Abrechnungszeitraums
                    periodEnd: null,  // Ende (heute)
                    periodProgress: 0,  // Fortschritt in %
                    daysElapsed: 0,  // Tage seit Start
                    daysTotal: 365,  // Gesamte Tage
                    totalConsumption: null,  // Gesamtverbrauch in kWh (aus Smartmeter)
                    solarProduction: null,  // Gesamte Solarproduktion kWh
                    solarSelfConsumption: null,  // Solar-Eigenverbrauch in kWh
                    batteryContribution: null,  // Akku ‚Üí Haus in kWh
                    gridImport: null,  // Netzbezug in kWh (das bezahlt man!)
                    gridExport: null,  // Einspeisung in kWh
                    autarkiePercent: null,  // (Solar + Akku) / Gesamtverbrauch * 100
                    solarSelfPercent: null,  // Solar-Anteil am Verbrauch
                    batteryPercent: null,  // Akku-Anteil am Verbrauch
                    gridPercent: null,  // Netz-Anteil am Verbrauch
                    estimatedCost: null,  // Gesch√§tzte Stromkosten in ‚Ç¨
                    avgPrice: null,  // Durchschnittlicher Strompreis ct/kWh
                    priceMode: 'dynamic',  // 'fixed' oder 'dynamic'
                    savings: null,  // Ersparnis durch Solar + Akku in ‚Ç¨
                    savedKwh: null,  // Gesparte kWh (nicht vom Netz bezogen)
                    projectedYearlyCost: null,  // Hochrechnung auf ganzes Jahr
                    projectedYearlySavings: null,  // Hochgerechnete Ersparnis
                    avgDailyProduction: null,  // √ò Tagesproduktion
                    bestDay: null,  // Bester Tag
                    bestDayKwh: null,  // kWh am besten Tag
                    // Detaillierte Flows aus Riemann-Akkumulation
                    solarToHouse: 0,  // Solar ‚Üí Haus kWh
                    solarToBattery: 0,  // Solar ‚Üí Akku kWh
                    batteryToHouse: 0,  // Akku ‚Üí Haus kWh
                    batteryToGrid: 0,  // Akku ‚Üí Netz kWh (Einspeisung aus Akku)
                    homeConsumption: 0,  // Hausverbrauch kWh (aus Accumulator)
                    gridToHouse: 0,  // Netz ‚Üí Haus kWh
                    gridToBattery: 0,  // Netz ‚Üí Akku kWh
                    houseToGrid: 0,  // Einspeisung kWh
                    // Akkumulator-Status
                    accumulatorSamples: 0,  // Anzahl Messungen
                    accumulatorAvailable: false,  // Ob Daten verf√ºgbar sind
                });

                // Solar Analytics Modal
                const solarModal = reactive({
                    isOpen: false,
                    activeTab: 'week',
                    exporting: false,
                    stats: {
                        weekTotal: 0,
                        monthTotal: 0,
                        yearTotal: 0,
                        avgAccuracy: 0,
                        peakPower: 0,
                        avgDaily: 0
                    },
                    historicalData: [],
                    hourlyProduction: {}
                });
                const solarProductionChart = ref(null);
                const solarHeatmapChart = ref(null);
                const solarAccuracyChart = ref(null);
                const solarPanelGroupChart = ref(null);

                // Forecast Comparison Modal
                const forecastComparisonModal = reactive({
                    isOpen: false,
                    stats: {
                        daysWithActual: 0,
                        sfmlAccuracy: null,
                        ext1Accuracy: null,
                        ext2Accuracy: null,
                        ext1Name: null,
                        ext2Name: null,
                        bestForecast: null,
                        totalActual: 0
                    },
                    chartData: null
                });
                const forecastComparisonChart = ref(null);

                // Shadow Analytics Modal
                const shadowModal = reactive({
                    isOpen: false,
                    stats: {
                        totalLoss: null,
                        shadowHours: 0,
                        avgEfficiency: null,
                        dominantCauseLabel: null,
                        daysWithShadow: 0,
                        daysAnalyzed: 0,
                        daysLearned: 0
                    },
                    data: null
                });
                const shadowCharts = { heatmap: null, causes: null, dailyLoss: null };

                // KI-Status
                const aiStatus = reactive({
                    loaded: false,
                    model: '‚Äî',
                    accuracy: '‚Äî',
                    rmse: '‚Äî',
                    samples: '‚Äî',
                    dataPoints: '‚Äî',
                    lastTrained: '‚Äî',
                    gridRuns: '‚Äî',
                    driftEvents: 0
                });

                async function loadAIStatus() {
                    try {
                        const response = await fetch('/api/sfml_stats/ai_status');
                        const result = await response.json();
                        if (result.success && result.data) {
                            const d = result.data;
                            const m = d.model || {};
                            const gs = d.grid_search || {};
                            const MODEL_LABELS = { 'tiny_lstm': 'Hybrid-KI', 'tinylstm': 'Hybrid-KI', 'ridge': 'Ridge', 'lstm': 'LSTM' };
                            aiStatus.model = MODEL_LABELS[m.active_model] || m.active_model || '‚Äî';
                            aiStatus.accuracy = m.accuracy != null ? m.accuracy.toFixed(1) : '‚Äî';
                            aiStatus.rmse = m.rmse != null ? m.rmse.toFixed(2) : '‚Äî';
                            aiStatus.samples = m.training_samples != null ? m.training_samples.toLocaleString('de-DE') : '‚Äî';
                            aiStatus.dataPoints = d.training_data_points != null ? d.training_data_points.toLocaleString('de-DE') : '‚Äî';
                            if (m.last_trained) {
                                const dt = new Date(m.last_trained);
                                aiStatus.lastTrained = isNaN(dt) ? m.last_trained : dt.toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit' });
                            }
                            aiStatus.gridRuns = gs.total_runs ?? '‚Äî';
                            aiStatus.driftEvents = d.drift_events_7d ?? 0;
                            aiStatus.loaded = true;
                        }
                    } catch (err) {
                        console.error('Error loading AI status:', err);
                    }
                }

                // Battery Analytics Modal
                const batteryModal = reactive({
                    isOpen: false,
                    activeTab: 'week',
                    exporting: false,
                    stats: {
                        weekCharged: 0,
                        weekDischarged: 0,
                        avgSOC: 0,
                        efficiency: 0,
                        cycles: 0,
                        solarShare: 0
                    },
                    historicalData: []
                });
                const batterySOCChart = ref(null);
                const batteryChargeChart = ref(null);
                const batteryEfficiencyChart = ref(null);
                const batteryPowerChart = ref(null);

                // House Analytics Modal
                const houseModal = reactive({
                    isOpen: false,
                    activeTab: 'week',
                    exporting: false,
                    stats: {
                        weekConsumption: 0,
                        avgDaily: 0,
                        autarky: 0,
                        selfConsumption: 0,
                        solarCoverage: 0,
                        peakPower: 0
                    },
                    historicalData: [],
                    hourlyConsumption: {}
                });
                const houseConsumptionChart = ref(null);
                const houseAutarkyChart = ref(null);
                const houseSourcesChart = ref(null);
                const housePeakChart = ref(null);

                // Grid Analytics Modal
                const gridModal = reactive({
                    isOpen: false,
                    activeTab: 'week',
                    exporting: false,
                    stats: {
                        weekImport: 0,
                        weekExport: 0,
                        netBalance: 0,
                        avgPrice: 0,
                        costs: 0,
                        revenue: 0
                    },
                    historicalData: [],
                    hourlyGrid: {}
                });
                const gridFlowChart = ref(null);
                const gridPriceChart = ref(null);
                const gridMoneyChart = ref(null);
                const gridPatternChart = ref(null);

                // Consumer Analytics Modal (W√§rmepumpe, Heizstab, Wallbox)
                const consumerModal = reactive({
                    isOpen: false,
                    activeTab: 'today',
                    stats: {
                        heatpump: { power: 0, daily_kwh: 0, cop: 3.5, cost_today: 0 },
                        heatingrod: { power: 0, daily_kwh: 0, cost_today: 0 },
                        wallbox: { power: 0, daily_kwh: 0, state: 'idle', cost_today: 0 },
                        total_daily_kwh: 0,
                        total_cost_today: 0
                    },
                    billingData: null  // From billing API
                });
                const consumerBarChart = ref(null);

                // Weather Analytics Modal
                const weatherModal = reactive({
                    isOpen: false,
                    activeTab: 'week',
                    exporting: false,
                    stats: {
                        avgTemp: 0,
                        maxTemp: 0,
                        minTemp: 0,
                        totalRain: 0,
                        avgWind: 0,
                        sunHours: 0
                    },
                    historicalData: []
                });
                const weatherTempChart = ref(null);

                // Clothing Recommendation Modal
                const clothingModal = reactive({
                    isOpen: false,
                    title: 'Au√üenteam-Ausr√ºstungsanalyse',
                    text: '',
                    recommendation: {
                        unterbekleidung: { name: '', icon: '' },
                        oberbekleidung: { name: '', icon: '' },
                        jacke: { name: '', icon: '' },
                        kopfbedeckung: { name: '', icon: '' },
                        zusaetze: []
                    },
                    weather: {
                        temperature: null,
                        feels_like: null,
                        humidity: null,
                        wind_speed: null,
                        rain_probability: null,
                        uv_index: null
                    },
                    labels: {
                        temperature: 'Temperatur',
                        feels_like: 'Gef√ºhlt',
                        humidity: 'Luftfeuchtigkeit',
                        wind: 'Wind',
                        rain_prob: 'Regenwahrsch.',
                        pants: 'Hose',
                        top: 'Oberteil',
                        jacket: 'Jacke',
                        headwear: 'Kopfbedeckung',
                        accessories: 'Zubeh√∂r'
                    }
                });

                // Power Sources Modal
                const powerSourcesModal = reactive({
                    isOpen: false,
                    activeTab: 'today',
                    exporting: false,
                    stats: {
                        solarTotal: 0,
                        solarToHouse: 0,
                        solarToBattery: 0,
                        batteryTotal: 0,
                        gridTotal: 0,
                        consumptionTotal: 0,
                        autarky: 0,
                        selfConsumption: 0
                    },
                    historicalData: [],
                    customStartDate: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
                    customEndDate: new Date().toISOString().split('T')[0]
                });
                const powerSourcesPreviewChart = ref(null);
                const powerSourcesMainChart = ref(null);
                const powerSourcesSOCChart = ref(null);
                const powerSourcesPieChart = ref(null);
                const weatherRadiationChart = ref(null);
                const weatherRainChart = ref(null);
                const weatherWindChart = ref(null);
                // IST vs KI Comparison Charts
                const weatherTempComparisonChart = ref(null);
                const weatherRadiationComparisonChart = ref(null);
                const weatherCloudsComparisonChart = ref(null);
                const weatherAccuracyChart = ref(null);

                const productionChart = ref(null);
                const priceChart = ref(null);
                const timelineChart = ref(null);
                const todayProductionChart = ref(null);
                const accuracyChart = ref(null);
                // Neue Chart-Refs
                const trendChart = ref(null);
                // Panel Group Chart Refs (dynamisch)
                const panelGroupChartRefs = reactive({});
                const panelGroupCharts = reactive({});
                const monthlyChart = ref(null);
                let charts = {};

                // Echtzeit-Produktionsdaten f√ºr heute (st√ºndlich)
                const todayProduction = reactive({ hours: [], currentPower: 0 });

                const weatherIcon = computed(() => {
                    if (weather.radiation > 400) return '‚òÄÔ∏è';
                    if (weather.radiation > 150) return 'üå§Ô∏è';
                    if (weather.clouds > 80) return '‚òÅÔ∏è';
                    if (weather.clouds > 50) return '‚õÖ';
                    return 'üå•Ô∏è';
                });

                const weatherCondition = computed(() => {
                    if (weather.radiation > 400) return 'Sonnig';
                    if (weather.radiation > 150) return 'Heiter';
                    if (weather.clouds > 80) return 'Bew√∂lkt';
                    return 'Wechselhaft';
                });

                const weatherHAIcon = computed(() => {
                    const state = weatherHA.state?.toLowerCase() || '';
                    if (state.includes('sunny') || state.includes('clear')) return '‚òÄÔ∏è';
                    if (state.includes('partly') || state.includes('cloudy')) return '‚õÖ';
                    if (state.includes('cloud') || state.includes('overcast')) return '‚òÅÔ∏è';
                    if (state.includes('rain') || state.includes('shower')) return 'üåßÔ∏è';
                    if (state.includes('thunder') || state.includes('storm')) return '‚õàÔ∏è';
                    if (state.includes('snow')) return '‚ùÑÔ∏è';
                    if (state.includes('fog') || state.includes('mist')) return 'üå´Ô∏è';
                    if (state.includes('wind')) return 'üí®';
                    return 'üå§Ô∏è';
                });

                function getGridPower() {
                    const imp = (energyFlow.flows.grid_to_house || 0) + (energyFlow.flows.grid_to_battery || 0);
                    const exp = energyFlow.flows.house_to_grid || 0;
                    const net = imp - exp;
                    return Math.abs(net).toFixed(0);
                }

                function getGridLabel() {
                    const imp = (energyFlow.flows.grid_to_house || 0) + (energyFlow.flows.grid_to_battery || 0);
                    const exp = energyFlow.flows.house_to_grid || 0;
                    if (exp > imp) return 'Einspeisung';
                    if (imp > 0) return 'Bezug';
                    return 'Netz';
                }

                function formatTime(isoString) {
                    if (!isoString) return '';
                    try {
                        const d = new Date(isoString);
                        return d.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
                    } catch { return ''; }
                }

                function formatTimeShort(timeString) {
                    if (!timeString) return '‚Äî';
                    // API liefert bereits HH:MM Format, aber zur Sicherheit auch ISO unterst√ºtzen
                    if (typeof timeString === 'string') {
                        if (timeString.includes('T')) {
                            try {
                                const d = new Date(timeString);
                                return d.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
                            } catch { return timeString.slice(0, 5); }
                        }
                        // Already in HH:MM format
                        return timeString.slice(0, 5);
                    }
                    return '‚Äî';
                }

                function formatDuration(seconds) {
                    if (!seconds) return '‚Äî';
                    const hours = Math.floor(seconds / 3600);
                    const mins = Math.floor((seconds % 3600) / 60);
                    return `${hours}h ${mins}m`;
                }

                // ===== SOLAR ANALYTICS MODAL =====
                function openSolarModal() {
                    console.log('Opening Solar Analytics Modal...');
                    solarModal.isOpen = true;

                    // Step 1: Wait for modal DOM to render
                    setTimeout(() => {
                        console.log('Step 1: Initializing charts...');
                        initSolarCharts();

                        // Step 2: Wait for charts to init, then load data
                        setTimeout(() => {
                            console.log('Step 2: Fetching and rendering data...');
                            updateSolarCharts();
                        }, 200);
                    }, 300);
                }

                function closeSolarModal() {
                    solarModal.isOpen = false;
                    // Dispose charts to prevent memory leaks
                    if (solarProductionChart.value) solarProductionChart.value.dispose();
                    if (solarHeatmapChart.value) solarHeatmapChart.value.dispose();
                    if (solarAccuracyChart.value) solarAccuracyChart.value.dispose();
                    if (solarPanelGroupChart.value) solarPanelGroupChart.value.dispose();
                    solarProductionChart.value = null;
                    solarHeatmapChart.value = null;
                    solarAccuracyChart.value = null;
                    solarPanelGroupChart.value = null;
                }

                async function exportSolarAnalytics() {
                    try {
                        solarModal.exporting = true;
                        Toast.info('Export wird vorbereitet...', 'Solar Analytics');

                        const exportData = {
                            period: solarModal.activeTab,
                            stats: solarModal.stats,
                            data: solarModal.historicalData
                        };

                        const response = await fetch('/api/sfml_stats/export_solar_analytics', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(exportData)
                        });

                        if (!response.ok) {
                            throw new Error(`Export failed: ${response.statusText}`);
                        }

                        const blob = await response.blob();
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `solar_analytics_${solarModal.activeTab}_${new Date().toISOString().slice(0, 10)}.png`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(url);

                        Toast.success('Chart wurde exportiert', 'Solar Analytics');
                    } catch (error) {
                        console.error('Export error:', error);
                        Toast.error(error.message, 'Export fehlgeschlagen');
                    } finally {
                        solarModal.exporting = false;
                    }
                }

                // ===== BATTERY ANALYTICS MODAL FUNCTIONS =====
                function openBatteryModal() {
                    console.log('Opening Battery Analytics Modal...');
                    batteryModal.isOpen = true;
                    setTimeout(() => {
                        initBatteryCharts();
                        setTimeout(() => {
                            updateBatteryCharts();
                        }, 200);
                    }, 300);
                }

                function closeBatteryModal() {
                    batteryModal.isOpen = false;
                    if (batterySOCChart.value) batterySOCChart.value.dispose();
                    if (batteryChargeChart.value) batteryChargeChart.value.dispose();
                    if (batteryEfficiencyChart.value) batteryEfficiencyChart.value.dispose();
                    if (batteryPowerChart.value) batteryPowerChart.value.dispose();
                    batterySOCChart.value = null;
                    batteryChargeChart.value = null;
                    batteryEfficiencyChart.value = null;
                    batteryPowerChart.value = null;
                }

                async function exportBatteryAnalytics() {
                    try {
                        batteryModal.exporting = true;
                        Toast.info('Export wird vorbereitet...', 'Batterie Analytics');
                        const exportData = {
                            period: batteryModal.activeTab,
                            stats: batteryModal.stats,
                            data: batteryModal.historicalData
                        };
                        const response = await fetch('/api/sfml_stats/export_battery_analytics', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(exportData)
                        });
                        if (!response.ok) throw new Error(`Export failed: ${response.statusText}`);
                        const blob = await response.blob();
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `battery_analytics_${batteryModal.activeTab}_${new Date().toISOString().slice(0, 10)}.png`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(url);
                        Toast.success('Chart wurde exportiert', 'Batterie Analytics');
                    } catch (error) {
                        console.error('Battery export error:', error);
                        Toast.error(error.message, 'Export fehlgeschlagen');
                    } finally {
                        batteryModal.exporting = false;
                    }
                }

                function initBatteryCharts() {
                    setTimeout(() => {
                        const socEl = document.getElementById('battery-soc-chart');
                        const chargeEl = document.getElementById('battery-charge-chart');
                        const efficiencyEl = document.getElementById('battery-efficiency-chart');
                        const powerEl = document.getElementById('battery-power-chart');
                        if (socEl && socEl.offsetWidth > 0) batterySOCChart.value = echarts.init(socEl);
                        if (chargeEl && chargeEl.offsetWidth > 0) batteryChargeChart.value = echarts.init(chargeEl);
                        if (efficiencyEl && efficiencyEl.offsetWidth > 0) batteryEfficiencyChart.value = echarts.init(efficiencyEl);
                        if (powerEl && powerEl.offsetWidth > 0) batteryPowerChart.value = echarts.init(powerEl);
                    }, 150);
                }

                async function updateBatteryCharts() {
                    try {
                        const days = batteryModal.activeTab === 'week' ? 7 : batteryModal.activeTab === 'month' ? 30 : 365;
                        const response = await fetch(`/api/sfml_stats/energy_sources_daily_stats?days=${days}`);
                        const result = await response.json();

                        const history = [];

                        if (result.success && result.daily_stats) {
                            const dailyStats = result.daily_stats;
                            const sortedDates = Object.keys(dailyStats).sort();

                            for (const dateStr of sortedDates) {
                                const dayData = dailyStats[dateStr];
                                const chargedFromSolar = dayData.battery_charge_solar_kwh || dayData.solar_to_battery_kwh || 0;
                                const chargedFromGrid = dayData.battery_charge_grid_kwh || dayData.grid_to_battery_kwh || 0;
                                const chargedKwh = chargedFromSolar + chargedFromGrid;
                                const dischargedKwh = dayData.battery_to_house_kwh || 0;
                                const efficiency = chargedKwh > 0 ? (dischargedKwh / chargedKwh) * 100 : 0;

                                history.push({
                                    date: dateStr,
                                    charged_kwh: chargedKwh,
                                    charged_solar_kwh: chargedFromSolar,
                                    charged_grid_kwh: chargedFromGrid,
                                    discharged_kwh: dischargedKwh,
                                    efficiency: Math.min(100, efficiency),
                                });
                            }
                        }

                        if (history.length === 0) {
                            console.warn('No battery stats available, showing empty data');
                        }

                        batteryModal.historicalData = history;

                        const now = new Date();
                        const dayOfWeek = now.getDay();
                        const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
                        const monday = new Date(now);
                        monday.setDate(now.getDate() + mondayOffset);
                        monday.setHours(0, 0, 0, 0);
                        const sundayEnd = new Date(monday);
                        sundayEnd.setDate(monday.getDate() + 6);
                        sundayEnd.setHours(23, 59, 59, 999);

                        const mondayStr = monday.toISOString().slice(0, 10);
                        const sundayStr = sundayEnd.toISOString().slice(0, 10);

                        const weekData = history.filter(d => d.date >= mondayStr && d.date <= sundayStr);

                        batteryModal.stats.weekCharged = weekData.reduce((sum, d) => sum + d.charged_kwh, 0);
                        batteryModal.stats.weekDischarged = weekData.reduce((sum, d) => sum + d.discharged_kwh, 0);
                        // SOC from live data
                        batteryModal.stats.avgSOC = energyFlow.battery?.soc || 0;
                        const totalCharged = history.reduce((sum, d) => sum + d.charged_kwh, 0);
                        const totalDischarged = history.reduce((sum, d) => sum + d.discharged_kwh, 0);
                        batteryModal.stats.efficiency = totalCharged > 0 ? (totalDischarged / totalCharged) * 100 : 0;
                        // Estimate capacity from max daily discharge
                        const maxDailyDischarge = history.length > 0 ? Math.max(...history.map(d => d.discharged_kwh)) : 10;
                        const estimatedCapacity = Math.max(5, Math.ceil(maxDailyDischarge));
                        batteryModal.stats.cycles = batteryModal.stats.weekDischarged / estimatedCapacity;
                        const totalSolarCharge = history.reduce((sum, d) => sum + d.charged_solar_kwh, 0);
                        batteryModal.stats.solarShare = totalCharged > 0 ? (totalSolarCharge / totalCharged) * 100 : 0;

                        renderBatteryCharts();
                    } catch (error) {
                        console.error('Error fetching battery data:', error);
                    }
                }

                function renderBatteryCharts() {
                    const tab = batteryModal.activeTab;
                    const data = batteryModal.historicalData || [];

                    if (!data.length) return;

                    const dates = data.map(d => d.date.slice(5));

                    // Charge Sources Chart (Solar vs Grid)
                    if (batterySOCChart.value) {
                        const totalSolarCharge = data.reduce((sum, d) => sum + d.charged_solar_kwh, 0);
                        const totalGridCharge = data.reduce((sum, d) => sum + d.charged_grid_kwh, 0);
                        batterySOCChart.value.setOption({
                            tooltip: { trigger: 'item', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#22c55e', textStyle: { color: '#fff' },
                                formatter: params => `${params.name}: ${params.value.toFixed(2)} kWh (${params.percent}%)` },
                            legend: { top: '5%', left: 'center', textStyle: { color: '#fff' } },
                            series: [{
                                name: 'Ladequellen',
                                type: 'pie',
                                radius: ['40%', '70%'],
                                center: ['50%', '55%'],
                                itemStyle: { borderRadius: 10, borderColor: '#1a1a2e', borderWidth: 2 },
                                label: { show: true, color: '#fff' },
                                data: [
                                    { value: totalSolarCharge, name: 'Solar', itemStyle: { color: '#fbbf24' } },
                                    { value: totalGridCharge, name: 'Netz', itemStyle: { color: '#8b5cf6' } }
                                ]
                            }]
                        });
                    }

                    // Charge/Discharge Chart
                    if (batteryChargeChart.value) {
                        batteryChargeChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#22c55e', textStyle: { color: '#fff' } },
                            legend: { data: ['Geladen', 'Entladen'], textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: { type: 'value', name: 'kWh', nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                            series: [
                                { name: 'Geladen', type: 'bar', data: data.map(d => d.charged_kwh), itemStyle: { color: '#22c55e' } },
                                { name: 'Entladen', type: 'bar', data: data.map(d => -d.discharged_kwh), itemStyle: { color: '#fb923c' } }
                            ],
                            grid: { left: 60, right: 30, top: 60, bottom: 50 }
                        });
                    }

                    // Efficiency Chart
                    if (batteryEfficiencyChart.value) {
                        const avgEff = data.reduce((sum, d) => sum + d.efficiency, 0) / data.length;
                        batteryEfficiencyChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#3b82f6', textStyle: { color: '#fff' } },
                            legend: { data: ['Wirkungsgrad', 'Durchschnitt'], textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: { type: 'value', name: '%', min: 0, max: 100, nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                            series: [
                                { name: 'Wirkungsgrad', type: 'line', data: data.map(d => d.efficiency), smooth: true, itemStyle: { color: '#3b82f6' }, lineStyle: { width: 2 } },
                                { name: 'Durchschnitt', type: 'line', data: Array(data.length).fill(avgEff), lineStyle: { type: 'dashed', color: '#fb923c' } }
                            ],
                            grid: { left: 60, right: 30, top: 60, bottom: 50 }
                        });
                    }

                    // Charge source breakdown per day (Solar vs Grid charging + Discharge)
                    if (batteryPowerChart.value) {
                        batteryPowerChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#22c55e', textStyle: { color: '#fff' } },
                            legend: { data: ['Solar-Ladung', 'Netz-Ladung', 'Entladung'], textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: { type: 'value', name: 'kWh', nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                            series: [
                                { name: 'Solar-Ladung', type: 'bar', stack: 'charge', data: data.map(d => d.charged_solar_kwh), itemStyle: { color: '#fbbf24' } },
                                { name: 'Netz-Ladung', type: 'bar', stack: 'charge', data: data.map(d => d.charged_grid_kwh), itemStyle: { color: '#8b5cf6' } },
                                { name: 'Entladung', type: 'bar', data: data.map(d => -d.discharged_kwh), itemStyle: { color: '#fb923c' } }
                            ],
                            grid: { left: 60, right: 30, top: 60, bottom: 50 }
                        });
                    }
                }

                // ===== HOUSE ANALYTICS MODAL FUNCTIONS =====
                function openHouseModal() {
                    console.log('Opening House Analytics Modal...');
                    houseModal.isOpen = true;
                    setTimeout(() => {
                        initHouseCharts();
                        setTimeout(() => {
                            updateHouseCharts();
                        }, 200);
                    }, 300);
                }

                function closeHouseModal() {
                    houseModal.isOpen = false;
                    if (houseConsumptionChart.value) houseConsumptionChart.value.dispose();
                    if (houseAutarkyChart.value) houseAutarkyChart.value.dispose();
                    if (houseSourcesChart.value) houseSourcesChart.value.dispose();
                    if (housePeakChart.value) housePeakChart.value.dispose();
                    houseConsumptionChart.value = null;
                    houseAutarkyChart.value = null;
                    houseSourcesChart.value = null;
                    housePeakChart.value = null;
                }

                async function exportHouseAnalytics() {
                    try {
                        houseModal.exporting = true;
                        Toast.info('Export wird vorbereitet...', 'Haus Analytics');
                        const exportData = {
                            period: houseModal.activeTab,
                            stats: houseModal.stats,
                            data: houseModal.historicalData
                        };
                        const response = await fetch('/api/sfml_stats/export_house_analytics', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(exportData)
                        });
                        if (!response.ok) throw new Error(`Export failed: ${response.statusText}`);
                        const blob = await response.blob();
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `house_analytics_${houseModal.activeTab}_${new Date().toISOString().slice(0, 10)}.png`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(url);
                        Toast.success('Chart wurde exportiert', 'Haus Analytics');
                    } catch (error) {
                        console.error('House export error:', error);
                        Toast.error(error.message, 'Export fehlgeschlagen');
                    } finally {
                        houseModal.exporting = false;
                    }
                }

                function initHouseCharts() {
                    setTimeout(() => {
                        const consumptionEl = document.getElementById('house-consumption-chart');
                        const autarkyEl = document.getElementById('house-autarky-chart');
                        const sourcesEl = document.getElementById('house-sources-chart');
                        const peakEl = document.getElementById('house-peak-chart');
                        if (consumptionEl && consumptionEl.offsetWidth > 0) houseConsumptionChart.value = echarts.init(consumptionEl);
                        if (autarkyEl && autarkyEl.offsetWidth > 0) houseAutarkyChart.value = echarts.init(autarkyEl);
                        if (sourcesEl && sourcesEl.offsetWidth > 0) houseSourcesChart.value = echarts.init(sourcesEl);
                        if (peakEl && peakEl.offsetWidth > 0) housePeakChart.value = echarts.init(peakEl);
                    }, 150);
                }

                async function updateHouseCharts() {
                    try {
                        // Fetch real daily stats from API
                        const days = houseModal.activeTab === 'week' ? 7 : houseModal.activeTab === 'month' ? 30 : 365;
                        const response = await fetch(`/api/sfml_stats/energy_sources_daily_stats?days=${days}`);
                        const result = await response.json();

                        const history = [];
                        const hourlyConsumption = result.hourly_consumption || {};

                        if (result.success && result.daily_stats) {
                            // Convert daily_stats object to array sorted by date
                            const dailyStats = result.daily_stats;
                            const sortedDates = Object.keys(dailyStats).sort();

                            for (const dateStr of sortedDates) {
                                const dayData = dailyStats[dateStr];
                                const solarToHouse = dayData.solar_to_house_kwh || 0;
                                const solarToBattery = dayData.solar_to_battery_kwh || 0;
                                const batteryKwh = dayData.battery_to_house_kwh || 0;
                                const gridKwh = dayData.grid_to_house_kwh || 0;
                                const consumptionKwh = dayData.home_consumption_kwh || (solarToHouse + batteryKwh + gridKwh);

                                // Use API values if available, otherwise calculate
                                let autarky = dayData.autarky_percent;
                                if (autarky === undefined || autarky === null) {
                                    autarky = consumptionKwh > 0 ? Math.max(0, (1 - gridKwh / consumptionKwh) * 100) : 0;
                                }
                                let selfConsumption = dayData.self_consumption_percent;
                                if (selfConsumption === undefined || selfConsumption === null || selfConsumption === 0) {
                                    const totalSolar = dayData.solar_yield_kwh || dayData.solar_total_kwh || (solarToHouse + solarToBattery);
                                    selfConsumption = totalSolar > 0 ? ((solarToHouse + solarToBattery) / totalSolar) * 100 : 0;
                                }

                                // Find peak hour from hourly data
                                const dayHourly = hourlyConsumption[dateStr] || {};
                                let peakHour = null;
                                let peakWh = 0;
                                for (const [hour, kwh] of Object.entries(dayHourly)) {
                                    if (kwh > peakWh) {
                                        peakWh = kwh;
                                        peakHour = parseInt(hour);
                                    }
                                }

                                history.push({
                                    date: dateStr,
                                    consumption_kwh: consumptionKwh,
                                    solar_kwh: solarToHouse,
                                    battery_kwh: batteryKwh,
                                    grid_kwh: gridKwh,
                                    autarky: Math.min(100, autarky),
                                    self_consumption: Math.min(100, selfConsumption),
                                    peak_hour: peakHour,
                                    peak_wh: Math.round(peakWh * 1000),
                                });
                            }
                        }

                        // Fallback if no data
                        if (history.length === 0) {
                            console.warn('No daily stats available, showing empty data');
                        }

                        houseModal.historicalData = history;
                        houseModal.hourlyConsumption = hourlyConsumption;

                        // Calculate stats - weekConsumption is Monday-Sunday of current week
                        const now = new Date();
                        const dayOfWeek = now.getDay(); // 0=Sunday, 1=Monday, ...
                        const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
                        const monday = new Date(now);
                        monday.setDate(now.getDate() + mondayOffset);
                        monday.setHours(0, 0, 0, 0);
                        const sundayEnd = new Date(monday);
                        sundayEnd.setDate(monday.getDate() + 6);
                        sundayEnd.setHours(23, 59, 59, 999);

                        const mondayStr = monday.toISOString().slice(0, 10);
                        const sundayStr = sundayEnd.toISOString().slice(0, 10);

                        // Filter data for current week (Monday-Sunday)
                        const weekData = history.filter(d => d.date >= mondayStr && d.date <= sundayStr);

                        houseModal.stats.weekConsumption = weekData.reduce((sum, d) => sum + d.consumption_kwh, 0);
                        houseModal.stats.avgDaily = history.length > 0 ? history.reduce((sum, d) => sum + d.consumption_kwh, 0) / history.length : 0;
                        houseModal.stats.autarky = history.length > 0 ? history.reduce((sum, d) => sum + d.autarky, 0) / history.length : 0;
                        houseModal.stats.selfConsumption = history.length > 0 ? history.reduce((sum, d) => sum + d.self_consumption, 0) / history.length : 0;
                        const totalSolar = history.reduce((sum, d) => sum + d.solar_kwh, 0);
                        const totalConsumption = history.reduce((sum, d) => sum + d.consumption_kwh, 0);
                        houseModal.stats.solarCoverage = totalConsumption > 0 ? (totalSolar / totalConsumption) * 100 : 0;
                        houseModal.stats.peakPower = history.length > 0 ? Math.max(...history.map(d => d.peak_wh || 0)) : 0;

                        renderHouseCharts();
                    } catch (error) {
                        console.error('Error fetching house data:', error);
                    }
                }

                function renderHouseCharts() {
                    const data = houseModal.historicalData || [];
                    if (!data.length) return;

                    const dates = data.map(d => d.date.slice(5));

                    // Consumption Chart
                    if (houseConsumptionChart.value) {
                        houseConsumptionChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#00ffff', textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: { type: 'value', name: 'kWh', nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                            series: [{
                                name: 'Verbrauch',
                                type: 'bar',
                                data: data.map(d => d.consumption_kwh),
                                itemStyle: { color: '#00ffff' }
                            }],
                            grid: { left: 60, right: 30, top: 40, bottom: 50 }
                        });
                    }

                    // Autarky Chart
                    if (houseAutarkyChart.value) {
                        houseAutarkyChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#00ffff', textStyle: { color: '#fff' } },
                            legend: { data: ['Autarkie', 'Eigenverbrauch'], textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: { type: 'value', name: '%', min: 0, max: 100, nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                            series: [
                                { name: 'Autarkie', type: 'line', data: data.map(d => d.autarky), smooth: true, itemStyle: { color: '#22c55e' }, lineStyle: { width: 2 } },
                                { name: 'Eigenverbrauch', type: 'line', data: data.map(d => d.self_consumption), smooth: true, itemStyle: { color: '#fbbf24' }, lineStyle: { width: 2 } }
                            ],
                            grid: { left: 60, right: 30, top: 60, bottom: 50 }
                        });
                    }

                    // Sources Chart (Pie)
                    if (houseSourcesChart.value) {
                        const totalSolar = data.reduce((sum, d) => sum + d.solar_kwh, 0);
                        const totalBattery = data.reduce((sum, d) => sum + d.battery_kwh, 0);
                        const totalGrid = data.reduce((sum, d) => sum + d.grid_kwh, 0);

                        houseSourcesChart.value.setOption({
                            tooltip: { trigger: 'item', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#00ffff', textStyle: { color: '#fff' } },
                            legend: { top: '5%', left: 'center', textStyle: { color: '#fff' } },
                            series: [{
                                name: 'Energiequellen',
                                type: 'pie',
                                radius: ['40%', '70%'],
                                avoidLabelOverlap: false,
                                itemStyle: { borderRadius: 10, borderColor: '#1a1a2e', borderWidth: 2 },
                                label: { show: true, color: '#fff' },
                                data: [
                                    { value: totalSolar, name: 'Solar', itemStyle: { color: '#fbbf24' } },
                                    { value: totalBattery, name: 'Batterie', itemStyle: { color: '#22c55e' } },
                                    { value: totalGrid, name: 'Netz', itemStyle: { color: '#8b5cf6' } }
                                ]
                            }]
                        });
                    }

                    // Peak Times Chart - Average consumption by hour of day
                    if (housePeakChart.value) {
                        const hourlyConsumption = houseModal.hourlyConsumption || {};
                        // Calculate average consumption per hour across all days in view
                        const hourSums = new Array(24).fill(0);
                        const hourCounts = new Array(24).fill(0);
                        for (const d of data) {
                            const dayHourly = hourlyConsumption[d.date] || {};
                            for (let h = 0; h < 24; h++) {
                                const val = dayHourly[h] || 0;
                                if (val > 0) {
                                    hourSums[h] += val * 1000; // kWh ‚Üí Wh
                                    hourCounts[h]++;
                                }
                            }
                        }
                        const hourAvgs = hourSums.map((sum, i) => hourCounts[i] > 0 ? Math.round(sum / hourCounts[i]) : 0);
                        const peakHour = hourAvgs.indexOf(Math.max(...hourAvgs));
                        const hourLabels = Array.from({ length: 24 }, (_, i) => `${String(i).padStart(2, '0')}:00`);

                        housePeakChart.value.setOption({
                            tooltip: {
                                trigger: 'axis',
                                backgroundColor: 'rgba(30, 30, 62, 0.95)',
                                borderColor: '#00ffff',
                                textStyle: { color: '#fff' },
                                formatter: params => `${params[0].axisValue}<br/>√ò ${params[0].value} Wh`
                            },
                            xAxis: { type: 'category', data: hourLabels, axisLabel: { color: '#888', interval: 1, rotate: 45 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: { type: 'value', name: 'Wh', nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                            series: [{
                                name: '√ò Verbrauch',
                                type: 'bar',
                                data: hourAvgs.map((val, i) => ({
                                    value: val,
                                    itemStyle: { color: i === peakHour ? '#ff6b6b' : '#00ffff' }
                                })),
                            }],
                            grid: { left: 60, right: 30, top: 40, bottom: 60 }
                        });
                    }
                }

                // ===== GRID ANALYTICS MODAL FUNCTIONS =====
                function openGridModal() {
                    console.log('Opening Grid Analytics Modal...');
                    gridModal.isOpen = true;
                    setTimeout(() => {
                        initGridCharts();
                        setTimeout(() => {
                            updateGridCharts();
                        }, 200);
                    }, 300);
                }

                function closeGridModal() {
                    gridModal.isOpen = false;
                    if (gridFlowChart.value) gridFlowChart.value.dispose();
                    if (gridPriceChart.value) gridPriceChart.value.dispose();
                    if (gridMoneyChart.value) gridMoneyChart.value.dispose();
                    if (gridPatternChart.value) gridPatternChart.value.dispose();
                    gridFlowChart.value = null;
                    gridPriceChart.value = null;
                    gridMoneyChart.value = null;
                    gridPatternChart.value = null;
                }

                async function exportGridAnalytics() {
                    try {
                        gridModal.exporting = true;
                        Toast.info('Export wird vorbereitet...', 'Netz Analytics');
                        const exportData = {
                            period: gridModal.activeTab,
                            stats: gridModal.stats,
                            data: gridModal.historicalData
                        };
                        const response = await fetch('/api/sfml_stats/export_grid_analytics', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(exportData)
                        });
                        if (!response.ok) throw new Error(`Export failed: ${response.statusText}`);
                        const blob = await response.blob();
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `grid_analytics_${gridModal.activeTab}_${new Date().toISOString().slice(0, 10)}.png`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(url);
                        Toast.success('Chart wurde exportiert', 'Netz Analytics');
                    } catch (error) {
                        console.error('Grid export error:', error);
                        Toast.error(error.message, 'Export fehlgeschlagen');
                    } finally {
                        gridModal.exporting = false;
                    }
                }

                function initGridCharts() {
                    setTimeout(() => {
                        const flowEl = document.getElementById('grid-flow-chart');
                        const priceEl = document.getElementById('grid-price-chart');
                        const moneyEl = document.getElementById('grid-money-chart');
                        const patternEl = document.getElementById('grid-pattern-chart');
                        if (flowEl && flowEl.offsetWidth > 0) gridFlowChart.value = echarts.init(flowEl);
                        if (priceEl && priceEl.offsetWidth > 0 && energyBalance.priceMode === 'dynamic') gridPriceChart.value = echarts.init(priceEl);
                        if (moneyEl && moneyEl.offsetWidth > 0 && energyBalance.priceMode !== 'none') gridMoneyChart.value = echarts.init(moneyEl);
                        if (patternEl && patternEl.offsetWidth > 0) gridPatternChart.value = echarts.init(patternEl);
                    }, 150);
                }

                async function updateGridCharts() {
                    try {
                        // Fetch real daily stats from API
                        const days = gridModal.activeTab === 'week' ? 7 : gridModal.activeTab === 'month' ? 30 : 365;
                        const response = await fetch(`/api/sfml_stats/energy_sources_daily_stats?days=${days}`);
                        const result = await response.json();

                        const history = [];
                        const dailyPrices = result.daily_prices || {};
                        const hourlyGrid = result.hourly_grid || {};

                        if (result.success && result.daily_stats) {
                            const dailyStats = result.daily_stats;
                            const sortedDates = Object.keys(dailyStats).sort();

                            for (const dateStr of sortedDates) {
                                const dayData = dailyStats[dateStr];
                                // Total grid import = grid_to_house + grid_to_battery
                                const gridToHouse = dayData.grid_to_house_kwh || 0;
                                const gridToBattery = dayData.grid_to_battery_kwh || 0;
                                const importKwh = dayData.grid_import_kwh || (gridToHouse + gridToBattery);
                                const exportKwh = Math.abs(dayData.grid_export_kwh || 0);
                                // Use real GPM price, fallback to collector price
                                const avgPrice = dailyPrices[dateStr] || dayData.price_ct_kwh || dayData.avg_price_ct || 0;
                                const feedInTariff = energyFlow.feed_in_tariff || 8.1;

                                history.push({
                                    date: dateStr,
                                    import_kwh: importKwh,
                                    grid_to_house_kwh: gridToHouse,
                                    grid_to_battery_kwh: gridToBattery,
                                    export_kwh: exportKwh,
                                    avg_price_ct: avgPrice,
                                    costs_eur: (importKwh * avgPrice) / 100,
                                    revenue_eur: (exportKwh * feedInTariff) / 100
                                });
                            }
                        }

                        if (history.length === 0) {
                            console.warn('No grid stats available, showing empty data');
                        }

                        gridModal.historicalData = history;
                        gridModal.hourlyGrid = hourlyGrid;

                        // Calculate stats - week is Monday-Sunday of current week
                        const now = new Date();
                        const dayOfWeek = now.getDay();
                        const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
                        const monday = new Date(now);
                        monday.setDate(now.getDate() + mondayOffset);
                        monday.setHours(0, 0, 0, 0);
                        const sundayEnd = new Date(monday);
                        sundayEnd.setDate(monday.getDate() + 6);
                        sundayEnd.setHours(23, 59, 59, 999);

                        const mondayStr = monday.toISOString().slice(0, 10);
                        const sundayStr = sundayEnd.toISOString().slice(0, 10);

                        const weekData = history.filter(d => d.date >= mondayStr && d.date <= sundayStr);

                        gridModal.stats.weekImport = weekData.reduce((sum, d) => sum + d.import_kwh, 0);
                        gridModal.stats.weekExport = weekData.reduce((sum, d) => sum + d.export_kwh, 0);
                        gridModal.stats.netBalance = gridModal.stats.weekImport - gridModal.stats.weekExport;
                        const pricesWithData = history.filter(d => d.avg_price_ct > 0);
                        gridModal.stats.avgPrice = pricesWithData.length > 0 ? pricesWithData.reduce((sum, d) => sum + d.avg_price_ct, 0) / pricesWithData.length : 0;
                        gridModal.stats.costs = weekData.reduce((sum, d) => sum + d.costs_eur, 0);
                        gridModal.stats.revenue = weekData.reduce((sum, d) => sum + d.revenue_eur, 0);

                        renderGridCharts();
                    } catch (error) {
                        console.error('Error fetching grid data:', error);
                    }
                }

                function renderGridCharts() {
                    const data = gridModal.historicalData || [];
                    if (!data.length) return;

                    const dates = data.map(d => d.date.slice(5));

                    // Grid Flow Chart
                    if (gridFlowChart.value) {
                        gridFlowChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#8b5cf6', textStyle: { color: '#fff' } },
                            legend: { data: ['Bezug', 'Einspeisung'], textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: { type: 'value', name: 'kWh', nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                            series: [
                                { name: 'Bezug', type: 'bar', data: data.map(d => d.import_kwh), itemStyle: { color: '#ef4444' }, stack: 'total' },
                                { name: 'Einspeisung', type: 'bar', data: data.map(d => -d.export_kwh), itemStyle: { color: '#22c55e' }, stack: 'total' }
                            ],
                            grid: { left: 60, right: 30, top: 60, bottom: 50 }
                        });
                    }

                    // Price Chart
                    if (gridPriceChart.value) {
                        const avgPrice = data.reduce((sum, d) => sum + d.avg_price_ct, 0) / data.length;
                        gridPriceChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#8b5cf6', textStyle: { color: '#fff' } },
                            legend: { data: ['Strompreis', 'Durchschnitt'], textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: { type: 'value', name: 'ct/kWh', nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                            series: [
                                { name: 'Strompreis', type: 'line', data: data.map(d => d.avg_price_ct), smooth: true, itemStyle: { color: '#8b5cf6' }, lineStyle: { width: 2 }, areaStyle: { color: 'rgba(139, 92, 246, 0.2)' } },
                                { name: 'Durchschnitt', type: 'line', data: Array(data.length).fill(avgPrice), lineStyle: { type: 'dashed', color: '#fbbf24' } }
                            ],
                            grid: { left: 60, right: 30, top: 60, bottom: 50 }
                        });
                    }

                    // Money Chart
                    if (gridMoneyChart.value) {
                        gridMoneyChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#8b5cf6', textStyle: { color: '#fff' } },
                            legend: { data: ['Kosten', 'Erl√∂se'], textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: { type: 'value', name: '‚Ç¨', nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                            series: [
                                { name: 'Kosten', type: 'bar', data: data.map(d => d.costs_eur), itemStyle: { color: '#ef4444' } },
                                { name: 'Erl√∂se', type: 'bar', data: data.map(d => d.revenue_eur), itemStyle: { color: '#22c55e' } }
                            ],
                            grid: { left: 60, right: 30, top: 60, bottom: 50 }
                        });
                    }

                    // Pattern Chart - Average grid import by hour of day
                    if (gridPatternChart.value) {
                        const hourlyGrid = gridModal.hourlyGrid || {};
                        const hourSums = new Array(24).fill(0);
                        const hourCounts = new Array(24).fill(0);
                        for (const d of data) {
                            const dayHourly = hourlyGrid[d.date] || {};
                            for (let h = 0; h < 24; h++) {
                                const val = dayHourly[h] || 0;
                                if (val > 0) {
                                    hourSums[h] += val * 1000; // kWh ‚Üí Wh
                                    hourCounts[h]++;
                                }
                            }
                        }
                        const hourAvgs = hourSums.map((sum, i) => hourCounts[i] > 0 ? Math.round(sum / hourCounts[i]) : 0);
                        const peakHour = hourAvgs.indexOf(Math.max(...hourAvgs));
                        const hourLabels = Array.from({ length: 24 }, (_, i) => `${String(i).padStart(2, '0')}:00`);

                        gridPatternChart.value.setOption({
                            tooltip: {
                                trigger: 'axis',
                                backgroundColor: 'rgba(30, 30, 62, 0.95)',
                                borderColor: '#8b5cf6',
                                textStyle: { color: '#fff' },
                                formatter: params => `${params[0].axisValue}<br/>√ò ${params[0].value} Wh Netzbezug`
                            },
                            xAxis: { type: 'category', data: hourLabels, axisLabel: { color: '#888', interval: 1, rotate: 45 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: { type: 'value', name: 'Wh', nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                            series: [{
                                name: '√ò Netzbezug',
                                type: 'bar',
                                data: hourAvgs.map((val, i) => ({
                                    value: val,
                                    itemStyle: { color: i === peakHour ? '#ef4444' : '#8b5cf6' }
                                })),
                            }],
                            grid: { left: 60, right: 30, top: 40, bottom: 60 }
                        });
                    }
                }

                // ===== POWER SOURCES MODAL FUNCTIONS =====
                function openPowerSourcesModal() {
                    console.log('Opening Power Sources Modal...');
                    powerSourcesModal.isOpen = true;
                    setTimeout(() => {
                        initPowerSourcesCharts();
                        setTimeout(() => {
                            loadPowerSourcesData('today');
                        }, 200);
                    }, 300);
                }

                function closePowerSourcesModal() {
                    powerSourcesModal.isOpen = false;
                    if (powerSourcesMainChart.value) powerSourcesMainChart.value.dispose();
                    if (powerSourcesSOCChart.value) powerSourcesSOCChart.value.dispose();
                    if (powerSourcesPieChart.value) powerSourcesPieChart.value.dispose();
                    powerSourcesMainChart.value = null;
                    powerSourcesSOCChart.value = null;
                    powerSourcesPieChart.value = null;
                }

                function changePowerSourcesTab(tab) {
                    powerSourcesModal.activeTab = tab;
                    if (tab === 'custom') {
                        // Load custom range data automatically when switching to custom tab
                        loadPowerSourcesCustomRange();
                    } else {
                        loadPowerSourcesData(tab);
                    }
                }

                async function loadPowerSourcesData(period) {
                    try {
                        // Map period to hours
                        const hoursMap = { 'today': 24, 'yesterday': 48, 'week': 168 };
                        const hours = hoursMap[period] || 24;

                        const response = await fetch(`/api/sfml_stats/power_sources_history?hours=${hours}`);
                        const result = await response.json();

                        if (result.success && result.data) {
                            // Filter data based on period
                            let filteredData = result.data;
                            if (period === 'today') {
                                const todayStart = new Date();
                                todayStart.setHours(0, 0, 0, 0);
                                filteredData = result.data.filter(d => new Date(d.timestamp) >= todayStart);
                            } else if (period === 'yesterday') {
                                const yesterday = new Date();
                                yesterday.setDate(yesterday.getDate() - 1);
                                yesterday.setHours(0, 0, 0, 0);
                                const todayStart = new Date();
                                todayStart.setHours(0, 0, 0, 0);
                                filteredData = result.data.filter(d => {
                                    const dt = new Date(d.timestamp);
                                    return dt >= yesterday && dt < todayStart;
                                });
                            }

                            powerSourcesModal.historicalData = filteredData;
                            calculatePowerSourcesStats(filteredData);
                            updatePowerSourcesCharts(filteredData);
                        }
                    } catch (error) {
                        console.error('Error loading power sources data:', error);
                    }
                }

                function calculatePowerSourcesStats(data) {
                    if (!data || data.length === 0) return;

                    // Calculate actual interval from timestamps
                    let intervalHours = 5 / 60;  // default 5min
                    if (data.length >= 2) {
                        const t0 = new Date(data[0].timestamp).getTime();
                        const tN = new Date(data[data.length - 1].timestamp).getTime();
                        const totalMs = tN - t0;
                        if (totalMs > 0 && data.length > 1) {
                            intervalHours = (totalMs / (data.length - 1)) / 3600000;
                        }
                    }

                    // Data is in Watt (W), we need kWh: sum(W) * intervalHours / 1000
                    let solarToHouseSum = 0, solarToBatterySum = 0, batterySum = 0, gridSum = 0, consumptionSum = 0;

                    data.forEach(d => {
                        solarToHouseSum += (d.solar_to_house || 0);
                        solarToBatterySum += (d.solar_to_battery || 0);
                        batterySum += (d.battery_to_house || 0);
                        gridSum += (d.grid_to_house || 0);
                        consumptionSum += (d.home_consumption || 0);
                    });

                    // Convert W to kWh
                    powerSourcesModal.stats.solarToHouse = (solarToHouseSum * intervalHours) / 1000;
                    powerSourcesModal.stats.solarToBattery = (solarToBatterySum * intervalHours) / 1000;
                    powerSourcesModal.stats.solarTotal = powerSourcesModal.stats.solarToHouse + powerSourcesModal.stats.solarToBattery;
                    powerSourcesModal.stats.batteryTotal = (batterySum * intervalHours) / 1000;
                    powerSourcesModal.stats.gridTotal = (gridSum * intervalHours) / 1000;
                    powerSourcesModal.stats.consumptionTotal = (consumptionSum * intervalHours) / 1000;

                    // Calculate autarky: (Verbrauch - Netzbezug) / Verbrauch = 1 - (Netz / Verbrauch)
                    const totalConsumption = powerSourcesModal.stats.consumptionTotal;
                    const gridToHouse = powerSourcesModal.stats.gridTotal;

                    if (totalConsumption > 0) {
                        powerSourcesModal.stats.autarky = Math.min(100, Math.max(0, (1 - gridToHouse / totalConsumption) * 100));
                    }

                    // Self-consumption: Eigenverbrauch / Solar gesamt
                    const totalSolar = powerSourcesModal.stats.solarTotal;
                    if (totalSolar > 0) {
                        powerSourcesModal.stats.selfConsumption = Math.min(100, ((powerSourcesModal.stats.solarToHouse + powerSourcesModal.stats.solarToBattery) / totalSolar) * 100);
                    }
                }

                function initPowerSourcesCharts() {
                    setTimeout(() => {
                        const mainEl = document.getElementById('power-sources-main-chart');
                        const socEl = document.getElementById('power-sources-soc-chart');
                        const pieEl = document.getElementById('power-sources-pie-chart');

                        if (mainEl && mainEl.offsetWidth > 0) {
                            powerSourcesMainChart.value = echarts.init(mainEl);
                        }
                        if (socEl && socEl.offsetWidth > 0) {
                            powerSourcesSOCChart.value = echarts.init(socEl);
                        }
                        if (pieEl && pieEl.offsetWidth > 0) {
                            powerSourcesPieChart.value = echarts.init(pieEl);
                        }
                    }, 150);
                }

                function updatePowerSourcesCharts(data) {
                    if (!data || data.length === 0) return;

                    // Extract data arrays
                    // Convert W to kW for display (divide by 1000)
                    const timestamps = data.map(d => {
                        const dt = new Date(d.timestamp);
                        return dt.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
                    });
                    const solarToHouse = data.map(d => (d.solar_to_house || 0) / 1000);
                    const solarToBattery = data.map(d => (d.solar_to_battery || 0) / 1000);
                    const battery = data.map(d => (d.battery_to_house || 0) / 1000);
                    const grid = data.map(d => (d.grid_to_house || 0) / 1000);
                    const consumption = data.map(d => (d.home_consumption || 0) / 1000);
                    const soc = data.map(d => d.battery_soc);

                    // Main stacked area chart with DataZoom slider
                    if (powerSourcesMainChart.value) {
                        console.log('Setting Power Sources chart with dataZoom, data points:', timestamps.length);
                        powerSourcesMainChart.value.setOption({
                            tooltip: {
                                trigger: 'axis',
                                axisPointer: { type: 'cross' },
                                backgroundColor: 'rgba(30, 30, 62, 0.95)',
                                borderColor: '#00ffff',
                                textStyle: { color: '#fff' },
                                formatter: function(params) {
                                    let html = `<div style="font-weight:bold;">${params[0].axisValue}</div>`;
                                    params.forEach(p => {
                                        html += `<div style="color:${p.color}">${p.seriesName}: ${p.value?.toFixed(2) || 0} kW</div>`;
                                    });
                                    return html;
                                }
                            },
                            legend: {
                                data: ['Solar ‚Üí Haus', 'Solar ‚Üí Batterie', 'Batterie ‚Üí Haus', 'Netz ‚Üí Haus', 'Verbrauch'],
                                textStyle: { color: '#94a3b8' },
                                top: 10
                            },
                            grid: { left: '3%', right: '4%', top: 60, bottom: '18%', containLabel: true },
                            xAxis: {
                                type: 'category',
                                data: timestamps,
                                axisLine: { lineStyle: { color: '#404040' } },
                                axisLabel: { color: '#94a3b8', rotate: 45 }
                            },
                            yAxis: {
                                type: 'value',
                                name: 'kW',
                                min: 0,
                                max: function(value) {
                                    // Dynamische Skalierung: Max + 10% Puffer, mindestens 0.5 kW
                                    return Math.max(0.5, Math.ceil(value.max * 1.1 * 10) / 10);
                                },
                                axisLine: { lineStyle: { color: '#404040' } },
                                axisLabel: { color: '#94a3b8' },
                                splitLine: { lineStyle: { color: '#303030' } }
                            },
                            dataZoom: [
                                { type: 'slider', start: 0, end: 100, textStyle: { color: '#94a3b8' }, height: 30 },
                                { type: 'inside', start: 0, end: 100 }
                            ],
                            series: [
                                {
                                    name: 'Solar ‚Üí Haus',
                                    type: 'line',
                                    stack: 'sources',
                                    areaStyle: { opacity: 0.8 },
                                    data: solarToHouse,
                                    itemStyle: { color: '#facc15' },
                                    smooth: true,
                                    showSymbol: false
                                },
                                {
                                    name: 'Solar ‚Üí Batterie',
                                    type: 'line',
                                    areaStyle: { opacity: 0.6 },
                                    data: solarToBattery,
                                    itemStyle: { color: '#9ACD32' },
                                    smooth: true,
                                    showSymbol: false
                                },
                                {
                                    name: 'Batterie ‚Üí Haus',
                                    type: 'line',
                                    stack: 'sources',
                                    areaStyle: { opacity: 0.8 },
                                    data: battery,
                                    itemStyle: { color: '#4DD0E1' },
                                    smooth: true,
                                    showSymbol: false
                                },
                                {
                                    name: 'Netz ‚Üí Haus',
                                    type: 'line',
                                    stack: 'sources',
                                    areaStyle: { opacity: 0.8 },
                                    data: grid,
                                    itemStyle: { color: '#90CAF9' },
                                    smooth: true,
                                    showSymbol: false
                                },
                                {
                                    name: 'Verbrauch',
                                    type: 'line',
                                    data: consumption,
                                    itemStyle: { color: '#ffffff' },
                                    lineStyle: { width: 2, type: 'solid' },
                                    smooth: true,
                                    showSymbol: false
                                }
                            ]
                        });
                    }

                    // SOC chart
                    if (powerSourcesSOCChart.value) {
                        powerSourcesSOCChart.value.setOption({
                            tooltip: {
                                trigger: 'axis',
                                backgroundColor: 'rgba(30, 30, 62, 0.95)',
                                borderColor: '#22c55e',
                                textStyle: { color: '#fff' }
                            },
                            grid: { left: 50, right: 20, top: 20, bottom: 60 },
                            xAxis: {
                                type: 'category',
                                data: timestamps,
                                axisLine: { lineStyle: { color: '#404040' } },
                                axisLabel: {
                                    color: '#94a3b8',
                                    rotate: 45,
                                    fontSize: 9,
                                    interval: Math.floor(timestamps.length / 8)
                                }
                            },
                            yAxis: {
                                type: 'value',
                                min: 0,
                                max: 100,
                                axisLine: { lineStyle: { color: '#404040' } },
                                axisLabel: { color: '#94a3b8', formatter: '{value}%' },
                                splitLine: { lineStyle: { color: '#303030' } }
                            },
                            series: [{
                                type: 'line',
                                data: soc,
                                areaStyle: {
                                    color: {
                                        type: 'linear',
                                        x: 0, y: 0, x2: 0, y2: 1,
                                        colorStops: [
                                            { offset: 0, color: 'rgba(34, 197, 94, 0.6)' },
                                            { offset: 1, color: 'rgba(34, 197, 94, 0.1)' }
                                        ]
                                    }
                                },
                                itemStyle: { color: '#22c55e' },
                                lineStyle: { width: 2 },
                                smooth: true,
                                showSymbol: false
                            }]
                        });
                    }

                    // Pie chart
                    if (powerSourcesPieChart.value) {
                        const stats = powerSourcesModal.stats;
                        powerSourcesPieChart.value.setOption({
                            tooltip: {
                                trigger: 'item',
                                backgroundColor: 'rgba(30, 30, 62, 0.95)',
                                borderColor: '#00ffff',
                                textStyle: { color: '#fff' },
                                formatter: '{b}: {c} kWh ({d}%)'
                            },
                            series: [{
                                type: 'pie',
                                radius: ['40%', '70%'],
                                center: ['50%', '50%'],
                                avoidLabelOverlap: true,
                                itemStyle: {
                                    borderRadius: 5,
                                    borderColor: '#1e1e3e',
                                    borderWidth: 2
                                },
                                label: {
                                    show: true,
                                    color: '#94a3b8',
                                    formatter: '{b}\n{d}%'
                                },
                                data: [
                                    { value: Math.round(stats.solarToHouse * 100) / 100, name: 'Solar ‚Üí Haus', itemStyle: { color: '#facc15' } },
                                    { value: Math.round(stats.batteryTotal * 100) / 100, name: 'Batterie ‚Üí Haus', itemStyle: { color: '#4DD0E1' } },
                                    { value: Math.round(stats.gridTotal * 100) / 100, name: 'Netz ‚Üí Haus', itemStyle: { color: '#90CAF9' } }
                                ]
                            }]
                        });
                    }
                }

                async function exportPowerSourcesAnalytics() {
                    try {
                        powerSourcesModal.exporting = true;
                        Toast.info('Export wird vorbereitet...', 'Energiequellen');

                        const exportData = {
                            period: powerSourcesModal.activeTab,
                            stats: powerSourcesModal.stats,
                            data: powerSourcesModal.historicalData
                        };

                        const response = await fetch('/api/sfml_stats/export_power_sources', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(exportData)
                        });

                        if (!response.ok) throw new Error(`Export failed: ${response.statusText}`);

                        const blob = await response.blob();
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `power_sources_${powerSourcesModal.activeTab}_${new Date().toISOString().slice(0, 10)}.png`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(url);
                        Toast.success('Chart wurde exportiert', 'Energiequellen');
                    } catch (error) {
                        console.error('Power sources export error:', error);
                        Toast.error(error.message, 'Export fehlgeschlagen');
                    } finally {
                        powerSourcesModal.exporting = false;
                    }
                }

                async function loadPowerSourcesCustomRange() {
                    try {
                        const startDate = new Date(powerSourcesModal.customStartDate);
                        const endDate = new Date(powerSourcesModal.customEndDate);
                        endDate.setHours(23, 59, 59, 999);  // End of day

                        // Calculate hours between dates
                        const hoursDiff = Math.ceil((endDate - startDate) / (1000 * 60 * 60));
                        const hours = Math.min(168, Math.max(1, hoursDiff));  // Max 7 days

                        console.log(`Loading custom range: ${powerSourcesModal.customStartDate} to ${powerSourcesModal.customEndDate} (${hours} hours)`);

                        const response = await fetch(`/api/sfml_stats/power_sources_history?hours=${hours}`);
                        const result = await response.json();

                        if (result.success && result.data) {
                            // Filter data to match the selected date range
                            const filteredData = result.data.filter(d => {
                                const dt = new Date(d.timestamp);
                                return dt >= startDate && dt <= endDate;
                            });

                            powerSourcesModal.historicalData = filteredData;
                            calculatePowerSourcesStats(filteredData);
                            updatePowerSourcesCharts(filteredData);
                        }
                    } catch (error) {
                        console.error('Error loading custom range:', error);
                    }
                }

                // ===== CONSUMER ANALYTICS MODAL FUNCTIONS =====
                function openConsumerModal() {
                    console.log('Opening Consumer Analytics Modal...');
                    consumerModal.isOpen = true;
                    // Update stats from current energyFlow data
                    if (energyFlow.consumers) {
                        const hp = energyFlow.consumers.heatpump;
                        const hr = energyFlow.consumers.heatingrod;
                        const wb = energyFlow.consumers.wallbox;

                        consumerModal.stats.heatpump = {
                            power: hp?.power || 0,
                            daily_kwh: hp?.daily_kwh || 0,
                            cop: hp?.cop || 3.5,
                            cost_today: 0  // Will be calculated from billing data
                        };
                        consumerModal.stats.heatingrod = {
                            power: hr?.power || 0,
                            daily_kwh: hr?.daily_kwh || 0,
                            cost_today: 0
                        };
                        consumerModal.stats.wallbox = {
                            power: wb?.power || 0,
                            daily_kwh: wb?.daily_kwh || 0,
                            state: wb?.state || 'idle',
                            cost_today: 0
                        };
                        consumerModal.stats.total_daily_kwh =
                            (hp?.daily_kwh || 0) + (hr?.daily_kwh || 0) + (wb?.daily_kwh || 0);
                    }
                    // Fetch billing data for costs
                    fetchConsumerBillingData();
                    setTimeout(() => {
                        initConsumerChart();
                    }, 300);
                }

                function closeConsumerModal() {
                    consumerModal.isOpen = false;
                    if (consumerBarChart.value) consumerBarChart.value.dispose();
                    consumerBarChart.value = null;
                }

                async function fetchConsumerBillingData() {
                    try {
                        const response = await fetch('/api/sfml_stats/billing');
                        if (!response.ok) return;
                        const data = await response.json();
                        if (data.success && data.consumers) {
                            consumerModal.billingData = data.consumers;
                            consumerModal.stats.heatpump.cost_today = data.consumers.heatpump?.cost_eur || 0;
                            consumerModal.stats.heatingrod.cost_today = data.consumers.heatingrod?.cost_eur || 0;
                            consumerModal.stats.wallbox.cost_today = data.consumers.wallbox?.cost_eur || 0;
                            consumerModal.stats.total_cost_today = data.consumers.total_cost_eur || 0;
                        }
                    } catch (error) {
                        console.error('Error fetching consumer billing data:', error);
                    }
                }

                function initConsumerChart() {
                    const chartDom = document.getElementById('consumerBarChart');
                    if (!chartDom) return;

                    if (consumerBarChart.value) consumerBarChart.value.dispose();
                    consumerBarChart.value = echarts.init(chartDom);

                    const hp = consumerModal.stats.heatpump;
                    const hr = consumerModal.stats.heatingrod;
                    const wb = consumerModal.stats.wallbox;

                    const option = {
                        backgroundColor: 'transparent',
                        tooltip: {
                            trigger: 'axis',
                            formatter: '{b}: {c} kWh'
                        },
                        grid: {
                            left: '3%',
                            right: '4%',
                            bottom: '3%',
                            top: '10%',
                            containLabel: true
                        },
                        xAxis: {
                            type: 'category',
                            data: ['W√§rmepumpe', 'Heizstab', 'Wallbox'],
                            axisLabel: { color: '#94a3b8' },
                            axisLine: { lineStyle: { color: '#30363d' } }
                        },
                        yAxis: {
                            type: 'value',
                            name: 'kWh',
                            axisLabel: { color: '#94a3b8' },
                            axisLine: { lineStyle: { color: '#30363d' } },
                            splitLine: { lineStyle: { color: '#30363d', type: 'dashed' } }
                        },
                        series: [{
                            type: 'bar',
                            data: [
                                { value: hp.daily_kwh, itemStyle: { color: '#ff6b6b' } },
                                { value: hr.daily_kwh, itemStyle: { color: '#fbbf24' } },
                                { value: wb.daily_kwh, itemStyle: { color: '#22c55e' } }
                            ],
                            barWidth: '50%',
                            label: {
                                show: true,
                                position: 'top',
                                formatter: '{c} kWh',
                                color: '#f0f6fc'
                            }
                        }]
                    };

                    consumerBarChart.value.setOption(option);
                }

                // ===== WEATHER ANALYTICS MODAL FUNCTIONS =====
                function openWeatherModal() {
                    console.log('Opening Weather Analytics Modal...');
                    weatherModal.isOpen = true;
                    setTimeout(() => {
                        initWeatherCharts();
                        setTimeout(() => {
                            updateWeatherCharts();
                        }, 200);
                    }, 300);
                }

                // ===== CLOTHING RECOMMENDATION MODAL =====
                async function openClothingModal() {
                    console.log('Opening Clothing Recommendation Modal...');
                    clothingModal.isOpen = true;
                    await fetchClothingRecommendation();
                }

                function closeClothingModal() {
                    clothingModal.isOpen = false;
                }

                async function fetchClothingRecommendation() {
                    try {
                        const response = await fetch('/api/sfml_stats/clothing_recommendation');
                        const data = await response.json();

                        if (data.success && data.recommendation) {
                            const rec = data.recommendation;

                            // Update recommendation
                            clothingModal.recommendation.unterbekleidung = rec.unterbekleidung || { name: '', icon: '' };
                            clothingModal.recommendation.oberbekleidung = rec.oberbekleidung || { name: '', icon: '' };
                            clothingModal.recommendation.jacke = rec.jacke || { name: '', icon: '' };
                            clothingModal.recommendation.kopfbedeckung = rec.kopfbedeckung || { name: '', icon: '' };
                            clothingModal.recommendation.zusaetze = rec.zusaetze || [];

                            // Update text based on language preference
                            const lang = navigator.language?.startsWith('en') ? 'en' : 'de';
                            clothingModal.text = lang === 'en' ? rec.text_en : rec.text_de;
                            clothingModal.title = lang === 'en' ? 'Starfleet Uniform Advisory' : 'Au√üenteam-Ausr√ºstungsanalyse';

                            // Update labels based on language
                            if (lang === 'en') {
                                clothingModal.labels = {
                                    temperature: 'Temperature',
                                    feels_like: 'Feels like',
                                    humidity: 'Humidity',
                                    wind: 'Wind',
                                    rain_prob: 'Rain prob.',
                                    pants: 'Pants',
                                    top: 'Top',
                                    jacket: 'Jacket',
                                    headwear: 'Headwear',
                                    accessories: 'Accessories'
                                };
                            } else {
                                clothingModal.labels = {
                                    temperature: 'Temperatur',
                                    feels_like: 'Gef√ºhlt',
                                    humidity: 'Luftfeuchtigkeit',
                                    wind: 'Wind',
                                    rain_prob: 'Regenwahrsch.',
                                    pants: 'Hose',
                                    top: 'Oberteil',
                                    jacket: 'Jacke',
                                    headwear: 'Kopfbedeckung',
                                    accessories: 'Zubeh√∂r'
                                };
                            }

                            // Update weather data
                            if (data.weather) {
                                clothingModal.weather.temperature = data.weather.temperature;
                                clothingModal.weather.feels_like = data.weather.feels_like;
                                clothingModal.weather.humidity = data.weather.humidity;
                                clothingModal.weather.wind_speed = data.weather.wind_speed;
                                clothingModal.weather.rain_probability = data.weather.rain_probability;
                                clothingModal.weather.uv_index = data.weather.uv_index;
                            }

                            console.log('Clothing recommendation loaded:', rec);
                        } else {
                            console.error('Failed to load clothing recommendation:', data.error);
                            clothingModal.text = 'Kleidungsempfehlung konnte nicht geladen werden.';
                        }
                    } catch (error) {
                        console.error('Error fetching clothing recommendation:', error);
                        clothingModal.text = 'Fehler beim Laden der Kleidungsempfehlung.';
                    }
                }

                // ===== PANEL GROUP MODAL =====
                function openPanelGroupModal(groupName) {
                    const groupData = panelGroups.groups[groupName];
                    if (!groupData) return;

                    panelGroupModal.groupName = groupName;
                    panelGroupModal.groupData = groupData;
                    panelGroupModal.isOpen = true;
                }

                function closePanelGroupModal() {
                    panelGroupModal.isOpen = false;
                    panelGroupModal.groupName = '';
                    panelGroupModal.groupData = null;
                }

                function getPanelGroupDeviation() {
                    if (!panelGroupModal.groupData) return 0;
                    const actual = panelGroupModal.groupData.actual_total_kwh || 0;
                    const prediction = panelGroupModal.groupData.prediction_total_kwh || 0;
                    if (prediction === 0) return 0;
                    return ((actual - prediction) / prediction) * 100;
                }

                function getPanelGroupHourlyData() {
                    if (!panelGroupModal.groupData || !panelGroupModal.groupData.hourly) return [];

                    return panelGroupModal.groupData.hourly
                        .sort((a, b) => a.hour - b.hour)
                        .map(h => {
                            const actual = h.actual_kwh || 0;
                            const prediction = h.prediction_kwh || 0;
                            let deviation = 0;
                            if (prediction > 0) {
                                deviation = ((actual - prediction) / prediction) * 100;
                            }
                            return {
                                hour: h.hour,
                                actual: actual,
                                prediction: prediction,
                                deviation: deviation
                            };
                        });
                }

                // ===== PRODUCTION TODAY MODAL =====
                function openProductionTodayModal() {
                    productionTodayModal.isOpen = true;
                }

                function closeProductionTodayModal() {
                    productionTodayModal.isOpen = false;
                }

                function getProductionTodayDeviation() {
                    const actual = energyFlow.statistics.solar_yield_daily || 0;
                    const prediction = forecast.todayTotal || 0;
                    if (prediction === 0) return 0;
                    return ((actual - prediction) / prediction) * 100;
                }

                function getProductionTodayHourlyData() {
                    // Hole die st√ºndlichen Daten aus forecast.todayHours
                    if (!forecast.todayHours || forecast.todayHours.length === 0) return [];

                    const now = new Date();
                    const todayStr = now.getFullYear() + '-' +
                        String(now.getMonth() + 1).padStart(2, '0') + '-' +
                        String(now.getDate()).padStart(2, '0');

                    // Hole IST-Werte aus den hourly forecasts (die haben actual_kwh)
                    return forecast.todayHours
                        .sort((a, b) => a.hour - b.hour)
                        .map(h => {
                            const actual = h.actual || 0;
                            const prediction = h.kwh || 0;
                            let deviation = 0;
                            let accuracy = 0;
                            if (prediction > 0) {
                                deviation = ((actual - prediction) / prediction) * 100;
                                const absDeviation = Math.abs(deviation);
                                accuracy = Math.max(0, 100 - absDeviation);
                            }
                            return {
                                hour: h.hour,
                                actual: actual,
                                prediction: prediction,
                                deviation: deviation,
                                accuracy: accuracy
                            };
                        });
                }

                function closeWeatherModal() {
                    weatherModal.isOpen = false;
                    if (weatherTempChart.value) weatherTempChart.value.dispose();
                    if (weatherRadiationChart.value) weatherRadiationChart.value.dispose();
                    if (weatherRainChart.value) weatherRainChart.value.dispose();
                    if (weatherWindChart.value) weatherWindChart.value.dispose();
                    if (weatherTempComparisonChart.value) weatherTempComparisonChart.value.dispose();
                    if (weatherRadiationComparisonChart.value) weatherRadiationComparisonChart.value.dispose();
                    if (weatherCloudsComparisonChart.value) weatherCloudsComparisonChart.value.dispose();
                    if (weatherAccuracyChart.value) weatherAccuracyChart.value.dispose();
                    weatherTempChart.value = null;
                    weatherRadiationChart.value = null;
                    weatherRainChart.value = null;
                    weatherWindChart.value = null;
                    weatherTempComparisonChart.value = null;
                    weatherRadiationComparisonChart.value = null;
                    weatherCloudsComparisonChart.value = null;
                    weatherAccuracyChart.value = null;
                }

                // ===== FORECAST COMPARISON MODAL =====
                async function openForecastComparisonModal() {
                    console.log('Opening Forecast Comparison Modal...');
                    forecastComparisonModal.isOpen = true;

                    setTimeout(async () => {
                        // Initialize chart
                        const chartEl = document.getElementById('forecast-comparison-chart');
                        if (chartEl && chartEl.offsetWidth > 0) {
                            forecastComparisonChart.value = echarts.init(chartEl);
                        }

                        // Fetch data
                        try {
                            const response = await fetch('/api/sfml_stats/forecast_comparison');
                            const result = await response.json();
                            console.log('Forecast comparison API response:', result);

                            if (result.success && result.data) {
                                const data = result.data;
                                console.log('Actual data:', data.actual);
                                console.log('SFML data:', data.sfml);
                                forecastComparisonModal.chartData = data;

                                // Update stats
                                forecastComparisonModal.stats.daysWithActual = data.stats?.days_with_actual || 0;
                                forecastComparisonModal.stats.sfmlAccuracy = data.stats?.sfml_avg_accuracy;
                                forecastComparisonModal.stats.ext1Accuracy = data.stats?.external_1_avg_accuracy;
                                forecastComparisonModal.stats.ext2Accuracy = data.stats?.external_2_avg_accuracy;
                                forecastComparisonModal.stats.ext1Name = data.external_1_name;
                                forecastComparisonModal.stats.ext2Name = data.external_2_name;
                                forecastComparisonModal.stats.bestForecast = data.stats?.best_forecast;

                                // Calculate total actual
                                const totalActual = data.actual?.filter(v => v !== null).reduce((sum, v) => sum + v, 0) || 0;
                                forecastComparisonModal.stats.totalActual = totalActual;

                                // Render chart
                                renderForecastComparisonChart(data);
                            }
                        } catch (error) {
                            console.error('Error fetching forecast comparison data:', error);
                            Toast.error('Fehler beim Laden der Daten', 'Prognose-Vergleich');
                        }
                    }, 300);
                }

                function closeForecastComparisonModal() {
                    forecastComparisonModal.isOpen = false;
                    if (forecastComparisonChart.value) {
                        forecastComparisonChart.value.dispose();
                        forecastComparisonChart.value = null;
                    }
                }

                function renderForecastComparisonChart(data) {
                    // Try to initialize chart if not yet done
                    if (!forecastComparisonChart.value) {
                        const chartEl = document.getElementById('forecast-comparison-chart');
                        if (chartEl && chartEl.offsetWidth > 0) {
                            forecastComparisonChart.value = echarts.init(chartEl);
                        } else {
                            console.warn('Chart element not ready, retrying in 200ms');
                            setTimeout(() => renderForecastComparisonChart(data), 200);
                            return;
                        }
                    }

                    const series = [];

                    // Actual production (green solid line with markers)
                    series.push({
                        name: 'Tats√§chlich',
                        type: 'line',
                        data: data.actual,
                        lineStyle: { color: '#10b981', width: 3 },
                        itemStyle: { color: '#10b981' },
                        symbol: 'circle',
                        symbolSize: 8,
                        connectNulls: false
                    });

                    // SFML forecast (purple dashed line)
                    series.push({
                        name: 'SFML',
                        type: 'line',
                        data: data.sfml,
                        lineStyle: { color: '#a855f7', width: 2, type: 'dashed' },
                        itemStyle: { color: '#a855f7' },
                        symbol: 'square',
                        symbolSize: 6,
                        connectNulls: false
                    });

                    // External forecast 1 (cyan dotted)
                    if (data.external_1 && data.external_1.some(v => v !== null)) {
                        series.push({
                            name: data.external_1_name || 'Extern 1',
                            type: 'line',
                            data: data.external_1,
                            lineStyle: { color: '#00d4ff', width: 2, type: 'dotted' },
                            itemStyle: { color: '#00d4ff' },
                            symbol: 'triangle',
                            symbolSize: 6,
                            connectNulls: false
                        });
                    }

                    // External forecast 2 (orange dash-dot)
                    if (data.external_2 && data.external_2.some(v => v !== null)) {
                        series.push({
                            name: data.external_2_name || 'Extern 2',
                            type: 'line',
                            data: data.external_2,
                            lineStyle: { color: '#ff9500', width: 2, type: [5, 3, 1, 3] },
                            itemStyle: { color: '#ff9500' },
                            symbol: 'diamond',
                            symbolSize: 6,
                            connectNulls: false
                        });
                    }

                    const option = {
                        backgroundColor: 'transparent',
                        grid: {
                            left: '10%',
                            right: '5%',
                            top: '15%',
                            bottom: '15%'
                        },
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: 'rgba(30, 30, 62, 0.95)',
                            borderColor: '#a855f7',
                            textStyle: { color: '#fff' },
                            formatter: function(params) {
                                let html = `<div style="font-weight: 600; margin-bottom: 8px;">${params[0].axisValue}</div>`;
                                params.forEach(p => {
                                    if (p.value !== null && p.value !== undefined) {
                                        html += `<div style="display: flex; justify-content: space-between; gap: 16px;">
                                            <span style="color: ${p.color};">${p.seriesName}</span>
                                            <span style="font-weight: 600;">${p.value.toFixed(2)} kWh</span>
                                        </div>`;
                                    }
                                });
                                return html;
                            }
                        },
                        xAxis: {
                            type: 'category',
                            data: data.dates,
                            axisLine: { lineStyle: { color: '#4a5568' } },
                            axisLabel: { color: '#a0aec0', fontSize: 12 }
                        },
                        yAxis: {
                            type: 'value',
                            name: 'kWh',
                            nameTextStyle: { color: '#a0aec0' },
                            axisLine: { show: false },
                            axisLabel: { color: '#a0aec0' },
                            splitLine: { lineStyle: { color: 'rgba(255,255,255,0.1)' } }
                        },
                        series: series
                    };

                    forecastComparisonChart.value.setOption(option);
                }

                // ===== SHADOW ANALYTICS =====
                const SHADOW_CAUSE_LABELS = {
                    'building_tree_obstruction': 'Geb√§ude/Baum',
                    'low_sun_angle': 'Tiefer Sonnenstand',
                    'panel_frost_snow': 'Schnee/Frost',
                    'weather_clouds': 'Wolken',
                    'weather_better_than_forecast': 'Besser als Prognose',
                    'night': 'Nacht',
                    'unknown': 'Unbekannt'
                };

                async function openShadowAnalyticsModal() {
                    shadowModal.isOpen = true;

                    setTimeout(async () => {
                        // Init charts
                        const heatEl = document.getElementById('shadow-heatmap-chart');
                        const causeEl = document.getElementById('shadow-causes-chart');
                        const lossEl = document.getElementById('shadow-daily-loss-chart');
                        if (heatEl && heatEl.offsetWidth > 0) shadowCharts.heatmap = echarts.init(heatEl);
                        if (causeEl && causeEl.offsetWidth > 0) shadowCharts.causes = echarts.init(causeEl);
                        if (lossEl && lossEl.offsetWidth > 0) shadowCharts.dailyLoss = echarts.init(lossEl);

                        try {
                            const response = await fetch('/api/sfml_stats/shadow_analytics?days=60');
                            const result = await response.json();
                            console.log('Shadow analytics response:', result);
                            if (result.success && result.data) {
                                const d = result.data;
                                shadowModal.data = d;

                                // Stats
                                shadowModal.stats.totalLoss = d.stats.total_loss_kwh;
                                shadowModal.stats.shadowHours = d.stats.shadow_hours;
                                shadowModal.stats.avgEfficiency = d.stats.avg_efficiency;
                                shadowModal.stats.daysWithShadow = d.stats.days_with_shadow;
                                shadowModal.stats.daysAnalyzed = d.stats.days_analyzed;
                                shadowModal.stats.daysLearned = d.learning?.days_learned || 0;
                                shadowModal.stats.dominantCauseLabel = SHADOW_CAUSE_LABELS[d.stats.dominant_cause] || d.stats.dominant_cause || '‚Äî';

                                renderShadowHeatmap(d.heatmap);
                                renderShadowCauses(d.causes);
                                renderShadowDailyLoss(d.daily_loss);
                            }
                        } catch (err) {
                            console.error('Shadow analytics error:', err);
                        }
                    }, 300);
                }

                function closeShadowAnalyticsModal() {
                    shadowModal.isOpen = false;
                    Object.values(shadowCharts).forEach(c => { if (c) c.dispose(); });
                    shadowCharts.heatmap = null;
                    shadowCharts.causes = null;
                    shadowCharts.dailyLoss = null;
                }

                function renderShadowHeatmap(heatmap) {
                    if (!shadowCharts.heatmap) return;

                    const dates = Object.keys(heatmap).sort();
                    const hours = [];
                    for (let h = 7; h <= 18; h++) hours.push(h);

                    const data = [];
                    let maxPct = 0;
                    dates.forEach((d, yi) => {
                        hours.forEach((h, xi) => {
                            const val = heatmap[d]?.[h];
                            const pct = val ? val.pct : null;
                            if (pct !== null) {
                                data.push([xi, yi, pct]);
                                if (pct > maxPct) maxPct = pct;
                            }
                        });
                    });

                    shadowCharts.heatmap.setOption({
                        backgroundColor: 'transparent',
                        tooltip: {
                            position: 'top',
                            backgroundColor: 'rgba(30,30,62,0.95)',
                            borderColor: '#8b8ba0',
                            textStyle: { color: '#fff' },
                            formatter: function(p) {
                                const d = dates[p.value[1]];
                                const h = hours[p.value[0]];
                                const info = heatmap[d]?.[h];
                                if (!info) return '';
                                const cause = SHADOW_CAUSE_LABELS[info.cause] || info.cause;
                                return `<div style="font-weight:600">${d.slice(5).replace('-','.')} ${h}:00</div>
                                    <div>Schatten: <b>${info.pct}%</b> (${info.type})</div>
                                    <div>Ursache: ${cause}</div>
                                    <div>Effizienz: ${(info.eff * 100).toFixed(0)}%</div>
                                    <div>Verlust: ${(info.loss * 1000).toFixed(0)} Wh</div>`;
                            }
                        },
                        grid: { left: 70, right: 20, top: 10, bottom: 40 },
                        xAxis: {
                            type: 'category',
                            data: hours.map(h => h + ':00'),
                            splitArea: { show: true, areaStyle: { color: ['rgba(255,255,255,0.02)', 'transparent'] } },
                            axisLabel: { color: '#94a3b8', fontSize: 11 }
                        },
                        yAxis: {
                            type: 'category',
                            data: dates.map(d => d.slice(5).replace('-', '.')),
                            axisLabel: { color: '#94a3b8', fontSize: 10 }
                        },
                        visualMap: {
                            min: 0,
                            max: 100,
                            calculable: true,
                            orient: 'horizontal',
                            left: 'center',
                            bottom: 0,
                            itemWidth: 12,
                            itemHeight: 120,
                            textStyle: { color: '#94a3b8' },
                            inRange: {
                                color: ['#10b981', '#86efac', '#fde047', '#fb923c', '#ef4444', '#991b1b']
                            },
                            formatter: function(val) { return Math.round(val) + '%'; }
                        },
                        series: [{
                            type: 'heatmap',
                            data: data,
                            label: { show: false },
                            emphasis: {
                                itemStyle: { shadowBlur: 10, shadowColor: 'rgba(0,0,0,0.5)' }
                            }
                        }]
                    });
                }

                function renderShadowCauses(causes) {
                    if (!shadowCharts.causes) return;

                    const colors = {
                        'building_tree_obstruction': '#ef4444',
                        'low_sun_angle': '#f59e0b',
                        'panel_frost_snow': '#38bdf8',
                        'weather_clouds': '#94a3b8',
                        'weather_better_than_forecast': '#10b981',
                        'unknown': '#64748b'
                    };

                    const pieData = Object.entries(causes)
                        .filter(([k]) => k !== 'night')
                        .map(([k, v]) => ({
                            name: SHADOW_CAUSE_LABELS[k] || k,
                            value: v,
                            itemStyle: { color: colors[k] || '#64748b' }
                        }))
                        .sort((a, b) => b.value - a.value);

                    shadowCharts.causes.setOption({
                        backgroundColor: 'transparent',
                        tooltip: {
                            backgroundColor: 'rgba(30,30,62,0.95)',
                            borderColor: '#8b8ba0',
                            textStyle: { color: '#fff' },
                            formatter: function(p) {
                                return `${p.marker} ${p.name}: <b>${p.value}</b> Stunden (${p.percent}%)`;
                            }
                        },
                        series: [{
                            type: 'pie',
                            radius: ['40%', '70%'],
                            center: ['50%', '50%'],
                            avoidLabelOverlap: true,
                            itemStyle: { borderRadius: 6, borderColor: '#1a1a2e', borderWidth: 2 },
                            label: {
                                color: '#e2e8f0',
                                fontSize: 11,
                                formatter: '{b}\n{d}%'
                            },
                            emphasis: {
                                label: { fontSize: 13, fontWeight: 'bold' }
                            },
                            data: pieData
                        }]
                    });
                }

                function renderShadowDailyLoss(dailyLoss) {
                    if (!shadowCharts.dailyLoss) return;

                    const filtered = dailyLoss.filter(d => d.loss_kwh > 0 || d.hours > 0);
                    if (filtered.length === 0) {
                        shadowCharts.dailyLoss.setOption({
                            backgroundColor: 'transparent',
                            title: { text: 'Keine Verlustdaten', left: 'center', top: 'center', textStyle: { color: '#64748b', fontSize: 14 } }
                        });
                        return;
                    }

                    shadowCharts.dailyLoss.setOption({
                        backgroundColor: 'transparent',
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: 'rgba(30,30,62,0.95)',
                            borderColor: '#ef4444',
                            textStyle: { color: '#fff' },
                            formatter: function(params) {
                                const d = filtered[params[0].dataIndex];
                                return `<div style="font-weight:600">${d.date.slice(5).replace('-','.')}</div>
                                    <div>Verlust: <b>${d.loss_kwh.toFixed(2)} kWh</b></div>
                                    <div>Schatten-Stunden: ${d.hours}</div>`;
                            }
                        },
                        grid: { left: 50, right: 15, top: 10, bottom: 30 },
                        xAxis: {
                            type: 'category',
                            data: filtered.map(d => d.date.slice(5).replace('-', '.')),
                            axisLabel: { color: '#94a3b8', fontSize: 10, rotate: 45 },
                            axisLine: { lineStyle: { color: '#4a5568' } }
                        },
                        yAxis: {
                            type: 'value',
                            name: 'kWh',
                            nameTextStyle: { color: '#94a3b8', fontSize: 10 },
                            axisLabel: { color: '#94a3b8', fontSize: 10 },
                            splitLine: { lineStyle: { color: 'rgba(255,255,255,0.06)' } }
                        },
                        series: [{
                            type: 'bar',
                            data: filtered.map(d => d.loss_kwh),
                            itemStyle: {
                                color: {
                                    type: 'linear', x: 0, y: 0, x2: 0, y2: 1,
                                    colorStops: [
                                        { offset: 0, color: '#ef4444' },
                                        { offset: 1, color: '#991b1b' }
                                    ]
                                },
                                borderRadius: [4, 4, 0, 0]
                            },
                            barMaxWidth: 30
                        }]
                    });
                }

                async function exportWeatherAnalytics() {
                    try {
                        weatherModal.exporting = true;
                        Toast.info('Export wird vorbereitet...', 'Wetter Analytics');

                        // For comparison tab, default to week for export
                        const period = weatherModal.activeTab === 'comparison' ? 'week' : weatherModal.activeTab;

                        const exportData = {
                            period: period,
                            stats: weatherModal.stats,
                            data: weatherModal.historicalData
                        };
                        const response = await fetch('/api/sfml_stats/export_weather_analytics', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(exportData)
                        });
                        if (!response.ok) throw new Error(`Export failed: ${response.statusText}`);
                        const blob = await response.blob();
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `weather_analytics_${period}_${new Date().toISOString().slice(0, 10)}.png`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(url);
                        Toast.success('Chart wurde exportiert', 'Wetter Analytics');
                    } catch (error) {
                        console.error('Weather export error:', error);
                        Toast.error(error.message, 'Export fehlgeschlagen');
                    } finally {
                        weatherModal.exporting = false;
                    }
                }

                function initWeatherCharts() {
                    setTimeout(() => {
                        // Historical charts
                        const tempEl = document.getElementById('weather-temp-chart');
                        const radiationEl = document.getElementById('weather-radiation-chart');
                        const rainEl = document.getElementById('weather-rain-chart');
                        const windEl = document.getElementById('weather-wind-chart');
                        if (tempEl && tempEl.offsetWidth > 0) weatherTempChart.value = echarts.init(tempEl);
                        if (radiationEl && radiationEl.offsetWidth > 0) weatherRadiationChart.value = echarts.init(radiationEl);
                        if (rainEl && rainEl.offsetWidth > 0) weatherRainChart.value = echarts.init(rainEl);
                        if (windEl && windEl.offsetWidth > 0) weatherWindChart.value = echarts.init(windEl);

                        // IST vs KI Comparison charts - only initialize if comparison tab is active
                        if (weatherModal.activeTab === 'comparison') {
                            initWeatherComparisonCharts();
                        }
                    }, 150);
                }

                function initWeatherComparisonCharts() {
                    setTimeout(() => {
                        const tempCompEl = document.getElementById('weather-temp-comparison-chart');
                        const radCompEl = document.getElementById('weather-radiation-comparison-chart');
                        const cloudsCompEl = document.getElementById('weather-clouds-comparison-chart');
                        const accuracyEl = document.getElementById('weather-accuracy-chart');

                        if (tempCompEl && tempCompEl.offsetWidth > 0 && !weatherTempComparisonChart.value) {
                            weatherTempComparisonChart.value = echarts.init(tempCompEl);
                        }
                        if (radCompEl && radCompEl.offsetWidth > 0 && !weatherRadiationComparisonChart.value) {
                            weatherRadiationComparisonChart.value = echarts.init(radCompEl);
                        }
                        if (cloudsCompEl && cloudsCompEl.offsetWidth > 0 && !weatherCloudsComparisonChart.value) {
                            weatherCloudsComparisonChart.value = echarts.init(cloudsCompEl);
                        }
                        if (accuracyEl && accuracyEl.offsetWidth > 0 && !weatherAccuracyChart.value) {
                            weatherAccuracyChart.value = echarts.init(accuracyEl);
                        }
                    }, 150);
                }

                async function updateWeatherCharts() {
                    try {
                        const response = await fetch('/api/sfml_stats/weather_history');
                        const result = await response.json();

                        if (!result.success || !result.data || result.data.length === 0) {
                            // Fallback: Generate mock data if API not ready or no data
                            console.log('No weather data available, generating mock data');
                            generateMockWeatherData();
                            return;
                        }

                        weatherModal.historicalData = result.data;
                        weatherModal.stats = result.stats || {};
                        renderWeatherCharts();
                    } catch (error) {
                        console.error('Error fetching weather data:', error);
                        generateMockWeatherData();
                    }
                }

                function generateMockWeatherData() {
                    // For comparison tab, generate week data
                    const activeTab = weatherModal.activeTab === 'comparison' ? 'week' : weatherModal.activeTab;
                    const days = activeTab === 'week' ? 7 : activeTab === 'month' ? 30 : 365;
                    const history = [];
                    const now = new Date();

                    for (let i = days - 1; i >= 0; i--) {
                        const date = new Date(now);
                        date.setDate(date.getDate() - i);
                        const temp = 15 + Math.sin(i / 30) * 10 + Math.random() * 5; // Seasonal variation
                        history.push({
                            date: date.toISOString().slice(0, 10),
                            temp_avg: temp,
                            temp_max: temp + 5 + Math.random() * 3,
                            temp_min: temp - 5 - Math.random() * 3,
                            radiation: Math.max(0, 300 + Math.sin(i / 10) * 200 + Math.random() * 100),
                            rain: Math.random() < 0.3 ? Math.random() * 15 : 0, // 30% chance of rain
                            humidity: 50 + Math.random() * 40,
                            wind: 2 + Math.random() * 8,
                            solar_kwh: 8 + Math.random() * 12 // For correlation
                        });
                    }

                    weatherModal.historicalData = history;

                    // Calculate stats
                    const weekData = history.slice(-7);
                    const monthData = history.slice(-30);
                    weatherModal.stats.avgTemp = weekData.reduce((sum, d) => sum + d.temp_avg, 0) / weekData.length;
                    weatherModal.stats.maxTemp = Math.max(...history.map(d => d.temp_max));
                    weatherModal.stats.minTemp = Math.min(...history.map(d => d.temp_min));
                    weatherModal.stats.totalRain = monthData.reduce((sum, d) => sum + d.rain, 0);
                    weatherModal.stats.avgWind = history.reduce((sum, d) => sum + d.wind, 0) / history.length;
                    weatherModal.stats.sunHours = monthData.reduce((sum, d) => sum + (d.sun_hours || 0), 0);

                    renderWeatherCharts();
                }

                async function renderWeatherCharts() {
                    // Check if we're on the comparison tab
                    if (weatherModal.activeTab === 'comparison') {
                        await renderWeatherComparisonCharts();
                        return;
                    }

                    const allData = weatherModal.historicalData || [];
                    if (!allData.length) return;

                    // Filter data based on active tab
                    const daysToShow = weatherModal.activeTab === 'week' ? 7 :
                                       weatherModal.activeTab === 'month' ? 30 : 365;
                    const data = allData.slice(-daysToShow);

                    const dates = data.map(d => d.date.slice(5));

                    // Temperature Chart
                    if (weatherTempChart.value) {
                        weatherTempChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#f59e0b', textStyle: { color: '#fff' } },
                            legend: { data: ['Durchschnitt', 'Maximum', 'Minimum'], textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: { type: 'value', name: '¬∞C', nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                            series: [
                                { name: 'Durchschnitt', type: 'line', data: data.map(d => d.temp_avg), smooth: true, itemStyle: { color: '#f59e0b' }, lineStyle: { width: 2 } },
                                { name: 'Maximum', type: 'line', data: data.map(d => d.temp_max), smooth: true, itemStyle: { color: '#ef4444' }, lineStyle: { width: 1, type: 'dashed' } },
                                { name: 'Minimum', type: 'line', data: data.map(d => d.temp_min), smooth: true, itemStyle: { color: '#3b82f6' }, lineStyle: { width: 1, type: 'dashed' } }
                            ],
                            grid: { left: 60, right: 30, top: 60, bottom: 50 }
                        });
                    }

                    // Radiation & Solar Correlation Chart
                    if (weatherRadiationChart.value) {
                        weatherRadiationChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#f59e0b', textStyle: { color: '#fff' } },
                            legend: { data: ['Einstrahlung (W/m¬≤)', 'Solar (kWh)'], textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: [
                                { type: 'value', name: 'W/m¬≤', nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                                { type: 'value', name: 'kWh', nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { show: false } }
                            ],
                            series: [
                                { name: 'Einstrahlung (W/m¬≤)', type: 'bar', data: data.map(d => d.radiation), itemStyle: { color: '#fbbf24' } },
                                { name: 'Solar (kWh)', type: 'line', yAxisIndex: 1, data: data.map(d => d.solar_kwh), smooth: true, itemStyle: { color: '#22c55e' }, lineStyle: { width: 2 } }
                            ],
                            grid: { left: 60, right: 60, top: 60, bottom: 50 }
                        });
                    }

                    // Rain & Humidity Chart
                    if (weatherRainChart.value) {
                        weatherRainChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#f59e0b', textStyle: { color: '#fff' } },
                            legend: { data: ['Niederschlag (mm)', 'Luftfeuchtigkeit (%)'], textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: [
                                { type: 'value', name: 'mm', nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                                { type: 'value', name: '%', min: 0, max: 100, nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { show: false } }
                            ],
                            series: [
                                { name: 'Niederschlag (mm)', type: 'bar', data: data.map(d => d.rain), itemStyle: { color: '#3b82f6' } },
                                { name: 'Luftfeuchtigkeit (%)', type: 'line', yAxisIndex: 1, data: data.map(d => d.humidity), smooth: true, itemStyle: { color: '#06b6d4' }, lineStyle: { width: 2 } }
                            ],
                            grid: { left: 60, right: 60, top: 60, bottom: 50 }
                        });
                    }

                    // Wind Chart
                    if (weatherWindChart.value) {
                        weatherWindChart.value.setOption({
                            tooltip: { trigger: 'axis', backgroundColor: 'rgba(30, 30, 62, 0.95)', borderColor: '#f59e0b', textStyle: { color: '#fff' } },
                            xAxis: { type: 'category', data: dates, axisLabel: { color: '#888', rotate: data.length > 20 ? 45 : 0 }, axisLine: { lineStyle: { color: '#444' } } },
                            yAxis: { type: 'value', name: 'm/s', nameTextStyle: { color: '#fff' }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#333' } } },
                            series: [{
                                name: 'Wind Geschwindigkeit',
                                type: 'line',
                                data: data.map(d => d.wind),
                                smooth: true,
                                itemStyle: { color: '#a855f7' },
                                lineStyle: { width: 2 },
                                areaStyle: { color: 'rgba(168, 85, 247, 0.2)' }
                            }],
                            grid: { left: 60, right: 30, top: 40, bottom: 50 }
                        });
                    }
                }

                async function renderWeatherComparisonCharts() {
                    // Load real IST vs KI comparison data from API
                    let comparisonData = [];
                    let comparisonStats = {};

                    try {
                        const response = await fetch('/api/sfml_stats/weather_comparison?days=7');
                        const result = await response.json();

                        if (result.success && result.data && result.data.length > 0) {
                            comparisonData = result.data;
                            comparisonStats = result.stats || {};
                            console.log('Weather comparison data loaded:', comparisonData.length, 'days');
                        } else {
                            console.warn('No weather comparison data available:', result.error || 'empty data');
                            return; // Don't render charts with no data
                        }
                    } catch (error) {
                        console.error('Error fetching weather comparison data:', error);
                        return; // Don't render charts on error
                    }

                    // Extract data arrays from comparison data
                    const dates = comparisonData.map(d => d.date.slice(5)); // MM-DD format
                    const tempIST = comparisonData.map(d => d.temp_ist);
                    const tempKI = comparisonData.map(d => d.temp_ki);
                    const radiationIST = comparisonData.map(d => d.radiation_ist);
                    const radiationKI = comparisonData.map(d => d.radiation_ki);
                    const cloudsIST = comparisonData.map(d => d.clouds_ist);
                    const cloudsKI = comparisonData.map(d => d.clouds_ki);

                    // Calculate per-day accuracy
                    const accuracy = comparisonData.map(d => {
                        if (d.temp_ki === 0 && d.radiation_ki === 0) return 0;
                        const tempError = Math.abs(d.temp_ist - d.temp_ki);
                        const radError = d.radiation_ki > 0 ? Math.abs(d.radiation_ist - d.radiation_ki) / 5 : 0;
                        const tempAcc = Math.max(0, 100 - tempError * 10);
                        const radAcc = Math.max(0, 100 - radError);
                        return (tempAcc + radAcc) / 2;
                    });

                    // Temperature IST vs KI Chart
                    if (weatherTempComparisonChart.value) {
                        weatherTempComparisonChart.value.setOption({
                            tooltip: {
                                trigger: 'axis',
                                backgroundColor: 'rgba(30, 30, 62, 0.95)',
                                borderColor: '#8b5cf6',
                                textStyle: { color: '#fff' }
                            },
                            legend: {
                                data: ['IST Temperatur', 'KI Vorhersage'],
                                textStyle: { color: '#fff' },
                                top: 10
                            },
                            xAxis: {
                                type: 'category',
                                data: dates,
                                axisLabel: { color: '#888', rotate: 45 },
                                axisLine: { lineStyle: { color: '#444' } }
                            },
                            yAxis: {
                                type: 'value',
                                name: 'Temperatur (¬∞C)',
                                nameTextStyle: { color: '#fff' },
                                axisLabel: { color: '#888' },
                                splitLine: { lineStyle: { color: '#333' } }
                            },
                            series: [
                                {
                                    name: 'IST Temperatur',
                                    type: 'line',
                                    data: tempIST,
                                    smooth: true,
                                    itemStyle: { color: '#22c55e' },
                                    lineStyle: { width: 3 },
                                    symbol: 'circle',
                                    symbolSize: 8
                                },
                                {
                                    name: 'KI Vorhersage',
                                    type: 'line',
                                    data: tempKI,
                                    smooth: true,
                                    itemStyle: { color: '#8b5cf6' },
                                    lineStyle: { width: 3, type: 'dashed' },
                                    symbol: 'diamond',
                                    symbolSize: 8
                                }
                            ],
                            grid: { left: 70, right: 30, top: 60, bottom: 70 }
                        });
                    }

                    // Radiation IST vs KI Chart
                    if (weatherRadiationComparisonChart.value) {
                        weatherRadiationComparisonChart.value.setOption({
                            tooltip: {
                                trigger: 'axis',
                                backgroundColor: 'rgba(30, 30, 62, 0.95)',
                                borderColor: '#8b5cf6',
                                textStyle: { color: '#fff' }
                            },
                            legend: {
                                data: ['IST Strahlung', 'KI Vorhersage'],
                                textStyle: { color: '#fff' },
                                top: 10
                            },
                            xAxis: {
                                type: 'category',
                                data: dates,
                                axisLabel: { color: '#888', rotate: 45 },
                                axisLine: { lineStyle: { color: '#444' } }
                            },
                            yAxis: {
                                type: 'value',
                                name: 'Strahlung (W/m¬≤)',
                                nameTextStyle: { color: '#fff' },
                                axisLabel: { color: '#888' },
                                splitLine: { lineStyle: { color: '#333' } }
                            },
                            series: [
                                {
                                    name: 'IST Strahlung',
                                    type: 'bar',
                                    data: radiationIST,
                                    itemStyle: { color: '#fbbf24' },
                                    barWidth: '40%'
                                },
                                {
                                    name: 'KI Vorhersage',
                                    type: 'bar',
                                    data: radiationKI,
                                    itemStyle: { color: '#8b5cf6', opacity: 0.7 },
                                    barWidth: '40%'
                                }
                            ],
                            grid: { left: 70, right: 30, top: 60, bottom: 70 }
                        });
                    }

                    // Clouds IST vs KI Chart
                    if (weatherCloudsComparisonChart.value) {
                        weatherCloudsComparisonChart.value.setOption({
                            tooltip: {
                                trigger: 'axis',
                                backgroundColor: 'rgba(30, 30, 62, 0.95)',
                                borderColor: '#8b5cf6',
                                textStyle: { color: '#fff' }
                            },
                            legend: {
                                data: ['IST Wolken', 'KI Vorhersage'],
                                textStyle: { color: '#fff' },
                                top: 10
                            },
                            xAxis: {
                                type: 'category',
                                data: dates,
                                axisLabel: { color: '#888', rotate: 45 },
                                axisLine: { lineStyle: { color: '#444' } }
                            },
                            yAxis: {
                                type: 'value',
                                name: 'Wolkendecke (%)',
                                nameTextStyle: { color: '#fff' },
                                axisLabel: { color: '#888' },
                                splitLine: { lineStyle: { color: '#333' } },
                                min: 0,
                                max: 100
                            },
                            series: [
                                {
                                    name: 'IST Wolken',
                                    type: 'line',
                                    data: cloudsIST,
                                    smooth: true,
                                    itemStyle: { color: '#3b82f6' },
                                    lineStyle: { width: 3 },
                                    areaStyle: { color: 'rgba(59, 130, 246, 0.2)' },
                                    symbol: 'circle',
                                    symbolSize: 8
                                },
                                {
                                    name: 'KI Vorhersage',
                                    type: 'line',
                                    data: cloudsKI,
                                    smooth: true,
                                    itemStyle: { color: '#8b5cf6' },
                                    lineStyle: { width: 3, type: 'dashed' },
                                    areaStyle: { color: 'rgba(139, 92, 246, 0.1)' },
                                    symbol: 'diamond',
                                    symbolSize: 8
                                }
                            ],
                            grid: { left: 70, right: 30, top: 60, bottom: 70 }
                        });
                    }

                    // KI Accuracy Analysis Chart
                    if (weatherAccuracyChart.value) {
                        weatherAccuracyChart.value.setOption({
                            tooltip: {
                                trigger: 'axis',
                                backgroundColor: 'rgba(30, 30, 62, 0.95)',
                                borderColor: '#8b5cf6',
                                textStyle: { color: '#fff' },
                                formatter: (params) => {
                                    const value = params[0].value;
                                    const color = value > 85 ? '#22c55e' : value > 70 ? '#f59e0b' : '#ef4444';
                                    return `${params[0].name}<br/><span style="color: ${color};">‚óè</span> Genauigkeit: ${value.toFixed(1)}%`;
                                }
                            },
                            xAxis: {
                                type: 'category',
                                data: dates,
                                axisLabel: { color: '#888', rotate: 45 },
                                axisLine: { lineStyle: { color: '#444' } }
                            },
                            yAxis: {
                                type: 'value',
                                name: 'KI Genauigkeit (%)',
                                nameTextStyle: { color: '#fff' },
                                axisLabel: { color: '#888' },
                                splitLine: { lineStyle: { color: '#333' } },
                                min: 0,
                                max: 100
                            },
                            series: [{
                                name: 'KI Genauigkeit',
                                type: 'bar',
                                data: accuracy,
                                itemStyle: {
                                    color: (params) => {
                                        const value = params.value;
                                        if (value > 85) return '#22c55e'; // Gr√ºn
                                        if (value > 70) return '#f59e0b'; // Orange
                                        return '#ef4444'; // Rot
                                    }
                                },
                                barWidth: '60%',
                                label: {
                                    show: true,
                                    position: 'top',
                                    formatter: '{c}%',
                                    color: '#fff',
                                    fontSize: 11
                                }
                            }],
                            grid: { left: 70, right: 30, top: 40, bottom: 70 },
                            visualMap: {
                                show: false,
                                min: 0,
                                max: 100,
                                dimension: 0
                            }
                        });
                    }
                }

                function initSolarCharts() {
                    // Wait a bit longer for Vue to render the modal DOM
                    setTimeout(() => {
                        const productionEl = solarProductionChart.value?.$el || document.getElementById('solar-production-chart');
                        const heatmapEl = solarHeatmapChart.value?.$el || document.getElementById('solar-heatmap-chart');
                        const accuracyEl = solarAccuracyChart.value?.$el || document.getElementById('solar-accuracy-chart');
                        const panelGroupEl = solarPanelGroupChart.value?.$el || document.getElementById('solar-panel-group-chart');

                        console.log('Init charts - Elements found:', {
                            production: !!productionEl,
                            heatmap: !!heatmapEl,
                            accuracy: !!accuracyEl,
                            panelGroup: !!panelGroupEl
                        });

                        if (productionEl && productionEl.offsetWidth > 0) {
                            solarProductionChart.value = echarts.init(productionEl);
                            console.log('Production chart initialized');
                        }
                        if (heatmapEl && heatmapEl.offsetWidth > 0) {
                            solarHeatmapChart.value = echarts.init(heatmapEl);
                            console.log('Heatmap chart initialized');
                        }
                        if (accuracyEl && accuracyEl.offsetWidth > 0) {
                            solarAccuracyChart.value = echarts.init(accuracyEl);
                            console.log('Accuracy chart initialized');
                        }
                        if (panelGroupEl && panelGroupEl.offsetWidth > 0 && panelGroups.available) {
                            solarPanelGroupChart.value = echarts.init(panelGroupEl);
                            console.log('Panel group chart initialized');
                        }
                    }, 150);
                }

                async function updateSolarCharts() {
                    try {
                        // Fetch historical solar data from statistics API (has more details)
                        const response = await fetch('/api/sfml_stats/statistics');
                        const result = await response.json();

                        // Check if we have data
                        if (!result.success || !result.history) {
                            console.warn('No solar data available', result);
                            return;
                        }

                        // Transform API data to expected format
                        const history = result.history.map(d => ({
                            date: d.date,
                            actual_kwh: d.actual_kwh || 0,
                            predicted_kwh: d.predicted_kwh || 0,
                            accuracy: d.accuracy || 0,
                            peak_power_w: d.peak_power_w || 0,
                            peak_hour: d.peak_hour || 12,
                            peak_at: d.peak_at || null,
                            production_hours: d.production_hours || 0
                        }));

                        console.log('Solar data loaded:', history.length, 'days', history.slice(0, 3));
                        solarModal.historicalData = history;
                        solarModal.hourlyProduction = result.hourly_production || {};
                        calculateSolarStats(history);
                        renderSolarCharts();
                    } catch (error) {
                        console.error('Error fetching solar analytics data:', error);
                    }
                }

                function calculateSolarStats(history) {
                    const now = new Date();
                    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                    const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
                    const yearStart = new Date(now.getFullYear(), 0, 1);

                    const weekData = history.filter(d => new Date(d.date) >= weekAgo);
                    const monthData = history.filter(d => new Date(d.date) >= monthStart);
                    const yearData = history.filter(d => new Date(d.date) >= yearStart);

                    solarModal.stats.weekTotal = weekData.reduce((sum, d) => sum + (d.actual_kwh || 0), 0);
                    solarModal.stats.monthTotal = monthData.reduce((sum, d) => sum + (d.actual_kwh || 0), 0);
                    solarModal.stats.yearTotal = yearData.reduce((sum, d) => sum + (d.actual_kwh || 0), 0);

                    const accuracyData = history.filter(d => d.accuracy > 0);
                    solarModal.stats.avgAccuracy = accuracyData.length > 0
                        ? Math.min(100, accuracyData.reduce((sum, d) => sum + Math.min(100, d.accuracy), 0) / accuracyData.length)
                        : 0;

                    solarModal.stats.peakPower = Math.max(...history.map(d => d.peak_power_w || 0));
                    solarModal.stats.avgDaily = history.length > 0
                        ? history.reduce((sum, d) => sum + (d.actual_kwh || 0), 0) / history.length
                        : 0;
                }

                function renderSolarCharts() {
                    const tab = solarModal.activeTab;
                    let data = [];

                    if (tab === 'week') {
                        const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
                        data = solarModal.historicalData.filter(d => new Date(d.date) >= weekAgo);
                    } else if (tab === 'month') {
                        const monthAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
                        data = solarModal.historicalData.filter(d => new Date(d.date) >= monthAgo);
                    } else {
                        const yearStart = new Date(new Date().getFullYear(), 0, 1);
                        data = solarModal.historicalData.filter(d => new Date(d.date) >= yearStart);
                    }

                    data.sort((a, b) => new Date(a.date) - new Date(b.date));

                    renderProductionChart(data);
                    renderHeatmapChart(data);
                    renderAccuracyChart(data);
                    if (panelGroups.available) renderPanelGroupChart();
                }

                function renderProductionChart(data) {
                    if (!solarProductionChart.value) {
                        console.warn('Production chart not initialized yet!');
                        return;
                    }

                    console.log('Rendering production chart with', data.length, 'days');
                    const dates = data.map(d => d.date.slice(5));
                    const actual = data.map(d => d.actual_kwh || 0);
                    const predicted = data.map(d => d.predicted_kwh || 0);

                    console.log('Chart data:', { dates, actual, predicted });

                    solarProductionChart.value.setOption({
                        backgroundColor: 'transparent',
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: '#1e1e3e',
                            borderColor: '#ffdd0033',
                            textStyle: { color: '#e2e8f0' }
                        },
                        legend: {
                            data: ['Tats√§chlich', 'Prognose'],
                            textStyle: { color: '#94a3b8' },
                            top: 0
                        },
                        grid: { left: '3%', right: '4%', bottom: '3%', top: '15%', containLabel: true },
                        xAxis: {
                            type: 'category',
                            data: dates,
                            axisLabel: { color: '#94a3b8', rotate: 45, interval: Math.floor(data.length / 10) }
                        },
                        yAxis: {
                            type: 'value',
                            axisLabel: { color: '#94a3b8', formatter: '{value} kWh' },
                            splitLine: { lineStyle: { color: '#1a1a3a' } }
                        },
                        series: [
                            {
                                name: 'Tats√§chlich',
                                type: 'bar',
                                data: actual,
                                itemStyle: {
                                    color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                        { offset: 0, color: '#ffdd00' },
                                        { offset: 1, color: '#ff8c00' }
                                    ]),
                                    borderRadius: [4, 4, 0, 0]
                                }
                            },
                            {
                                name: 'Prognose',
                                type: 'line',
                                data: predicted,
                                smooth: true,
                                lineStyle: { color: '#8b5cf6', width: 2 },
                                itemStyle: { color: '#8b5cf6' }
                            }
                        ]
                    });
                }

                function renderHeatmapChart(data) {
                    if (!solarHeatmapChart.value) return;

                    const hourlyProduction = solarModal.hourlyProduction || {};

                    // Build heatmap from real hourly production data
                    const hourlyData = [];
                    let maxVal = 0;
                    for (let hour = 6; hour <= 20; hour++) {
                        data.forEach((d, idx) => {
                            const dayData = hourlyProduction[d.date] || {};
                            const kwh = dayData[hour] || 0;
                            const wh = Math.round(kwh * 1000);
                            if (wh > maxVal) maxVal = wh;
                            hourlyData.push([idx, hour - 6, wh]);
                        });
                    }

                    const dates = data.map(d => d.date.slice(5));
                    const hours = Array.from({ length: 15 }, (_, i) => `${i + 6}:00`);

                    solarHeatmapChart.value.setOption({
                        backgroundColor: 'transparent',
                        tooltip: {
                            position: 'top',
                            backgroundColor: '#1e1e3e',
                            borderColor: '#ffdd0033',
                            textStyle: { color: '#e2e8f0' },
                            formatter: params => {
                                return `${dates[params.value[0]]}<br/>${hours[params.value[1]]}: ${params.value[2]} Wh`;
                            }
                        },
                        grid: { left: '10%', right: '4%', bottom: '10%', top: '5%' },
                        xAxis: {
                            type: 'category',
                            data: dates,
                            axisLabel: { color: '#94a3b8', rotate: 45, interval: Math.floor(data.length / 10) },
                            splitArea: { show: true }
                        },
                        yAxis: {
                            type: 'category',
                            data: hours,
                            axisLabel: { color: '#94a3b8' },
                            splitArea: { show: true }
                        },
                        visualMap: {
                            min: 0,
                            max: maxVal || 100,
                            calculable: true,
                            orient: 'horizontal',
                            left: 'center',
                            bottom: '0%',
                            inRange: {
                                color: ['#1a1a3a', '#ff8c00', '#ffdd00']
                            },
                            textStyle: { color: '#94a3b8' }
                        },
                        series: [{
                            type: 'heatmap',
                            data: hourlyData,
                            emphasis: {
                                itemStyle: {
                                    shadowBlur: 10,
                                    shadowColor: 'rgba(255, 221, 0, 0.5)'
                                }
                            }
                        }]
                    });
                }

                function renderAccuracyChart(data) {
                    if (!solarAccuracyChart.value) return;

                    const dates = data.map(d => d.date.slice(5));
                    const accuracy = data.map(d => d.accuracy || 0);

                    solarAccuracyChart.value.setOption({
                        backgroundColor: 'transparent',
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: '#1e1e3e',
                            borderColor: '#00ff8833',
                            textStyle: { color: '#e2e8f0' },
                            formatter: params => `${params[0].axisValue}: ${params[0].value.toFixed(1)}%`
                        },
                        grid: { left: '3%', right: '4%', bottom: '3%', top: '10%', containLabel: true },
                        xAxis: {
                            type: 'category',
                            data: dates,
                            axisLabel: { color: '#94a3b8', rotate: 45, interval: Math.floor(data.length / 10) }
                        },
                        yAxis: {
                            type: 'value',
                            axisLabel: { color: '#94a3b8', formatter: '{value}%' },
                            splitLine: { lineStyle: { color: '#1a1a3a' } },
                            min: 0,
                            max: 100
                        },
                        series: [{
                            type: 'line',
                            data: accuracy,
                            smooth: true,
                            lineStyle: { color: '#00ff88', width: 3 },
                            itemStyle: { color: '#00ff88' },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: 'rgba(0, 255, 136, 0.4)' },
                                    { offset: 1, color: 'rgba(0, 255, 136, 0)' }
                                ])
                            },
                            markLine: {
                                data: [{ type: 'average', name: 'Durchschnitt' }],
                                lineStyle: { color: '#8b5cf6', type: 'dashed' },
                                label: { color: '#8b5cf6' }
                            }
                        }]
                    });
                }

                function renderPanelGroupChart() {
                    if (!solarPanelGroupChart.value || !panelGroups.available) return;

                    const groups = Object.values(panelGroups.groups);
                    const names = groups.map(g => g.name);
                    const production = groups.map(g => g.actual_total_kwh || 0);
                    const prediction = groups.map(g => g.prediction_total_kwh || 0);

                    solarPanelGroupChart.value.setOption({
                        backgroundColor: 'transparent',
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: '#1e1e3e',
                            borderColor: '#ffdd0033',
                            textStyle: { color: '#e2e8f0' }
                        },
                        legend: {
                            data: ['Produktion', 'Prognose'],
                            textStyle: { color: '#94a3b8' },
                            top: 0
                        },
                        grid: { left: '3%', right: '4%', bottom: '3%', top: '15%', containLabel: true },
                        xAxis: {
                            type: 'category',
                            data: names,
                            axisLabel: { color: '#94a3b8' }
                        },
                        yAxis: {
                            type: 'value',
                            axisLabel: { color: '#94a3b8', formatter: '{value} kWh' },
                            splitLine: { lineStyle: { color: '#1a1a3a' } }
                        },
                        series: [
                            {
                                name: 'Produktion',
                                type: 'bar',
                                data: production,
                                itemStyle: { color: '#00ff88', borderRadius: [4, 4, 0, 0] }
                            },
                            {
                                name: 'Prognose',
                                type: 'bar',
                                data: prediction,
                                itemStyle: { color: '#8b5cf6', borderRadius: [4, 4, 0, 0] }
                            }
                        ]
                    });
                }

                // Watch for tab changes to update charts
                watch(() => solarModal.activeTab, () => {
                    if (solarModal.isOpen) {
                        renderSolarCharts();
                    }
                });

                watch(() => batteryModal.activeTab, () => {
                    if (batteryModal.isOpen) {
                        updateBatteryCharts();
                    }
                });

                watch(() => houseModal.activeTab, () => {
                    if (houseModal.isOpen) {
                        updateHouseCharts();
                    }
                });

                watch(() => gridModal.activeTab, () => {
                    if (gridModal.isOpen) {
                        updateGridCharts();
                    }
                });

                watch(() => weatherModal.activeTab, () => {
                    if (weatherModal.isOpen) {
                        // If switching to comparison tab, initialize comparison charts first
                        if (weatherModal.activeTab === 'comparison') {
                            initWeatherComparisonCharts();
                            setTimeout(async () => {
                                await renderWeatherComparisonCharts();
                            }, 200);
                        } else {
                            // For week/month/year tabs, just re-render with existing data (filtered by tab)
                            // Only fetch if no data loaded yet
                            if (weatherModal.historicalData && weatherModal.historicalData.length > 0) {
                                renderWeatherCharts();
                            } else {
                                updateWeatherCharts();
                            }
                        }
                    }
                });

                // Energy Balance - L√§dt Jahresbilanz aus Recorder (Riemann-Summe)
                async function fetchBillingData() {
                    try {
                        const res = await fetch('/api/sfml_stats/billing');
                        const data = await res.json();

                        if (!data.success) return;

                        console.log('Billing API Response:', data);

                        // Zeitraum
                        energyBalance.periodStart = data.period?.start;
                        energyBalance.periodEnd = data.period?.end;
                        energyBalance.periodProgress = data.period?.progress_percent || 0;
                        energyBalance.daysElapsed = data.period?.days_elapsed || 0;
                        energyBalance.daysTotal = data.period?.days_total || 365;

                        // ===== HAUSHALT (aus Recorder) =====
                        const household = data.household || {};
                        energyBalance.homeConsumption = household.total_kwh || 0;
                        energyBalance.solarToHouse = household.from_solar_kwh || 0;
                        energyBalance.batteryToHouse = household.from_battery_kwh || 0;
                        energyBalance.gridToHouse = household.from_grid_kwh || 0;

                        // ===== AKKU (aus Recorder) =====
                        const battery = data.battery || {};
                        energyBalance.batteryChargeTotal = battery.total_charge_kwh || 0;
                        energyBalance.solarToBattery = battery.from_solar_kwh || 0;
                        energyBalance.gridToBattery = battery.from_grid_kwh || 0;

                        // ===== SOLAR =====
                        const solar = data.solar || {};
                        energyBalance.solarProduction = solar.total_kwh || 0;

                        // ===== GRID =====
                        const grid = data.grid || {};
                        energyBalance.gridImport = grid.total_import_kwh || 0;
                        energyBalance.gridExport = grid.export_kwh || 0;

                        // ===== FINANZEN =====
                        const finance = data.finance || {};
                        energyBalance.estimatedCost = finance.grid_cost_eur || 0;
                        energyBalance.savings = finance.savings_eur || 0;
                        energyBalance.avgPrice = finance.avg_price_ct || 35;

                        // ===== TARIF-MODUS =====
                        if (data.config?.price_mode) {
                            energyBalance.priceMode = data.config.price_mode;
                        }

                        // ===== AUTARKIE =====
                        energyBalance.autarkiePercent = data.autarkie_percent || 0;

                        // ===== RECORDER META =====
                        energyBalance.recorderSamples = data.recorder?.sample_count || 0;
                        energyBalance.recorderAvailable = data.recorder?.data_available || false;

                        // Durchschnitt pro Tag
                        if (energyBalance.daysElapsed > 0) {
                            energyBalance.avgDailyProduction = energyBalance.solarProduction / energyBalance.daysElapsed;
                        }

                        // Berechne Anteile f√ºr Breakdown-Chart
                        const totalForBreakdown = energyBalance.homeConsumption;
                        if (totalForBreakdown > 0) {
                            energyBalance.solarSelfPercent = (energyBalance.solarToHouse / totalForBreakdown) * 100;
                            energyBalance.batteryPercent = (energyBalance.batteryToHouse / totalForBreakdown) * 100;
                            energyBalance.gridPercent = (energyBalance.gridToHouse / totalForBreakdown) * 100;
                        }

                        // Hochrechnung auf ganzes Jahr
                        if (energyBalance.daysElapsed > 0 && energyBalance.daysElapsed < energyBalance.daysTotal) {
                            const factor = energyBalance.daysTotal / energyBalance.daysElapsed;
                            energyBalance.projectedYearlySavings = energyBalance.savings * factor;
                        }

                        // Gespartes kWh = Eigenverbrauch (Solar direkt + √ºber Akku)
                        energyBalance.savedKwh = energyBalance.solarToHouse + energyBalance.batteryToHouse;

                        console.log('Energy Balance Updated:', {
                            household: energyBalance.homeConsumption,
                            solar: energyBalance.solarProduction,
                            grid: energyBalance.gridImport,
                            autarkie: energyBalance.autarkiePercent,
                            recorderSamples: energyBalance.recorderSamples
                        });

                    } catch (err) {
                        console.error('Fehler beim Laden der Billing-Daten:', err);
                    }
                }

                // HINWEIS: Die Jahresbilanz kommt ausschlie√ülich aus der Billing API
                // Der sensor_grid_import_yearly z√§hlt ab 01.01., nicht ab Abrechnungsstart!
                // Daher KEIN Fallback auf diesen Sensor - w√ºrde falsche Werte zeigen.
                function updateEnergyBalanceFromSensors(energyFlowData, gridImportYearly) {
                    // DEAKTIVIERT: Fallback w√ºrde falschen Zeitraum zeigen!
                    // grid_import_yearly = ab 01.01., Abrechnung = ab konfiguriertem Startdatum
                    // Die echten Werte kommen aus hourly_billing_history.json √ºber die Billing API
                    return;
                }

                // Differential fetching: energy_flow every poll, others less frequently
                const _fetchTimestamps = {};
                const _fetchIntervals = { statistics: 30000, summary: 30000, solar: 60000, prices: 300000 };
                function _needsFetch(key) {
                    const now = Date.now();
                    if (!_fetchTimestamps[key] || (now - _fetchTimestamps[key]) >= _fetchIntervals[key]) {
                        _fetchTimestamps[key] = now;
                        return true;
                    }
                    return false;
                }

                async function fetchData() {
                    try {
                        // energy_flow: always (real-time), others: conditional
                        const doStats = _needsFetch('statistics');
                        const doSummary = _needsFetch('summary');
                        const doSolar = _needsFetch('solar');
                        const doPrices = _needsFetch('prices');

                        const [energyFlowRes, statsRes, summaryRes, solarRes, priceRes] = await Promise.all([
                            fetch('/api/sfml_stats/energy_flow'),
                            doStats ? fetch('/api/sfml_stats/statistics') : Promise.resolve(null),
                            doSummary ? fetch('/api/sfml_stats/summary') : Promise.resolve(null),
                            doSolar ? fetch('/api/sfml_stats/solar?days=7') : Promise.resolve(null),
                            doPrices ? fetch('/api/sfml_stats/prices?days=2') : Promise.resolve(null),
                        ]);

                        const energyFlowData = await energyFlowRes.json();
                        const statsData = statsRes ? await statsRes.json() : null;
                        const summary = summaryRes ? await summaryRes.json() : null;
                        const solar = solarRes ? await solarRes.json() : null;
                        const prices = priceRes ? await priceRes.json() : null;

                        // Energy Flow
                        if (energyFlowData.success) {
                            // Solar kann NIEMALS negativ sein - korrigiere negative Werte
                            if (energyFlowData.flows) {
                                energyFlowData.flows.solar_to_house = Math.max(0, energyFlowData.flows.solar_to_house || 0);
                                energyFlowData.flows.solar_to_battery = Math.max(0, energyFlowData.flows.solar_to_battery || 0);
                                energyFlowData.flows.solar_power = Math.max(0, energyFlowData.flows.solar_power || 0);
                            }
                            Object.assign(energyFlow.flows, energyFlowData.flows);
                            Object.assign(energyFlow.battery, energyFlowData.battery);
                            Object.assign(energyFlow.home, energyFlowData.home);
                            Object.assign(energyFlow.statistics, energyFlowData.statistics);

                            // Feed-in tariff from config
                            if (energyFlowData.feed_in_tariff !== undefined) {
                                energyFlow.feed_in_tariff = energyFlowData.feed_in_tariff;
                            }

                            // Price mode from config
                            if (energyFlowData.price_mode !== undefined) {
                                energyBalance.priceMode = energyFlowData.price_mode;
                            }

                            // Check if battery is configured (has valid SOC value)
                            hasBattery.value = energyFlowData.battery?.soc !== null && energyFlowData.battery?.soc !== undefined;

                            // Panel data
                            if (energyFlowData.panels) {
                                energyFlow.panels = energyFlowData.panels;
                            }

                            // Consumer data (W√§rmepumpe, Heizstab, Wallbox)
                            if (energyFlowData.consumers) {
                                energyFlow.consumers = energyFlowData.consumers;
                            }

                            // HA Weather Integration
                            if (energyFlowData.weather_ha) {
                                weatherHA.state = energyFlowData.weather_ha.state;
                                weatherHA.temperature = energyFlowData.weather_ha.temperature;
                                weatherHA.humidity = energyFlowData.weather_ha.humidity;
                                weatherHA.wind_speed = energyFlowData.weather_ha.wind_speed;
                                weatherHA.cloud_coverage = energyFlowData.weather_ha.cloud_coverage;
                                weatherHA.pressure = energyFlowData.weather_ha.pressure;
                            }

                            // Sun Position
                            if (energyFlowData.sun_position) {
                                sunPosition.elevation_deg = energyFlowData.sun_position.elevation_deg;
                                sunPosition.azimuth_deg = energyFlowData.sun_position.azimuth_deg;
                                sunPosition.direction = energyFlowData.sun_position.direction;
                                sunPosition.sunrise = energyFlowData.sun_position.sunrise;
                                sunPosition.sunset = energyFlowData.sun_position.sunset;
                                sunPosition.daylight_hours = energyFlowData.sun_position.daylight_hours;
                            }

                            // Current Price (from price_cache.json)
                            if (energyFlowData.current_price) {
                                currentPrice.total_price = energyFlowData.current_price.total_price;
                                currentPrice.net_price = energyFlowData.current_price.net_price;
                                currentPrice.hour = energyFlowData.current_price.hour;
                            }

                            // Energy Balance mit Jahres-Netzbezug erg√§nzen
                            const gridImportYearly = energyFlowData.statistics?.grid_import_yearly || null;
                            updateEnergyBalanceFromSensors(energyFlowData, gridImportYearly);
                        }

                        // Statistics (conditional: every 30s)
                        if (statsData?.success) {
                            Object.assign(stats.peaks, statsData.peaks);
                            Object.assign(stats.production, statsData.production);
                            Object.assign(stats.statistics, statsData.statistics);
                            stats.production_time = statsData.production_time || null;

                            // Beste Stunde (aus daily_forecasts.json)
                            if (statsData.best_hour) {
                                bestHour.hour = statsData.best_hour.hour;
                                bestHour.prediction_kwh = statsData.best_hour.prediction_kwh;
                            }

                            // Panel Groups (Prognose + IST pro Gruppe)
                            if (statsData.panel_groups) {
                                panelGroups.available = statsData.panel_groups.available;
                                panelGroups.groups = statsData.panel_groups.groups || {};
                            }
                        }

                        if (summary?.success) {
                            kpis.weekProduction = summary.week?.total_production || 0;
                            kpis.avgAccuracy = summary.week?.avg_accuracy || 0;
                            kpis.priceMin = summary.kpis?.price_min || 0;
                            kpis.priceMax = summary.kpis?.price_max || 0;
                            live.price = summary.kpis?.price_current || 0;

                            // Production Time & Sun Times
                            if (summary.production_time) {
                                Object.assign(productionTime, summary.production_time);
                            }
                            if (summary.sun_times) {
                                Object.assign(sunTimes, summary.sun_times);
                            }
                        }

                        if (solar?.success && solar?.data) {
                            const hourly = solar.data.hourly || [];
                            const now = new Date();
                            // Lokales Datum verwenden (nicht UTC!)
                            const todayStr = now.getFullYear() + '-' +
                                String(now.getMonth() + 1).padStart(2, '0') + '-' +
                                String(now.getDate()).padStart(2, '0');
                            const tomorrow = new Date(now);
                            tomorrow.setDate(tomorrow.getDate() + 1);
                            const tomorrowStr = tomorrow.getFullYear() + '-' +
                                String(tomorrow.getMonth() + 1).padStart(2, '0') + '-' +
                                String(tomorrow.getDate()).padStart(2, '0');
                            const dayAfterTomorrow = new Date(now);
                            dayAfterTomorrow.setDate(dayAfterTomorrow.getDate() + 2);
                            const dayAfterTomorrowStr = dayAfterTomorrow.getFullYear() + '-' +
                                String(dayAfterTomorrow.getMonth() + 1).padStart(2, '0') + '-' +
                                String(dayAfterTomorrow.getDate()).padStart(2, '0');
                            const currentHour = now.getHours();

                            const currentPred = hourly.find(h => h.target_date === todayStr && h.target_hour === currentHour);
                            if (currentPred) {
                                live.power = (currentPred.actual_kwh || currentPred.prediction_kwh || 0) * 1000;
                            }

                            // IST-Wetter: Prim√§r aus hourly_weather_actual (solar.data.weather)
                            const actualWeather = solar.data.weather?.[todayStr]?.[String(currentHour)];
                            if (actualWeather) {
                                weather.temperature = actualWeather.temperature_c;
                                weather.radiation = actualWeather.solar_radiation_wm2;
                                weather.humidity = actualWeather.humidity_percent;
                                weather.wind = actualWeather.wind_speed_ms;
                                // Wolken aus Strahlungsdaten berechnen (W/m¬≤ Sensor)
                                // Physikalische Ableitung: Weniger Strahlung = mehr Wolken
                                if (actualWeather.solar_radiation_wm2 !== undefined && actualWeather.solar_radiation_wm2 !== null) {
                                    // Maximale erwartete Strahlung basierend auf Jahreszeit
                                    // Winter (Nov-Feb): ~500 W/m¬≤ max, Sommer: ~900 W/m¬≤ max
                                    const month = new Date().getMonth(); // 0-11
                                    const hour = currentHour;
                                    const isSummer = month >= 4 && month <= 8;
                                    const maxRadiation = isSummer ? 900 : 500;

                                    // Nur tags√ºber berechnen (Strahlung > 0 erwartet)
                                    const isDaytime = hour >= 7 && hour <= 19;
                                    if (isDaytime && maxRadiation > 0) {
                                        const clearSkyRatio = Math.min(1, actualWeather.solar_radiation_wm2 / maxRadiation);
                                        weather.clouds = Math.round((1 - clearSkyRatio) * 100);
                                    } else {
                                        // Nachts: Fallback auf KI-Daten wenn verf√ºgbar
                                        const correctedHour = solar.data.weather_corrected?.[todayStr]?.[String(currentHour)];
                                        weather.clouds = correctedHour?.clouds ?? 50;
                                    }
                                } else {
                                    // Fallback: condition-basierte Logik
                                    const cond = (actualWeather.condition || '').toLowerCase();
                                    if (cond.includes('clear') || cond.includes('sunny')) weather.clouds = 0;
                                    else if (cond.includes('partly')) weather.clouds = 30;
                                    else if (cond.includes('cloudy')) weather.clouds = 75;
                                    else if (cond.includes('overcast')) weather.clouds = 100;
                                    else if (cond.includes('rain') || cond.includes('fog')) weather.clouds = 90;
                                    else weather.clouds = 50;
                                }
                            } else if (currentPred) {
                                // Fallback: weather_forecast aus predictions
                                const wf = currentPred.weather_forecast || {};
                                weather.temperature = wf.temperature;
                                weather.radiation = wf.solar_radiation_wm2;
                                weather.humidity = wf.humidity;
                                weather.wind = wf.wind;
                                weather.clouds = wf.clouds;
                            }

                            // KI-korrigierte Wetterdaten laden
                            const correctedData = solar.data.weather_corrected?.[todayStr]?.[String(currentHour)];
                            if (correctedData) {
                                weatherCorrected.temperature = correctedData.temperature;
                                weatherCorrected.radiation = correctedData.solar_radiation_wm2;
                                weatherCorrected.humidity = correctedData.humidity;
                                weatherCorrected.wind = correctedData.wind;
                                weatherCorrected.clouds = correctedData.clouds;
                            }

                            const todayPreds = hourly.filter(h => h.target_date === todayStr && h.target_hour >= 6 && h.target_hour <= 20);
                            forecast.todayHours = todayPreds.map(h => ({ hour: h.target_hour, kwh: h.prediction_kwh || 0, actual: h.actual_kwh || 0 }));
                            forecast.todayTotal = todayPreds.reduce((s, h) => s + (h.prediction_kwh || 0), 0);

                            // Korrigierte Tagesprognose aus daily_forecasts (prediction_kwh_display)
                            const correctedForecast = solar.data.forecasts?.today?.prediction_kwh_display;
                            forecast.todayTotalCorrected = (correctedForecast && correctedForecast !== forecast.todayTotal) ? correctedForecast : null;

                            live.yield = todayPreds.filter(h => h.actual_kwh != null).reduce((s, h) => s + (h.actual_kwh || 0), 0);
                            forecast.todayRemaining = todayPreds.filter(h => h.target_hour > currentHour).reduce((s, h) => s + (h.prediction_kwh || 0), 0);

                            // Tagesgenauigkeit berechnen aus angezeigten Werten (Sensor vs Prognose-Summe)
                            // Dies stellt sicher, dass die Genauigkeit konsistent mit den angezeigten Ertrag/Prognose-Werten ist
                            const actualFromSensor = energyFlow.statistics?.solar_yield_daily || 0;
                            const predictedTotal = forecast.todayTotal || 0;
                            if (predictedTotal > 0 && actualFromSensor > 0) {
                                const deviation = Math.abs((actualFromSensor - predictedTotal) / predictedTotal) * 100;
                                todayAccuracy.value = Math.max(0, 100 - deviation);
                            }

                            const tomorrowPreds = hourly.filter(h => h.target_date === tomorrowStr && h.target_hour >= 6 && h.target_hour <= 20);
                            forecast.tomorrowHours = tomorrowPreds.map(h => ({ hour: h.target_hour, kwh: h.prediction_kwh || 0 }));
                            forecast.tomorrowTotal = tomorrowPreds.reduce((s, h) => s + (h.prediction_kwh || 0), 0);

                            // Fallback: Wenn keine st√ºndlichen Daten f√ºr morgen, nutze multi_day_hourly
                            if (forecast.tomorrowHours.length === 0 && solar.data.multi_day_hourly?.[tomorrowStr]) {
                                const multiDayTomorrow = solar.data.multi_day_hourly[tomorrowStr];
                                const tomorrowHourly = (multiDayTomorrow.hourly || []).filter(h => h.hour >= 6 && h.hour <= 20);
                                forecast.tomorrowHours = tomorrowHourly.map(h => ({ hour: h.hour, kwh: h.prediction_kwh || 0 }));
                                forecast.tomorrowTotal = multiDayTomorrow.total_kwh || tomorrowHourly.reduce((s, h) => s + (h.prediction_kwh || 0), 0);
                            } else if (forecast.tomorrowHours.length === 0 && solar.data.forecasts?.tomorrow) {
                                forecast.tomorrowTotal = solar.data.forecasts.tomorrow.prediction_kwh || 0;
                            }

                            // √úbermorgen-Daten laden
                            const dayAfterTomorrowPreds = hourly.filter(h => h.target_date === dayAfterTomorrowStr && h.target_hour >= 6 && h.target_hour <= 20);
                            forecast.dayAfterTomorrowHours = dayAfterTomorrowPreds.map(h => ({ hour: h.target_hour, kwh: h.prediction_kwh || 0 }));
                            forecast.dayAfterTomorrowTotal = dayAfterTomorrowPreds.reduce((s, h) => s + (h.prediction_kwh || 0), 0);

                            // Fallback: Wenn keine st√ºndlichen Daten f√ºr √ºbermorgen, nutze multi_day_hourly
                            if (forecast.dayAfterTomorrowHours.length === 0 && solar.data.multi_day_hourly?.[dayAfterTomorrowStr]) {
                                const multiDayAfter = solar.data.multi_day_hourly[dayAfterTomorrowStr];
                                const afterHourly = (multiDayAfter.hourly || []).filter(h => h.hour >= 6 && h.hour <= 20);
                                forecast.dayAfterTomorrowHours = afterHourly.map(h => ({ hour: h.hour, kwh: h.prediction_kwh || 0 }));
                                forecast.dayAfterTomorrowTotal = multiDayAfter.total_kwh || afterHourly.reduce((s, h) => s + (h.prediction_kwh || 0), 0);
                            } else if (forecast.dayAfterTomorrowHours.length === 0 && solar.data.forecasts?.day_after_tomorrow) {
                                forecast.dayAfterTomorrowTotal = solar.data.forecasts.day_after_tomorrow.prediction_kwh || 0;
                            }

                            forecast.maxHourly = Math.max(0.1, ...forecast.todayHours.map(h => h.kwh), ...forecast.tomorrowHours.map(h => h.kwh), ...forecast.dayAfterTomorrowHours.map(h => h.kwh));
                            kpis.forecastWeek = hourly.reduce((s, h) => s + (h.prediction_kwh || 0), 0);

                            updateProductionChart(solar.data.daily || []);
                            updateAccuracyChart(solar.data.daily || []);
                            updateTimelineChart(hourly);

                            // Neuer Tages-Chart mit aktueller Solarleistung
                            const currentSolarPower = energyFlow.flows.solar_power || 0;
                            updateTodayProductionChart(hourly, currentSolarPower);

                            // Panel-Gruppen Charts aktualisieren (nextTick warten bis DOM gerendert)
                            Vue.nextTick(() => {
                                updatePanelGroupCharts();
                            });

                            // Erweiterte Charts mit History-Daten
                            if (solar.data.history) {
                                updateExtendedCharts(solar.data.history, solar.data.astronomy || {}, solar.data.statistics);
                            }
                        }

                        if (prices?.success && prices?.data?.prices && energyBalance.priceMode === 'dynamic') {
                            updatePriceChart(prices.data.prices, prices.data.statistics);
                        }

                        lastUpdate.value = new Date().toLocaleTimeString('de-DE');
                    } catch (e) { console.error('Fetch error:', e); }
                }

                function initCharts() {
                    if (productionChart.value) charts.production = echarts.init(productionChart.value);
                    if (priceChart.value && energyBalance.priceMode === 'dynamic') charts.price = echarts.init(priceChart.value);
                    if (timelineChart.value) charts.timeline = echarts.init(timelineChart.value);
                    if (todayProductionChart.value) charts.todayProduction = echarts.init(todayProductionChart.value);
                    if (accuracyChart.value) charts.accuracy = echarts.init(accuracyChart.value);
                    // Neue Charts
                    if (trendChart.value) charts.trend = echarts.init(trendChart.value);
                    if (monthlyChart.value) charts.monthly = echarts.init(monthlyChart.value);
                    // Power Sources Preview Chart
                    const powerSourcesEl = document.querySelector('.power-sources-chart-container');
                    if (powerSourcesEl && powerSourcesEl.offsetWidth > 0) {
                        charts.powerSourcesPreview = echarts.init(powerSourcesEl);
                    }
                }

                function updateProductionChart(daily) {
                    if (!charts.production) return;
                    // Chronologisch sortieren (√§ltester Tag links, neuester rechts)
                    const sorted = [...daily].sort((a, b) => new Date(a.date) - new Date(b.date));
                    const days = sorted.map(d => ['So','Mo','Di','Mi','Do','Fr','Sa'][new Date(d.date).getDay()]);
                    // Genauigkeit pro Tag berechnen
                    const accuracyData = sorted.map(d => d.overall?.accuracy_percent || 0);
                    charts.production.setOption({
                        backgroundColor: 'transparent',
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: '#1e1e3e',
                            borderColor: '#00ffff33',
                            textStyle: { color: '#e2e8f0' },
                            formatter: params => {
                                const idx = params[0].dataIndex;
                                const acc = accuracyData[idx];
                                const dateStr = sorted[idx]?.date || '';
                                let result = `<b>${params[0].axisValue}</b> (${dateStr.slice(5)})<br/>`;
                                params.forEach(p => {
                                    result += `${p.marker} ${p.seriesName}: <b>${p.value?.toFixed(2) || 0} kWh</b><br/>`;
                                });
                                // Genauigkeit mit Farbe
                                const accColor = acc >= 80 ? '#00ff88' : acc >= 50 ? '#ffdd00' : '#ef4444';
                                result += `<span style="color:${accColor}">üìä Genauigkeit: <b>${acc.toFixed(0)}%</b></span>`;
                                return result;
                            }
                        },
                        legend: { data: ['Tats√§chlich', 'Vorhersage'], textStyle: { color: '#94a3b8' }, top: 0 },
                        grid: { left: '3%', right: '4%', bottom: '3%', top: '12%', containLabel: true },
                        xAxis: { type: 'category', data: days, axisLabel: { color: '#94a3b8' } },
                        yAxis: {
                            type: 'value',
                            min: 0,
                            max: function(value) {
                                // Dynamische Skalierung: Max + 15% Puffer, mindestens 1 kWh
                                return Math.max(1, Math.ceil(value.max * 1.15 * 10) / 10);
                            },
                            axisLabel: { color: '#94a3b8' },
                            splitLine: { lineStyle: { color: '#1a1a3a' } }
                        },
                        series: [
                            {
                                name: 'Tats√§chlich',
                                type: 'bar',
                                data: sorted.map(d => d.overall?.actual_total_kwh || 0),
                                itemStyle: { color: '#00ff88', borderRadius: [4,4,0,0] },
                                label: {
                                    show: true,
                                    position: 'top',
                                    formatter: (params) => {
                                        const acc = accuracyData[params.dataIndex];
                                        return acc > 0 ? `${acc.toFixed(0)}%` : '';
                                    },
                                    color: params => {
                                        const acc = accuracyData[params.dataIndex];
                                        return acc >= 80 ? '#00ff88' : acc >= 50 ? '#ffdd00' : '#ef4444';
                                    },
                                    fontSize: 10,
                                    fontWeight: 'bold'
                                }
                            },
                            {
                                name: 'Vorhersage',
                                type: 'bar',
                                data: sorted.map(d => d.overall?.predicted_total_kwh || 0),
                                itemStyle: { color: '#3b82f6', borderRadius: [4,4,0,0] }
                            }
                        ]
                    });
                }

                function updateAccuracyChart(daily) {
                    if (!charts.accuracy) return;

                    // Heutiges Datum (ohne Uhrzeit) f√ºr Vergleich
                    const today = new Date().toISOString().slice(0, 10);

                    // Chronologisch sortieren und heutigen Tag ausschlie√üen (noch keine vollst√§ndigen IST-Werte)
                    const sorted = [...daily]
                        .filter(d => d.date < today)
                        .sort((a, b) => new Date(a.date) - new Date(b.date));

                    if (sorted.length === 0) return;

                    // Wochentage als Labels
                    const days = sorted.map(d => {
                        // T12:00 verhindert Zeitzonenprobleme bei Datumsstrings
                        const dateObj = new Date(d.date + 'T12:00:00');
                        return ['So','Mo','Di','Mi','Do','Fr','Sa'][dateObj.getDay()];
                    });

                    // Abweichung berechnen: (Tats√§chlich - Prognose) / Prognose * 100
                    const deviationData = sorted.map(d => {
                        const actual = d.overall?.actual_total_kwh || 0;
                        const predicted = d.overall?.predicted_total_kwh || 0;
                        if (predicted > 0) {
                            return parseFloat(((actual - predicted) / predicted * 100).toFixed(1));
                        }
                        return 0;
                    });

                    charts.accuracy.setOption({
                        backgroundColor: 'transparent',
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: '#1e1e3e',
                            borderColor: '#00ffff33',
                            textStyle: { color: '#e2e8f0' },
                            formatter: params => {
                                const idx = params[0].dataIndex;
                                const d = sorted[idx];
                                const actual = d.overall?.actual_total_kwh || 0;
                                const predicted = d.overall?.predicted_total_kwh || 0;
                                const dev = deviationData[idx];
                                const devColor = dev >= 0 ? '#00ff88' : '#ef4444';
                                const devSign = dev >= 0 ? '+' : '';
                                return `<b>${d.date}</b><br/>
                                    Tats√§chlich: <b>${actual.toFixed(2)} kWh</b><br/>
                                    Prognose: <b>${predicted.toFixed(2)} kWh</b><br/>
                                    <span style="color:${devColor}">Abweichung: <b>${devSign}${dev}%</b></span>`;
                            }
                        },
                        grid: { left: '3%', right: '4%', bottom: '3%', top: '10%', containLabel: true },
                        xAxis: {
                            type: 'category',
                            data: days,
                            axisLabel: { color: '#94a3b8' },
                            axisLine: { lineStyle: { color: '#1a1a3a' } }
                        },
                        yAxis: {
                            type: 'value',
                            axisLabel: { color: '#94a3b8', formatter: '{value}%' },
                            splitLine: { lineStyle: { color: '#1a1a3a' } }
                        },
                        series: [
                            {
                                name: 'Abweichung',
                                type: 'line',
                                data: deviationData,
                                smooth: true,
                                symbol: 'circle',
                                symbolSize: 8,
                                lineStyle: {
                                    color: '#00ffff',
                                    width: 3
                                },
                                itemStyle: {
                                    color: params => params.value >= 0 ? '#00ff88' : '#ef4444',
                                    borderColor: '#0a0a1a',
                                    borderWidth: 2
                                },
                                areaStyle: {
                                    color: {
                                        type: 'linear', x: 0, y: 0, x2: 0, y2: 1,
                                        colorStops: [
                                            { offset: 0, color: 'rgba(0, 255, 136, 0.3)' },
                                            { offset: 0.5, color: 'rgba(0, 255, 255, 0.05)' },
                                            { offset: 1, color: 'rgba(239, 68, 68, 0.3)' }
                                        ]
                                    }
                                },
                                // 0-Linie (Treffer)
                                markLine: {
                                    silent: true,
                                    symbol: 'none',
                                    lineStyle: { color: '#ffdd00', width: 2, type: 'dashed' },
                                    data: [{ yAxis: 0, label: { show: true, formatter: '0% Treffer', color: '#ffdd00', fontSize: 10, position: 'end' } }]
                                },
                                // Min/Max Marker
                                markPoint: {
                                    data: [
                                        { type: 'max', name: 'Max', symbol: 'circle', symbolSize: 12, itemStyle: { color: '#00ff88' }, label: { formatter: '+{c}%', color: '#00ff88', fontSize: 10 } },
                                        { type: 'min', name: 'Min', symbol: 'circle', symbolSize: 12, itemStyle: { color: '#ef4444' }, label: { formatter: '{c}%', color: '#ef4444', fontSize: 10 } }
                                    ]
                                }
                            }
                        ]
                    });
                }

                function updatePriceChart(prices, stats) {
                    if (!charts.price) return;

                    const now = new Date();
                    // Lokales Datum verwenden (nicht UTC!)
                    const todayStr = now.getFullYear() + '-' +
                        String(now.getMonth() + 1).padStart(2, '0') + '-' +
                        String(now.getDate()).padStart(2, '0');

                    // Berechne morgen
                    const tomorrow = new Date(now);
                    tomorrow.setDate(tomorrow.getDate() + 1);
                    const tomorrowStr = tomorrow.getFullYear() + '-' +
                        String(tomorrow.getMonth() + 1).padStart(2, '0') + '-' +
                        String(tomorrow.getDate()).padStart(2, '0');

                    // Hilfsfunktion: Datum aus Preis-Objekt extrahieren
                    // Nutzt das 'date' Feld falls vorhanden, sonst parse Timestamp
                    function getPriceDateStr(priceObj) {
                        // Wenn date-Feld vorhanden, direkt nutzen
                        if (priceObj.date) {
                            return priceObj.date;
                        }
                        // Fallback: Timestamp parsen (lokal)
                        const d = new Date(priceObj.timestamp);
                        return d.getFullYear() + '-' +
                            String(d.getMonth() + 1).padStart(2, '0') + '-' +
                            String(d.getDate()).padStart(2, '0');
                    }

                    // Filtere Preise f√ºr heute und sortiere nach Stunde
                    const todayPrices = prices
                        .filter(p => getPriceDateStr(p) === todayStr)
                        .sort((a, b) => a.hour - b.hour);

                    // Filtere Preise f√ºr morgen und sortiere nach Stunde
                    const tomorrowPrices = prices
                        .filter(p => getPriceDateStr(p) === tomorrowStr)
                        .sort((a, b) => a.hour - b.hour);

                    // Erstelle vollst√§ndige 24h Arrays (0-23)
                    const hours = Array.from({length: 24}, (_, i) => i);
                    const todayData = hours.map(h => {
                        const found = todayPrices.find(p => p.hour === h);
                        return found ? found.price_total || 0 : null;
                    });
                    const tomorrowData = hours.map(h => {
                        const found = tomorrowPrices.find(p => p.hour === h);
                        return found ? found.price_total || 0 : null;
                    });

                    // Min/Max f√ºr heute berechnen
                    const todayValid = todayData.filter(v => v !== null);
                    if (todayValid.length > 0) {
                        const maxIdx = todayData.indexOf(Math.max(...todayValid));
                        const minIdx = todayData.indexOf(Math.min(...todayValid));
                        priceStats.max = Math.max(...todayValid).toFixed(2);
                        priceStats.maxHour = maxIdx;
                        priceStats.min = Math.min(...todayValid).toFixed(2);
                        priceStats.minHour = minIdx;
                    }

                    // Min/Max f√ºr morgen berechnen
                    const tomorrowValid = tomorrowData.filter(v => v !== null);
                    if (tomorrowValid.length > 0) {
                        const maxIdx = tomorrowData.indexOf(Math.max(...tomorrowValid));
                        const minIdx = tomorrowData.indexOf(Math.min(...tomorrowValid));
                        priceStatsTomorrow.max = Math.max(...tomorrowValid).toFixed(2);
                        priceStatsTomorrow.maxHour = maxIdx;
                        priceStatsTomorrow.min = Math.min(...tomorrowValid).toFixed(2);
                        priceStatsTomorrow.minHour = minIdx;
                    } else {
                        priceStatsTomorrow.max = '‚Äî';
                        priceStatsTomorrow.min = '‚Äî';
                    }

                    charts.price.setOption({
                        backgroundColor: 'transparent',
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: '#1e1e3e',
                            borderColor: '#00ffff33',
                            textStyle: { color: '#e2e8f0' },
                            formatter: params => {
                                let result = `${params[0].axisValue}<br/>`;
                                params.forEach(p => {
                                    if (p.value !== null) {
                                        result += `${p.seriesName}: <b>${p.value?.toFixed(2)} ct</b><br/>`;
                                    }
                                });
                                return result;
                            }
                        },
                        legend: { data: ['Heute', 'Morgen'], textStyle: { color: '#94a3b8' }, top: 0 },
                        grid: { left: '3%', right: '4%', bottom: '3%', top: '12%', containLabel: true },
                        xAxis: { type: 'category', data: hours.map(h => h + ':00'), axisLabel: { color: '#94a3b8', interval: 3 } },
                        yAxis: { type: 'value', axisLabel: { color: '#94a3b8', formatter: '{value} ct' }, splitLine: { lineStyle: { color: '#1a1a3a' } } },
                        series: [
                            {
                                name: 'Heute',
                                type: 'line',
                                data: todayData,
                                smooth: true,
                                lineStyle: { color: '#ff0080', width: 3 },
                                areaStyle: { color: { type: 'linear', x: 0, y: 0, x2: 0, y2: 1, colorStops: [{offset: 0, color: '#ff008022'}, {offset: 1, color: '#ff008000'}] } },
                                itemStyle: { color: '#ff0080' },
                                markPoint: {
                                    data: [
                                        { type: 'max', name: 'Max', symbol: 'circle', symbolSize: 10, itemStyle: { color: '#ef4444' } },
                                        { type: 'min', name: 'Min', symbol: 'circle', symbolSize: 10, itemStyle: { color: '#22c55e' } }
                                    ],
                                    label: { show: false }
                                }
                            },
                            {
                                name: 'Morgen',
                                type: 'line',
                                data: tomorrowData,
                                smooth: true,
                                lineStyle: { color: '#00ffff', width: 3 },
                                areaStyle: { color: { type: 'linear', x: 0, y: 0, x2: 0, y2: 1, colorStops: [{offset: 0, color: '#00ffff22'}, {offset: 1, color: '#00ffff00'}] } },
                                itemStyle: { color: '#00ffff' },
                                markPoint: {
                                    data: [
                                        { type: 'max', name: 'Max', symbol: 'circle', symbolSize: 10, itemStyle: { color: '#ef4444' } },
                                        { type: 'min', name: 'Min', symbol: 'circle', symbolSize: 10, itemStyle: { color: '#22c55e' } }
                                    ],
                                    label: { show: false }
                                }
                            }
                        ]
                    });
                }

                function updateTimelineChart(hourly) {
                    if (!charts.timeline) return;

                    // Volle 7 Tage, nur Produktionsstunden (7-18h)
                    const sorted = [...hourly]
                        .filter(h => h.target_hour >= 7 && h.target_hour <= 18)
                        .sort((a,b) => new Date(a.target_datetime) - new Date(b.target_datetime));

                    // Tagesgrenzen f√ºr markArea berechnen
                    const dayDates = [...new Set(sorted.map(h => h.target_date))];
                    const markAreas = dayDates
                        .filter((_, i) => i % 2 === 1)
                        .map(d => {
                            const first = sorted.findIndex(h => h.target_date === d);
                            const last = sorted.filter(h => h.target_date === d).length + first - 1;
                            if (first < 0) return null;
                            return [{ xAxis: first }, { xAxis: last }];
                        })
                        .filter(Boolean);

                    charts.timeline.setOption({
                        backgroundColor: 'transparent',
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: 'rgba(30, 30, 62, 0.95)',
                            borderColor: '#00ffff33',
                            textStyle: { color: '#e2e8f0' },
                            formatter: function(params) {
                                const h = sorted[params[0].dataIndex];
                                const dateStr = h?.target_date ? h.target_date.slice(5).replace('-', '.') : '';
                                let html = `<div style="font-weight:600;margin-bottom:6px;">${dateStr} ${h?.target_hour || ''}:00</div>`;
                                params.forEach(p => {
                                    if (p.value !== null && p.value !== undefined) {
                                        html += `<div style="display:flex;justify-content:space-between;gap:16px;">
                                            <span>${p.marker} ${p.seriesName}</span>
                                            <span style="font-weight:600;">${(p.value * 1000).toFixed(0)} Wh</span>
                                        </div>`;
                                    }
                                });
                                return html;
                            }
                        },
                        legend: { data: ['Tats√§chlich', 'Vorhersage'], textStyle: { color: '#94a3b8' }, top: 0 },
                        grid: { left: '3%', right: '4%', bottom: '12%', containLabel: true },
                        xAxis: {
                            type: 'category',
                            data: sorted.map(h => {
                                const d = h.target_date?.slice(5).replace('-', '.') || '';
                                return h.target_hour === 12 ? d : h.target_hour + 'h';
                            }),
                            axisLabel: { color: '#94a3b8', fontSize: 10, rotate: 0 },
                            axisLine: { lineStyle: { color: '#4a5568' } }
                        },
                        yAxis: {
                            type: 'value',
                            name: 'kWh',
                            nameTextStyle: { color: '#94a3b8' },
                            min: 0,
                            max: function(value) {
                                return Math.max(0.3, Math.ceil(value.max * 1.15 * 10) / 10);
                            },
                            axisLabel: { color: '#94a3b8' },
                            splitLine: { lineStyle: { color: '#1a1a3a' } }
                        },
                        series: [
                            {
                                name: 'Tats√§chlich',
                                type: 'bar',
                                data: sorted.map(h => h.actual_kwh != null ? h.actual_kwh : null),
                                itemStyle: { color: '#00ff88' },
                                barMaxWidth: 12,
                                markArea: {
                                    silent: true,
                                    itemStyle: { color: 'rgba(255,255,255,0.03)' },
                                    data: markAreas
                                }
                            },
                            {
                                name: 'Vorhersage',
                                type: 'line',
                                data: sorted.map(h => h.prediction_kwh),
                                smooth: true,
                                lineStyle: { color: '#3b82f6', width: 2 },
                                itemStyle: { color: '#3b82f6' },
                                symbol: 'none',
                                areaStyle: {
                                    color: {
                                        type: 'linear', x: 0, y: 0, x2: 0, y2: 1,
                                        colorStops: [
                                            { offset: 0, color: 'rgba(59, 130, 246, 0.2)' },
                                            { offset: 1, color: 'rgba(59, 130, 246, 0.02)' }
                                        ]
                                    }
                                }
                            }
                        ]
                    });
                }

                async function updatePowerSourcesPreviewChart() {
                    if (!charts.powerSourcesPreview) return;

                    try {
                        const response = await fetch('/api/sfml_stats/power_sources_history?hours=24');
                        const result = await response.json();

                        if (!result.success || !result.data) return;

                        // Filter auf heute (nur Daten ab Mitternacht)
                        const today = new Date();
                        today.setHours(0, 0, 0, 0);
                        const allData = result.data.filter(d => {
                            const dt = new Date(d.timestamp);
                            return dt >= today;
                        });

                        if (allData.length === 0) return;

                        // Filter auf Produktionszeitraum: nur Datenpunkte mit solar_power > 0
                        // oder alle Punkte zwischen erstem und letztem Produktionspunkt
                        let firstProductionIdx = allData.findIndex(d => (d.solar_power || 0) > 10);
                        let lastProductionIdx = allData.length - 1;
                        for (let i = allData.length - 1; i >= 0; i--) {
                            if ((allData[i].solar_power || 0) > 10) {
                                lastProductionIdx = i;
                                break;
                            }
                        }

                        // Wenn keine Produktion, zeige letzte 6 Stunden
                        if (firstProductionIdx === -1) {
                            firstProductionIdx = Math.max(0, allData.length - 72); // 6h bei 5min Intervall
                            lastProductionIdx = allData.length - 1;
                        }

                        // Etwas Puffer hinzuf√ºgen (30 min vor und nach)
                        firstProductionIdx = Math.max(0, firstProductionIdx - 6);
                        lastProductionIdx = Math.min(allData.length - 1, lastProductionIdx + 6);

                        const data = allData.slice(firstProductionIdx, lastProductionIdx + 1);

                        const timestamps = data.map(d => {
                            const dt = new Date(d.timestamp);
                            return dt.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
                        });
                        const solarPower = data.map(d => d.solar_power || 0);

                        charts.powerSourcesPreview.setOption({
                            tooltip: {
                                trigger: 'axis',
                                axisPointer: { type: 'line', lineStyle: { color: '#facc15' } },
                                backgroundColor: 'rgba(30, 30, 62, 0.95)',
                                borderColor: '#facc15',
                                textStyle: { color: '#fff' },
                                formatter: function(params) {
                                    var html = '<div style="font-weight:bold; margin-bottom:5px;">' + params[0].axisValue + '</div>';
                                    params.forEach(function(p) {
                                        html += '<div>' + p.marker + ' ' + p.seriesName + ': <b>' + Math.round(p.value || 0) + ' W</b></div>';
                                    });
                                    return html;
                                }
                            },
                            grid: { left: 50, right: 20, top: 15, bottom: 30 },
                            xAxis: {
                                type: 'category',
                                data: timestamps,
                                axisLabel: { color: '#64748b', fontSize: 9, interval: Math.floor(timestamps.length / 6) },
                                axisLine: { lineStyle: { color: '#404040' } }
                            },
                            yAxis: {
                                type: 'value',
                                name: 'W',
                                nameTextStyle: { color: '#94a3b8', fontSize: 10 },
                                axisLabel: { color: '#64748b', fontSize: 9 },
                                splitLine: { lineStyle: { color: '#303030' } }
                            },
                            series: [
                                {
                                    name: 'PV-Leistung',
                                    type: 'line',
                                    data: solarPower,
                                    itemStyle: { color: '#facc15' },
                                    lineStyle: { width: 2, color: '#facc15' },
                                    areaStyle: {
                                        color: {
                                            type: 'linear',
                                            x: 0, y: 0, x2: 0, y2: 1,
                                            colorStops: [
                                                { offset: 0, color: 'rgba(255, 183, 77, 0.6)' },
                                                { offset: 1, color: 'rgba(255, 183, 77, 0.1)' }
                                            ]
                                        }
                                    },
                                    showSymbol: false,
                                    smooth: true
                                }
                            ]
                        });
                    } catch (error) {
                        console.error('Error updating power sources preview:', error);
                    }
                }

                function updateTodayProductionChart(hourly, currentSolarPower) {
                    if (!charts.todayProduction) return;

                    const now = new Date();
                    const todayStr = now.getFullYear() + '-' +
                        String(now.getMonth() + 1).padStart(2, '0') + '-' +
                        String(now.getDate()).padStart(2, '0');
                    const currentHour = now.getHours();

                    // Filtere nur heute und sortiere nach Stunde
                    const todayData = hourly
                        .filter(h => h.target_date === todayStr)
                        .sort((a, b) => a.target_hour - b.target_hour);

                    const { startHour: START_HOUR, endHour: END_HOUR } = getProductionHourRange();

                    const hours = Array.from({length: END_HOUR - START_HOUR + 1}, (_, i) => i + START_HOUR);

                    // Tats√§chliche Produktion (kWh pro Stunde) - 0 f√ºr fehlende Stunden
                    const actualData = hours.map(h => {
                        const found = todayData.find(d => d.target_hour === h);
                        return found?.actual_kwh ?? 0;
                    });

                    // Vorhersage (kWh pro Stunde) - 0 f√ºr fehlende Stunden
                    const forecastData = hours.map(h => {
                        const found = todayData.find(d => d.target_hour === h);
                        return found?.prediction_kwh ?? 0;
                    });

                    // Aktuelle Leistung als Linie (W -> kW f√ºr Skalierung)
                    const powerData = hours.map(h => {
                        if (h === currentHour && currentSolarPower > 0) {
                            return (currentSolarPower / 1000).toFixed(2); // W -> kW
                        }
                        return null;
                    });

                    // Genauigkeit pro Stunde berechnen
                    const accuracyData = hours.map(h => {
                        const actual = actualData[h];
                        const pred = forecastData[h];
                        if (actual != null && pred != null && pred > 0) {
                            const deviation = Math.abs((actual - pred) / pred) * 100;
                            return Math.max(0, 100 - deviation);
                        }
                        return null;
                    });

                    charts.todayProduction.setOption({
                        backgroundColor: 'transparent',
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: '#1e1e3e',
                            borderColor: '#00ffff33',
                            textStyle: { color: '#e2e8f0' },
                            formatter: params => {
                                const hourIdx = params[0].dataIndex;
                                let result = `<b>${params[0].axisValue}</b><br/>`;
                                params.forEach(p => {
                                    if (p.value !== null && p.value !== undefined) {
                                        const unit = p.seriesName === 'Aktuell' ? 'kW' : 'kWh';
                                        result += `${p.marker} ${p.seriesName}: <b>${parseFloat(p.value).toFixed(3)} ${unit}</b><br/>`;
                                    }
                                });
                                // Genauigkeit hinzuf√ºgen wenn beide Werte vorhanden
                                const acc = accuracyData[hourIdx];
                                if (acc !== null) {
                                    const accColor = acc >= 80 ? '#00ff88' : acc >= 50 ? '#ffdd00' : '#ef4444';
                                    result += `<span style="color:${accColor}">üìä Genauigkeit: <b>${acc.toFixed(0)}%</b></span>`;
                                }
                                return result;
                            }
                        },
                        legend: { data: ['Tats√§chlich', 'Vorhersage', 'Aktuell'], textStyle: { color: '#94a3b8' }, top: 0 },
                        grid: { left: '3%', right: '4%', bottom: '3%', top: '12%', containLabel: true },
                        xAxis: {
                            type: 'category',
                            data: hours.map(h => h + ':00'),
                            axisLabel: { color: '#94a3b8', interval: 2 },
                            axisLine: { lineStyle: { color: '#1a1a3a' } }
                        },
                        yAxis: {
                            type: 'value',
                            min: 0,
                            axisLabel: { color: '#94a3b8', formatter: '{value} kWh' },
                            splitLine: { lineStyle: { color: '#1a1a3a' } }
                        },
                        series: [
                            {
                                name: 'Tats√§chlich',
                                type: 'line',
                                data: actualData,
                                smooth: true,
                                lineStyle: { color: '#00ff88', width: 3 },
                                itemStyle: { color: '#00ff88' },
                                symbol: 'circle',
                                symbolSize: 6,
                                areaStyle: {
                                    color: {
                                        type: 'linear', x: 0, y: 0, x2: 0, y2: 1,
                                        colorStops: [
                                            { offset: 0, color: 'rgba(0, 255, 136, 0.4)' },
                                            { offset: 1, color: 'rgba(0, 255, 136, 0.05)' }
                                        ]
                                    }
                                }
                            },
                            {
                                name: 'Vorhersage',
                                type: 'line',
                                data: forecastData,
                                smooth: true,
                                lineStyle: { color: '#8b5cf6', width: 2, type: 'dashed' },
                                itemStyle: { color: '#8b5cf6' },
                                symbol: 'none',
                                areaStyle: {
                                    color: {
                                        type: 'linear', x: 0, y: 0, x2: 0, y2: 1,
                                        colorStops: [
                                            { offset: 0, color: 'rgba(139, 92, 246, 0.2)' },
                                            { offset: 1, color: 'rgba(139, 92, 246, 0)' }
                                        ]
                                    }
                                }
                            },
                            {
                                name: 'Aktuell',
                                type: 'scatter',
                                data: powerData,
                                symbolSize: 15,
                                itemStyle: {
                                    color: '#ffdd00',
                                    shadowBlur: 10,
                                    shadowColor: 'rgba(255, 221, 0, 0.5)'
                                }
                            }
                        ],
                        // Markierung f√ºr aktuelle Stunde
                        markLine: {
                            silent: true,
                            data: [{ xAxis: currentHour }],
                            lineStyle: { color: '#ffdd00', width: 2, type: 'solid' },
                            label: { show: false }
                        }
                    });
                }

                // ===== PANEL-GRUPPEN CHART-FUNKTION =====

                function updatePanelGroupCharts() {
                    if (!panelGroups.available || !panelGroups.groups) return;

                    const { startHour: START_HOUR, endHour: END_HOUR } = getProductionHourRange();

                    const hours = Array.from({length: END_HOUR - START_HOUR + 1}, (_, i) => i + START_HOUR);

                    // F√ºr jede Panel-Gruppe einen Chart erstellen/aktualisieren
                    for (const [groupName, groupData] of Object.entries(panelGroups.groups)) {
                        const chartEl = panelGroupChartRefs[groupName];
                        if (!chartEl) continue;

                        // Chart initialisieren falls n√∂tig
                        if (!panelGroupCharts[groupName]) {
                            panelGroupCharts[groupName] = echarts.init(chartEl);
                        }

                        const chart = panelGroupCharts[groupName];
                        const hourlyData = groupData.hourly || [];

                        // Erstelle Arrays nur f√ºr Produktionszeit
                        const actualData = hours.map(h => {
                            const found = hourlyData.find(d => d.hour === h);
                            return found?.actual_kwh ?? 0;
                        });
                        const forecastData = hours.map(h => {
                            const found = hourlyData.find(d => d.hour === h);
                            return found?.prediction_kwh ?? 0;
                        });

                        chart.setOption({
                            backgroundColor: 'transparent',
                            tooltip: {
                                trigger: 'axis',
                                backgroundColor: '#1e1e3e',
                                borderColor: '#00ffff33',
                                textStyle: { color: '#e2e8f0' }
                            },
                            legend: { data: ['IST', 'Prognose'], textStyle: { color: '#94a3b8' }, top: 0 },
                            grid: { left: '3%', right: '4%', bottom: '3%', top: '15%', containLabel: true },
                            xAxis: {
                                type: 'category',
                                data: hours.map(h => h + ':00'),
                                axisLabel: { color: '#94a3b8', interval: 3, fontSize: 10 },
                                axisLine: { lineStyle: { color: '#1a1a3a' } }
                            },
                            yAxis: {
                                type: 'value',
                                name: 'kWh',
                                nameTextStyle: { color: '#94a3b8' },
                                axisLabel: { color: '#94a3b8', formatter: v => v.toFixed(3) },
                                splitLine: { lineStyle: { color: '#1a1a3a' } }
                            },
                            series: [
                                {
                                    name: 'IST',
                                    type: 'line',
                                    data: actualData,
                                    smooth: true,
                                    lineStyle: { color: '#00ff88', width: 3 },
                                    itemStyle: { color: '#00ff88' },
                                    symbol: 'circle',
                                    symbolSize: 6,
                                    areaStyle: {
                                        color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                            { offset: 0, color: 'rgba(0, 255, 136, 0.4)' },
                                            { offset: 1, color: 'rgba(0, 255, 136, 0.05)' }
                                        ])
                                    }
                                },
                                {
                                    name: 'Prognose',
                                    type: 'line',
                                    data: forecastData,
                                    smooth: true,
                                    lineStyle: { color: '#8b5cf6', width: 2, type: 'dashed' },
                                    itemStyle: { color: '#8b5cf6' },
                                    symbol: 'none'
                                }
                            ]
                        });
                    }
                }

                // ===== ERWEITERTE CHART-FUNKTIONEN =====

                function updateExtendedCharts(history, astronomy, statistics) {
                    // Sortiere History chronologisch
                    const sorted = [...history].sort((a, b) => new Date(a.date) - new Date(b.date));
                    const last30 = sorted.slice(-30);

                    // Stats berechnen
                    if (last30.length > 0) {
                        historyStats.avgProduction = last30.reduce((s, d) => s + (d.actual_kwh || 0), 0) / last30.length;
                        historyStats.avgForecast = last30.reduce((s, d) => s + (d.predicted_kwh || 0), 0) / last30.length;
                        historyStats.avgAccuracy = Math.min(100, last30.filter(d => d.accuracy > 0).reduce((s, d, _, a) => s + Math.min(100, d.accuracy) / a.length, 0));
                        historyStats.totalProduction = sorted.reduce((s, d) => s + (d.actual_kwh || 0), 0);
                        historyStats.monthPeak = Math.max(...last30.map(d => d.peak_power_w || 0));
                        historyStats.allTimePeak = statistics?.all_time_peak?.power_w || historyStats.monthPeak;
                    }

                    updateTrendChart(last30);
                    updateMonthlyChart(sorted);
                }

                // Chart 1: Langzeit-Trend (30 Tage)
                function updateTrendChart(data) {
                    if (!charts.trend) return;
                    const dates = data.map(d => d.date.slice(5)); // MM-DD
                    const actual = data.map(d => d.actual_kwh || 0);
                    const predicted = data.map(d => d.predicted_kwh || 0);

                    charts.trend.setOption({
                        backgroundColor: 'transparent',
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: '#1e1e3e',
                            borderColor: '#00ffff33',
                            textStyle: { color: '#e2e8f0' }
                        },
                        legend: { data: ['Produktion', 'Prognose'], textStyle: { color: '#94a3b8' }, top: 0 },
                        grid: { left: '3%', right: '4%', bottom: '10%', top: '15%', containLabel: true },
                        xAxis: {
                            type: 'category',
                            data: dates,
                            axisLabel: { color: '#94a3b8', rotate: 45, interval: 2 }
                        },
                        yAxis: {
                            type: 'value',
                            axisLabel: { color: '#94a3b8', formatter: '{value} kWh' },
                            splitLine: { lineStyle: { color: '#1a1a3a' } }
                        },
                        series: [
                            {
                                name: 'Produktion',
                                type: 'line',
                                data: actual,
                                smooth: true,
                                lineStyle: { color: '#00ff88', width: 3 },
                                itemStyle: { color: '#00ff88' },
                                areaStyle: {
                                    color: { type: 'linear', x: 0, y: 0, x2: 0, y2: 1,
                                        colorStops: [{ offset: 0, color: 'rgba(0, 255, 136, 0.4)' }, { offset: 1, color: 'rgba(0, 255, 136, 0)' }]
                                    }
                                }
                            },
                            {
                                name: 'Prognose',
                                type: 'line',
                                data: predicted,
                                smooth: true,
                                lineStyle: { color: '#8b5cf6', width: 2, type: 'dashed' },
                                itemStyle: { color: '#8b5cf6' }
                            }
                        ]
                    });
                }

                // Monats-Vergleich Chart
                function updateMonthlyChart(data) {
                    if (!charts.monthly) return;

                    // Gruppiere nach Monat
                    const monthly = {};
                    data.forEach(d => {
                        const month = d.date.slice(0, 7); // YYYY-MM
                        if (!monthly[month]) monthly[month] = { production: 0, forecast: 0, days: 0 };
                        monthly[month].production += d.actual_kwh || 0;
                        monthly[month].forecast += d.predicted_kwh || 0;
                        monthly[month].days++;
                    });

                    const months = Object.keys(monthly).sort();
                    const monthNames = months.map(m => {
                        const [y, mo] = m.split('-');
                        return ['Jan','Feb','M√§r','Apr','Mai','Jun','Jul','Aug','Sep','Okt','Nov','Dez'][parseInt(mo)-1] + ' ' + y.slice(2);
                    });
                    const production = months.map(m => monthly[m].production.toFixed(1));
                    const forecast = months.map(m => monthly[m].forecast.toFixed(1));

                    charts.monthly.setOption({
                        backgroundColor: 'transparent',
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: '#1e1e3e',
                            borderColor: '#00ffff33',
                            textStyle: { color: '#e2e8f0' }
                        },
                        legend: { data: ['Produktion', 'Prognose'], textStyle: { color: '#94a3b8' }, top: 0 },
                        grid: { left: '3%', right: '4%', bottom: '3%', top: '15%', containLabel: true },
                        xAxis: {
                            type: 'category',
                            data: monthNames,
                            axisLabel: { color: '#94a3b8' }
                        },
                        yAxis: {
                            type: 'value',
                            axisLabel: { color: '#94a3b8', formatter: '{value} kWh' },
                            splitLine: { lineStyle: { color: '#1a1a3a' } }
                        },
                        series: [
                            {
                                name: 'Produktion',
                                type: 'bar',
                                data: production,
                                itemStyle: { color: '#00ff88', borderRadius: [4, 4, 0, 0] }
                            },
                            {
                                name: 'Prognose',
                                type: 'bar',
                                data: forecast,
                                itemStyle: { color: '#3b82f6', borderRadius: [4, 4, 0, 0] }
                            }
                        ]
                    });
                }


                // Debounced resize handler
                let _resizeTimer;
                function _resizeAllCharts() {
                    Object.values(charts).forEach(c => c?.resize());
                    [batterySOCChart, batteryChargeChart, batteryEfficiencyChart, batteryPowerChart,
                     houseConsumptionChart, houseAutarkyChart, houseSourcesChart, housePeakChart,
                     gridFlowChart, gridPriceChart, gridMoneyChart, gridPatternChart,
                     solarProductionChart, solarHeatmapChart, solarAccuracyChart, solarPanelGroupChart,
                     weatherTempChart, weatherRadiationChart, weatherRainChart, weatherWindChart,
                     weatherTempComparisonChart, weatherRadiationComparisonChart, weatherCloudsComparisonChart, weatherAccuracyChart,
                     powerSourcesMainChart, powerSourcesSOCChart, powerSourcesPieChart,
                     consumerBarChart, forecastComparisonChart
                    ].forEach(c => c.value?.resize());
                    Object.values(panelGroupCharts).forEach(c => c?.resize());
                }

                // Visibility-based polling: 5s active, 30s background
                let _pollInterval = 5000;
                let interval;
                function _startPolling() {
                    clearInterval(interval);
                    interval = setInterval(fetchData, _pollInterval);
                }

                onMounted(() => {
                    initCharts();
                    fetchBillingData();
                    fetchData();
                    setTimeout(() => updatePowerSourcesPreviewChart(), 1500);
                    loadAIStatus();
                    _startPolling();
                    window.addEventListener('resize', () => {
                        clearTimeout(_resizeTimer);
                        _resizeTimer = setTimeout(_resizeAllCharts, 200);
                    });
                    document.addEventListener('visibilitychange', () => {
                        if (document.hidden) {
                            _pollInterval = 30000;
                        } else {
                            _pollInterval = 5000;
                            fetchData(); // Sofort aktualisieren wenn Tab wieder sichtbar
                        }
                        _startPolling();
                    });
                    setTimeout(() => {
                        initSortable();
                        initDragHoldFeedback();
                    }, 500);
                });
                onUnmounted(() => {
                    clearInterval(interval);
                    Object.values(charts).forEach(c => c?.dispose());
                });

                return {
                    lastUpdate, isDarkTheme, toggleTheme, dashboardStyle, toggleDashboardStyle, hasBattery, isNightTime,
                    getDashboardStyleIcon, getDashboardStyleLabel, goToLcars,
                    collapsedSections, toggleSection, isSectionCollapsed,
                    sortableContainer, resetSectionOrder,
                    panelGroupsValidation, hasSinglePanelGroup,
                    weather, weatherCorrected, weatherHA, weatherIcon, weatherCondition, weatherHAIcon, live, forecast, kpis,
                    productionChart, priceChart, timelineChart, todayProductionChart, accuracyChart,
                    trendChart, monthlyChart,
                    energyFlow, stats, getGridPower, getGridLabel, formatTime,
                    productionTime, sunTimes, formatTimeShort, formatDuration,
                    priceStats, priceStatsTomorrow, sunPosition, bestHour, currentPrice,
                    todayAccuracy, historyStats, energyBalance,
                    panelGroups, panelGroupChartRefs,
                    panelGroupModal, openPanelGroupModal, closePanelGroupModal, getPanelGroupDeviation, getPanelGroupHourlyData,
                    productionTodayModal, openProductionTodayModal, closeProductionTodayModal, getProductionTodayDeviation, getProductionTodayHourlyData,
                    solarModal, openSolarModal, closeSolarModal, exportSolarAnalytics,
                    batteryModal, openBatteryModal, closeBatteryModal, exportBatteryAnalytics,
                    houseModal, openHouseModal, closeHouseModal, exportHouseAnalytics,
                    gridModal, openGridModal, closeGridModal, exportGridAnalytics,
                    consumerModal, openConsumerModal, closeConsumerModal,
                    weatherModal, openWeatherModal, closeWeatherModal, exportWeatherAnalytics,
                    powerSourcesModal, openPowerSourcesModal, closePowerSourcesModal, exportPowerSourcesAnalytics, changePowerSourcesTab, loadPowerSourcesCustomRange,
                    clothingModal, openClothingModal, closeClothingModal,
                    forecastComparisonModal, openForecastComparisonModal, closeForecastComparisonModal,
                    shadowModal, openShadowAnalyticsModal, closeShadowAnalyticsModal,
                    aiStatus
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
