- id: heating_plan_every_5min
  alias: "Heizung: Planung alle 5 Minuten (PV/Preheat/Phasen)"
  mode: single
  trigger:
    - platform: time_pattern
      minutes: "/5"
  variables:
    # ===================================================================
    # SECTION 1: CONFIGURATION & GLOBAL PARAMETERS
    # ===================================================================
    rooms_json: '["bad","kueche","schlafzimmer","flur","speisekammer","wohnzimmer","buero_merja","buero_fabian"]'
    phase_max_amps: 16.0
    hysteresis_k: 0.05
    stop_margin_k: 0.1   # früher ausmachen, um Overshoot zu reduzieren
    
    # PV and preheat parameters
    pv_forecast_w: "{{ states('sensor.filtered_exported_power_w') | float(0) }}"
    pv_thr_w: "{{ states('input_number.pv_excess_threshold_w') | float(0) }}"
    has_pv_excess: "{{ pv_forecast_w > pv_thr_w }}"
    pv_offset_k: "{{ 0.5 if has_pv_excess else 0 }}"

    # PV-/Top-Up-Fenster: nur mittags 12–14 Uhr & nur wenn PV-Überschuss
    is_midday_topup_window: >-
      {% set nowts = as_timestamp(now()) %}
      {% set t0 = as_timestamp(now().replace(hour=12, minute=0, second=0, microsecond=0)) %}
      {% set t1 = as_timestamp(now().replace(hour=14, minute=0, second=0, microsecond=0)) %}
      {{ t0 <= nowts < t1 }}

    # Preheat-Fenster 00–06 Uhr (Preis egal)
    is_preheat_window: >-
      {% set nowts = as_timestamp(now()) %}
      {% set t0 = as_timestamp(now().replace(hour=0, minute=0, second=0, microsecond=0)) %}
      {% set t1 = as_timestamp(now().replace(hour=6, minute=0, second=0, microsecond=0)) %}
      {{ t0 <= nowts < t1 }}
    
    # Heating blocking: When enabled, only allow heating during preheat window (00:00-06:00)
    # Turn this switch ON to block heating outside preheat window
    heating_block_enabled: "{{ is_state('input_boolean.heating_block_daytime', 'on') or is_state('binary_sensor.preheat_erlaubt_demand_weighted', 'off') }}"
    
    C_eff: "{{ states('sensor.C_kWh_per_K_rolling') | float(10) }}"
    H_eff: "{{ states('sensor.H_kW_per_K_effective') | float(6.25) }}"
    dT_forecast: "{{ states('input_number.delta_t_forecast_k') | float(0) }}"
    
    # --- Preheat goal (room-specific) ---
    preheat_end_hour: 6          # preheat window ends 06:00
    target_hour: 22              # want condition at 22:00
    target_below_base_k: 0.3     # at 22:00: base - 0.3K
    max_total_offset_k: 1.0      # <= 1K above each room's base (includes PV + preheat)

    # Outside avg estimate for 06:00–22:00 (hourly forecast if available,
    # else daily high/low average, else current outside temp)
    outside_avg_6_22_c: >-
      {% set current_outside = states('sensor.outside_temperature') | float(0) %}
      {% set forecast_attr = state_attr('weather.home', 'forecast') %}
      {% set t0 = as_timestamp(now().replace(hour=6, minute=0, second=0, microsecond=0)) %}
      {% set t1 = as_timestamp(now().replace(hour=22, minute=0, second=0, microsecond=0)) %}
      {% set ns = namespace(sum=0.0, n=0) %}
      {% if forecast_attr is iterable %}
        {# Try hourly points: forecast items with datetime + temperature #}
        {% for p in forecast_attr %}
          {% if p.datetime is defined and p.temperature is defined %}
            {% set ts = as_timestamp(p.datetime) %}
            {% if ts is number and t0 <= ts < t1 %}
              {% set ns.sum = ns.sum + (p.temperature | float(0)) %}
              {% set ns.n = ns.n + 1 %}
            {% endif %}
          {% endif %}
        {% endfor %}
        {% if ns.n > 0 %}
          {{ ns.sum / ns.n }}
        {% else %}
          {# Fallback: daily high/low average on first forecast item #}
          {% set first = forecast_attr | first %}
          {% if first is mapping and first.temperature is defined and first.templow is defined %}
            {{ ((first.temperature | float(0)) + (first.templow | float(0))) / 2.0 }}
          {% else %}
            {{ current_outside }}
          {% endif %}
        {% endif %}
      {% else %}
        {{ current_outside }}
      {% endif %}

    # ===== Tibber Preisfenster =====
    # Anteil des Tagesmax, der "billig" ist (z.B. 0.10 = unter 10% des Max-Preises)
    price_pct_of_max: "{{ states('input_number.price_percentile_cutoff')|float(0.10) }}"
    current_price_eur: "{{ states('sensor.backerstrasse_3b_strompreis')|float(99) }}"
    
    # ===================================================================
    # SECTION 2: COMPREHENSIVE ROOM DATA (Single Pass)
    # ===================================================================
    # Build all room data in one pass - no JSON parsing needed!
    room_data: >-
      {% set rooms = rooms_json | from_json(default=[]) %}
      {% set hyst = hysteresis_k | float(0.05) %}
      {% set invalid_states = ['unknown', 'unavailable', 'None', ''] %}
      {% set ns = namespace(rooms = {}) %}
      
      {% for room in rooms %}
        {% set climate_entity = 'climate.climate_room_' ~ room %}
        {% set sensor_l1 = 'sensor.current_l1_' ~ room ~ '_current' %}
        {% set sensor_l2 = 'sensor.current_l2_' ~ room ~ '_current' %}
        {% set sensor_l3 = 'sensor.current_l3_' ~ room ~ '_current' %}

        {# Read temperatures #}
        {% set current_temp = state_attr(climate_entity, 'current_temperature') %}
        {% set current_setpoint = state_attr(climate_entity, 'temperature') %}
        
        {# Get base temperature from helper, or use current setpoint if helper doesn't exist #}
        {# This prevents offset accumulation by always using the original base temperature #}
        {% set base_helper = 'input_number.heating_base_' ~ room %}
        {% set stored_base = states(base_helper) | float(0) %}
        {% if stored_base > 0 %}
          {# Use stored base temperature (original, before any offsets) #}
          {% set base_target = stored_base %}
        {% elif current_setpoint is number %}
          {# No stored base yet, use current setpoint as base (will be stored when offset is first applied) #}
          {% set base_target = current_setpoint | float %}
        {% else %}
          {# Fallback default #}
          {% set base_target = 22.0 %}
        {% endif %}
        
        {% if current_temp is number %}
          {% set current = current_temp | float %}
        {% else %}
          {% set current = 22.0 %}
        {% endif %}
        
        {% set pv_off = pv_offset_k | float(0) %}
        {% set cap = max_total_offset_k | float(1.0) %}
        {% set margin = target_below_base_k | float(0.3) %}
        {% set dt = ((target_hour | float(22)) - (preheat_end_hour | float(6))) %}
        {% set C = C_eff | float(0) %}
        {% set H = H_eff | float(0) %}
        {% set T_out = outside_avg_6_22_c | float(states('sensor.outside_temperature') | float(0)) %}

        {% set preheat_off = 0.0 %}
        {% if is_preheat_window and C > 0 and H > 0 and dt > 0 and heating_block_enabled %}
          {% set k = H / C %}
          {% set f = 2.718281828 ** (-(k * dt)) %}
          {% if f < 0.05 %}{% set f = 0.05 %}{% endif %} {# numerical safety #}
          {% set D_base = (base_target - T_out) * (1 - f) %}
          {% set raw = (D_base - margin) / f %}
          {% if raw > 0 %}{% set preheat_off = raw %}{% else %}{% set preheat_off = 0.0 %}{% endif %}
        {% endif %}

        {% set room_offset = preheat_off + pv_off %}
        {% if room_offset > cap %}{% set room_offset = cap %}{% endif %}
        {% if room_offset < 0 %}{% set room_offset = 0 %}{% endif %}

        {% set effective_target = base_target + room_offset %}
        {% set error = effective_target - current %}
        
        {# Determine phase #}
        {% set phase = 0 %}
        {% if states(sensor_l1) not in invalid_states %}
          {% set phase = 1 %}
        {% elif states(sensor_l2) not in invalid_states %}
          {% set phase = 2 %}
        {% elif states(sensor_l3) not in invalid_states %}
          {% set phase = 3 %}
        {% endif %}
        
        {# Get current consumption #}
        {% set live_current_ma = 0 %}
        {% if states(sensor_l1) not in invalid_states %}
          {% set live_current_ma = states(sensor_l1) | float(0) %}
        {% elif states(sensor_l2) not in invalid_states %}
          {% set live_current_ma = states(sensor_l2) | float(0) %}
        {% elif states(sensor_l3) not in invalid_states %}
          {% set live_current_ma = states(sensor_l3) | float(0) %}
        {% endif %}
        {% if live_current_ma > 0 %}
          {% set live_current_a = live_current_ma / 1000 %}
        {% else %}
          {% set live_current_a = 0 %}
        {% endif %}
        {% set sql_current_a = states('sensor.heater_' ~ room ~ '_max_current_a') | float(0) %}
        {% set rated_current_a = states('input_number.heater_' ~ room ~ '_rated_a') | float(0) %}
        {% if live_current_a > 0 %}
          {% set amps = live_current_a %}
        {% elif sql_current_a > 0 %}
          {% set amps = sql_current_a %}
        {% else %}
          {% set amps = rated_current_a %}
        {% endif %}
        
        {# Determine if heating is needed #}
        {# --- is_heating (robust) --- #}
        {% set st = states(climate_entity) %}
        {% set is_heating = (st == 'heat') %}

        {# --- Safety band --- #}
        {% set lower_safety_band_k = 1.5 %}
        {% set sp_eff = effective_target %}
        {% set sp_now = (state_attr(climate_entity,'temperature')
                          if state_attr(climate_entity,'temperature') is number
                          else sp_eff) | float(sp_eff) %}
        {# start condition for safety: at/below setpoint - lower_band #}
        {% set must_heat_start = current <= (sp_now - lower_safety_band_k) %}

        {# --- Start/Stop thresholds (normal) --- #}
        {% set stop_margin = stop_margin_k | float(0.1) %}
        {% set stop_th  = effective_target - stop_margin %}
        {% set start_th = stop_th - (hysteresis_k | float(0.05)) %}

        {# --- Safety stop threshold: setpoint - lower_band + stop_margin --- #}
        {% set safety_stop_th = (sp_now - lower_safety_band_k + stop_margin) %}

        {# --- Cooldown check --- #}
        {% set cd_ent = 'input_datetime.heating_cooldown_until_' ~ room %}
        {% set cd_state = states(cd_ent) %}
        {% set cd_ts = as_timestamp(cd_state) if cd_state not in invalid_states else 0 %}
        {% set nowts = as_timestamp(now()) %}
        {% set cooldown_ok = (cd_ts == 0) or (nowts >= cd_ts) %}

        {# --- Decision
             - If OFF: may start on (normal start) OR (safety start), both respect cooldown
             - If ON and we're currently in safety range: only continue up to safety_stop_th
             - If ON and not in safety range: use normal stop_th
        --- #}
        {% if is_heating %}
          {% if must_heat_start %}
            {# running from safety band -> cap at setpoint - lower + stop_margin #}
            {% set needs_heating = (current < safety_stop_th) %}
          {% else %}
            {# normal run #}
            {% set needs_heating = (current < stop_th) %}
          {% endif %}
        {% else %}
          {% set needs_heating = cooldown_ok and ((current < start_th) or must_heat_start) %}
        {% endif %}

        {# Build room data structure #}
        {% set ns.rooms = ns.rooms | combine({
          room: ns.rooms.get(room, {}) | combine({
            'entity': climate_entity,
            'current_temp': current,
            'base_target': base_target,
            'effective_target': effective_target,
            'offset': room_offset,
            'preheat_offset': preheat_off,
            'pv_offset': pv_off,
            'error': error,
            'phase': phase,
            'amps': amps,
            'needs_heating': needs_heating,
            'must_heat': must_heat_start
          })
        }) %}
      {% endfor %}
      {{ (ns.rooms | tojson) | string }}
    
    # ===================================================================
    # SECTION 3: ROOM SELECTION BY PHASE
    # ===================================================================
    # Select rooms for each phase using greedy algorithm
    sel_p1: >-
      {% set rooms_data = room_data | from_json(default={}) %}
      {% set all_rooms = rooms_json | from_json(default=[]) %}
      {% set max_amps = phase_max_amps | float(16.0) %}
      {% set ns = namespace(room_list = [], selected = []) %}
      {% for room in all_rooms %}
        {% if rooms_data[room] is defined %}
          {% set d = rooms_data[room] %}
          {% if d.phase == 1 and d.needs_heating %}
            {% set score = (1000 if d.must_heat else 0) + (d.error | float(0)) %}
            {% set ns.room_list = ns.room_list + [{'room': room, 'amps': d.amps, 'score': score}] %}
          {% endif %}
        {% endif %}
      {% endfor %}
      {% set sorted = ns.room_list | sort(attribute='score', reverse=True) %}
      {% set total = 0.0 %}
      {% for item in sorted %}
        {% set a = item.amps | float(0) %}
        {% if total + a <= max_amps %}
          {% set total = total + a %}
          {% set ns.selected = ns.selected + [item.room] %}
        {% endif %}
      {% endfor %}
      {{ (ns.selected | tojson) | string }}
    
    sel_p2: >-
      {% set rooms_data = room_data | from_json(default={}) %}
      {% set all_rooms = rooms_json | from_json(default=[]) %}
      {% set max_amps = phase_max_amps | float(16.0) %}
      {% set ns = namespace(room_list = [], selected = []) %}
      {% for room in all_rooms %}
        {% if rooms_data[room] is defined %}
          {% set d = rooms_data[room] %}
          {% if d.phase == 2 and d.needs_heating %}
            {% set score = (1000 if d.must_heat else 0) + (d.error | float(0)) %}
            {% set ns.room_list = ns.room_list + [{'room': room, 'amps': d.amps, 'score': score}] %}
          {% endif %}
        {% endif %}
      {% endfor %}
      {% set sorted = ns.room_list | sort(attribute='score', reverse=True) %}
      {% set total = 0.0 %}
      {% for item in sorted %}
        {% set a = item.amps | float(0) %}
        {% if total + a <= max_amps %}
          {% set total = total + a %}
          {% set ns.selected = ns.selected + [item.room] %}
        {% endif %}
      {% endfor %}
      {{ (ns.selected | tojson) | string }}
    
    sel_p3: >-
      {% set rooms_data = room_data | from_json(default={}) %}
      {% set all_rooms = rooms_json | from_json(default=[]) %}
      {% set max_amps = phase_max_amps | float(16.0) %}
      {% set ns = namespace(room_list = [], selected = []) %}
      {% for room in all_rooms %}
        {% if rooms_data[room] is defined %}
          {% set d = rooms_data[room] %}
          {% if d.phase == 3 and d.needs_heating %}
            {% set score = (1000 if d.must_heat else 0) + (d.error | float(0)) %}
            {% set ns.room_list = ns.room_list + [{'room': room, 'amps': d.amps, 'score': score}] %}
          {% endif %}
        {% endif %}
      {% endfor %}
      {% set sorted = ns.room_list | sort(attribute='score', reverse=True) %}
      {% set total = 0.0 %}
      {% for item in sorted %}
        {% set a = item.amps | float(0) %}
        {% if total + a <= max_amps %}
          {% set total = total + a %}
          {% set ns.selected = ns.selected + [item.room] %}
        {% endif %}
      {% endfor %}
      {{ (ns.selected | tojson) | string }}
    
    # ===================================================================
    # SECTION 4: CLIMATE ENTITY MAPPING (for debug output)
    # ===================================================================
    climates_on: >-
      {% set rooms_data = room_data | from_json(default={}) %}
      {% set max_amps = phase_max_amps | float(16.0) %}
      {% set ns = namespace(selected_rooms = [], climates = []) %}
      {% for phase_num in [1, 2, 3] %}
        {% set ns.room_list = [] %}
        {% for room, data in rooms_data.items() %}
          {% if data.phase == phase_num and data.needs_heating %}
            {% set ns.room_list = ns.room_list + [{'room': room, 'error': data.error, 'amps': data.amps}] %}
          {% endif %}
        {% endfor %}
        {% set sorted = ns.room_list | sort(attribute='error', reverse=True) %}
        {% set total = 0.0 %}
        {% for item in sorted %}
          {% if total + item.amps <= max_amps %}
            {% set total = total + item.amps %}
            {% if item.room not in ns.selected_rooms %}
              {% set ns.selected_rooms = ns.selected_rooms + [item.room] %}
            {% endif %}
          {% endif %}
        {% endfor %}
      {% endfor %}
      {% for room in ns.selected_rooms %}
        {% set ns.climates = ns.climates + ['climate.climate_room_' ~ room] %}
      {% endfor %}
      {{ (ns.climates | tojson) | string }}
    
    climates_off: >-
      {% set rooms_data = room_data | from_json(default={}) %}
      {% set max_amps = phase_max_amps | float(16.0) %}
      {% set all_rooms = rooms_json | from_json(default=[]) %}
      {% set ns = namespace(selected_rooms = [], climates = []) %}
      {% for phase_num in [1, 2, 3] %}
        {% set ns.room_list = [] %}
        {% for room, data in rooms_data.items() %}
          {% if data.phase == phase_num and data.needs_heating %}
            {% set ns.room_list = ns.room_list + [{'room': room, 'error': data.error, 'amps': data.amps}] %}
          {% endif %}
        {% endfor %}
        {% set sorted = ns.room_list | sort(attribute='error', reverse=True) %}
        {% set total = 0.0 %}
        {% for item in sorted %}
          {% if total + item.amps <= max_amps %}
            {% set total = total + item.amps %}
            {% if item.room not in ns.selected_rooms %}
              {% set ns.selected_rooms = ns.selected_rooms + [item.room] %}
            {% endif %}
          {% endif %}
        {% endfor %}
      {% endfor %}
      {% for room in all_rooms %}
        {% if room not in ns.selected_rooms %}
          {% set ns.climates = ns.climates + ['climate.climate_room_' ~ room] %}
        {% endif %}
      {% endfor %}
      {{ (ns.climates | tojson) | string }}
  
  condition: []
  action:
    # 1) Tagespreise laden
    - service: tibber.get_prices
      data:
        start: "{{ now().strftime('%Y-%m-%d %H:00:00') }}"
        end:   "{{ (now() + timedelta(hours=24)).strftime('%Y-%m-%d %H:00:00') }}"
      response_variable: tibber_resp

    # 2) Preis-Gate bestimmen (robuste Extraktion + Perzentil, ohne from_json)
    - variables:
        # 2.1 Rohdaten -> einheitliches Array [{price: ..., start_time: ...}, ...]
        tib_prices_arr: >-
          {% set raw = tibber_resp %}
          {% set arr = [] %}
          {% if raw is mapping and 'prices' in raw and (raw['prices'] is mapping) %}
            {% set first_key = (raw['prices'].keys() | list | first) %}
            {% if first_key %}
              {% set arr = raw['prices'][first_key] %}
            {% endif %}
          {% elif raw is sequence %}
            {% set arr = raw %}
          {% endif %}
          {{ arr }}

        # 2.2 Perzentil-Schwelle (unteres x-Perzentil des Tages)
        price_quantile_thr: >-
          {% set items = tib_prices_arr if tib_prices_arr is sequence else [] %}
          {% set prices = items | map(attribute='price') | select('number') | list %}
          {% if prices | length == 0 %}
            {{ none }}
          {% else %}
            {# Eingabe kann 0–1 oder 0–100 sein #}
            {% set p = states('input_number.price_percentile_cutoff') | float(0.10) %}
            {% if p > 1 %}{% set p = p / 100 %}{% endif %}
            {% set p = 0 if p < 0 else (1 if p > 1 else p) %}
            {% set sorted = prices | sort %}
            {% set idx = ((sorted | length - 1) * p) | round(0, 'floor') %}
            {{ sorted[idx] }}
          {% endif %}

        # 2.3 Ist der aktuelle Preis günstig?
        price_is_cheap_now: >-
          {% if price_quantile_thr is number %}
            {{ states('sensor.backerstrasse_3b_strompreis') | float(999) <= price_quantile_thr }}
          {% else %}
            {{ is_state('input_boolean.heating_ignore_price','on') }}
          {% endif %}

        # Optional: kompaktes Preis-Debug fürs Log
        price_debug: >-
          {% set items = tib_prices_arr if tib_prices_arr is sequence else [] %}
          {% set prs = items | map(attribute='price') | select('number') | list %}
          {% if prs | length == 0 %}
            {{ {'n': 0} | tojson }}
          {% else %}
            {{ {'n': prs|length, 'min': (prs|min), 'max': (prs|max), 'thr': price_quantile_thr} | tojson }}
          {% endif %}

    # 2b) Pmax/Threshold in Helper schreiben (für die UI-Sichtkontrolle)
    - variables:
        pmax_eur: >-
          {% set items = tib_prices_arr if tib_prices_arr is sequence else [] %}
          {% set prices = items | map(attribute='price') | select('number') | list %}
          {{ (prices|max) if prices|length else 0 }}
        thr_eur: >-
          {# UI-Helper soll am besten das echte Quantil zeigen, nicht pmax*pct #}
          {{ price_quantile_thr if price_quantile_thr is number else 0 }}

    - service: input_number.set_value
      target: { entity_id: input_number.tibber_pmax_today }
      data:
        value: "{{ pmax_eur|float(0) }}"

    - service: input_number.set_value
      target: { entity_id: input_number.tibber_threshold_today }
      data:
        value: "{{ thr_eur|float(0) }}"

    # 3) Endgültiges Heizerlaubnis
    - variables:
        # tagsüber nur, wenn (Preis günstig) ODER (12–14 & PV-Excess)
        allow_daytime_heat: >-
          {% set topup_ok = (is_midday_topup_window and has_pv_excess) %}
          {{ price_is_cheap_now or topup_ok }}
        heating_allowed_now: >-
          {{ is_preheat_window or (not heating_block_enabled and allow_daytime_heat) }}
    # ===================================================================
    # ACTION 1: Update temperature setpoints based on offset (always executed)
    # ===================================================================
    # Store base temperatures and apply/reset offsets (always, regardless of blocking)
    - repeat:
        for_each: "{{ rooms_json | from_json(default=[]) }}"
        sequence:
          - choose:
              # If offset is active: Store base temp (if not stored) and apply offset
              - conditions:
                  - condition: template
                    value_template: >-
                      {% set rd = room_data | from_json(default={}) %}
                      {{ (rd[repeat.item].offset | float(0)) > 0 }}
                sequence:
                  - service: input_number.set_value
                    target:
                      entity_id: "input_number.heating_base_{{ repeat.item }}"
                    data:
                      value: >-
                        {% set base_helper = 'input_number.heating_base_' ~ repeat.item %}
                        {% set stored_base = states(base_helper) | float(0) %}
                        {% set rooms_data = room_data | from_json(default={}) %}
                        {% if stored_base > 0 %}
                          {# Keep existing stored base #}
                          {{ stored_base }}
                        {% else %}
                          {# Store current setpoint as base (before offset is applied) #}
                          {{ rooms_data[repeat.item].base_target | float }}
                        {% endif %}
                  - service: climate.set_temperature
                    target:
                      entity_id: "climate.climate_room_{{ repeat.item }}"
                    data:
                      temperature: >-
                        {% set base_helper = 'input_number.heating_base_' ~ repeat.item %}
                        {% set stored_base = states(base_helper) | float(0) %}
                        {% set rd = room_data | from_json(default={}) %}
                        {% set off = rd[repeat.item].offset | float(0) %}
                        {% if stored_base > 0 %}
                          {{ stored_base + off }}
                        {% else %}
                          {{ (rd[repeat.item].base_target | float(21.5)) + off }}
                        {% endif %}
              # If offset is 0: Reset to stored base temperature (if stored)
              - conditions:
                  - condition: template
                    value_template: >-
                      {% set rd = room_data | from_json(default={}) %}
                      {{ (rd[repeat.item].offset | float(0)) == 0 }}
                sequence:
                  - service: climate.set_temperature
                    target:
                      entity_id: "climate.climate_room_{{ repeat.item }}"
                    data:
                      temperature: >-
                        {% set base_helper = 'input_number.heating_base_' ~ repeat.item %}
                        {% set stored_base = states(base_helper) | float(0) %}
                        {% if stored_base > 0 %}
                          {# Reset to stored base #}
                          {{ stored_base }}
                        {% else %}
                          {# No stored base: use current setpoint (don't change) #}
                          {% set rooms_data = room_data | from_json(default={}) %}
                          {{ rooms_data[repeat.item].base_target | float }}
                        {% endif %}
    # Log offset status
    - choose:
        - conditions:
            - condition: template
              value_template: >-
                {% set rd = room_data | from_json(default={}) %}
                {% set ns = namespace(any=false) %}
                {% for r, d in rd.items() %}
                  {% if (d.offset | float(0)) > 0 %}{% set ns.any = true %}{% endif %}
                {% endfor %}
                {{ ns.any }}
          sequence:
            - service: logbook.log
              data:
                name: "Heiz-Planer"
                message: >-
                  {% set rd = room_data | from_json(default={}) %}
                  {% set offs = rd.values() | map(attribute='offset') | list %}
                  {% set pre = rd.values() | map(attribute='preheat_offset') | list %}
                  Offset aktiv (room): total_min={{ offs|min }}K total_max={{ offs|max }}K,
                  preheat_min={{ pre|min }}K preheat_max={{ pre|max }}K,
                  PV={{ pv_offset_k | float(0) }}K
    
    # ===================================================================
    # ACTION 2: Log debug information
    # ===================================================================
    - service: logbook.log
      data:
        name: "Heiz-Planer"
        message: >-
          PreisOK={{ price_is_cheap_now }}, PVexcess={{ has_pv_excess }},
          Preheat={{ is_preheat_window }}, DayAllow={{ heating_allowed_now }},
          PriceDbg={{ price_debug }}

    # === 9) Phase-safe HVAC control =================================
    - choose:
        - conditions:
            - condition: template
              value_template: >-
                {% set rd = room_data | from_json(default={}) %}
                {% set safety = rd.values() | selectattr('must_heat') | list | count > 0 %}
                {{ heating_allowed_now or safety }}
          sequence:
            - variables:
                cap: "{{ phase_max_amps | float(16) }}"
                rd: "{{ room_data | from_json }}"

                # Übernimm die bereits berechneten Selektionen & Plans
                sel1: "{{ sel_p1 }}"
                sel2: "{{ sel_p2 }}"
                sel3: "{{ sel_p3 }}"
                planned_on: "{{ climates_on }}"
                planned_off: "{{ climates_off }}"

                # Greedy-Pack je Phase – Jinja-only (ohne .append(), nur Listen-Konkatenation)
                p1_keep: >-
                  {% set ns = namespace(load=0.0, keep=[]) %}
                  {% for r in sel1 %}
                    {% set a = rd[r]['amps'] | float(0) %}
                    {% if ns.load + a <= cap %}
                      {% set ns.load = ns.load + a %}
                      {% set ns.keep = ns.keep + [ rd[r]['entity'] ] %}
                    {% endif %}
                  {% endfor %}
                  {{ ns.keep }}

                p2_keep: >-
                  {% set ns = namespace(load=0.0, keep=[]) %}
                  {% for r in sel2 %}
                    {% set a = rd[r]['amps'] | float(0) %}
                    {% if ns.load + a <= cap %}
                      {% set ns.load = ns.load + a %}
                      {% set ns.keep = ns.keep + [ rd[r]['entity'] ] %}
                    {% endif %}
                  {% endfor %}
                  {{ ns.keep }}

                p3_keep: >-
                  {% set ns = namespace(load=0.0, keep=[]) %}
                  {% for r in sel3 %}
                    {% set a = rd[r]['amps'] | float(0) %}
                    {% if ns.load + a <= cap %}
                      {% set ns.load = ns.load + a %}
                      {% set ns.keep = ns.keep + [ rd[r]['entity'] ] %}
                    {% endif %}
                  {% endfor %}
                  {{ ns.keep }}

                phase_safe_on: "{{ p1_keep + p2_keep + p3_keep }}"
                to_off: "{{ (planned_on + planned_off) | reject('in', phase_safe_on) | list }}"
                cooldown_minutes: "{{ states('input_number.heating_cooldown_minutes')|int(10) }}"
                to_off_rooms: >-
                  {% set rooms = to_off | map('regex_replace','^climate\\.climate_room_','') | list %}
                  {% set ns = namespace(out=[]) %}
                  {% for r in rooms %}
                    {% if states('climate.climate_room_' ~ r) == 'heat' %}
                      {% set ns.out = ns.out + [r] %}
                    {% endif %}
                  {% endfor %}
                  {{ ns.out }}

            # Heat the allowed ones
            - if:
                - condition: template
                  value_template: "{{ phase_safe_on | count > 0 }}"
              then:
                - service: climate.set_hvac_mode
                  target: { entity_id: "{{ phase_safe_on }}" }
                  data: { hvac_mode: heat }

            # Off for everybody else (incl. blocked by phase cap) value_template: "{{ to_off | count > 0 }}"
            - if:
                - condition: template
                  value_template: "{{ to_off | count > 0 }}"
              then:
                - service: climate.set_hvac_mode
                  target: { entity_id: "{{ to_off }}" }
                  data: { hvac_mode: "off" }
            - if:
                - condition: template
                  value_template: "{{ to_off_rooms | count > 0 and cooldown_minutes > 0 }}"
              then:
                - repeat:
                    for_each: "{{ to_off_rooms }}"
                    sequence:
                      - service: input_datetime.set_datetime
                        target:
                          entity_id: "input_datetime.heating_cooldown_until_{{ repeat.item }}"
                        data:
                          date: "{{ (now() + timedelta(minutes=cooldown_minutes)).strftime('%Y-%m-%d') }}"
                          time: "{{ (now() + timedelta(minutes=cooldown_minutes)).strftime('%H:%M:%S') }}"

            # Optional: log how many made it per phase
            - service: logbook.log
              data:
                name: "Heiz-Planer"
                message: >-
                  Phase guard: cap={{ cap }}A |
                  P1={{ p1_keep|length }} {{ p1_keep }} |
                  P2={{ p2_keep|length }} {{ p2_keep }} |
                  P3={{ p3_keep|length }} {{ p3_keep }} |
                  planned_on={{ planned_on|length }}
      default:
        # If heating not allowed now: switch everything off
        - variables:
            cooldown_minutes: "{{ states('input_number.heating_cooldown_minutes')|int(10) }}"
            all_rooms: "{{ rooms_json | from_json(default=[]) }}"
            rooms_heating_now: >-
              {% set ns = namespace(out=[]) %}
              {% for r in all_rooms %}
                {% if states('climate.climate_room_' ~ r) == 'heat' %}
                  {% set ns.out = ns.out + [r] %}
                {% endif %}
              {% endfor %}
              {{ ns.out }}
            climates_heating_now: >-
              {{ rooms_heating_now | map('regex_replace','^(.*)$','climate.climate_room_\\1') | list }}
        - if:
            - condition: template
              value_template: "{{ climates_heating_now | count > 0 }}"
          then:
            - service: climate.set_hvac_mode
              target: { entity_id: "{{ climates_heating_now }}" }
              data: { hvac_mode: "off" }
        - if:
            - condition: template
              value_template: "{{ cooldown_minutes > 0 and rooms_heating_now | count > 0 }}"
          then:
            - repeat:
                for_each: "{{ rooms_heating_now }}"
                sequence:
                  - service: input_datetime.set_datetime
                    target:
                      entity_id: "input_datetime.heating_cooldown_until_{{ repeat.item }}"
                    data:
                      date: "{{ (now() + timedelta(minutes=cooldown_minutes)).strftime('%Y-%m-%d') }}"
                      time: "{{ (now() + timedelta(minutes=cooldown_minutes)).strftime('%H:%M:%S') }}"

