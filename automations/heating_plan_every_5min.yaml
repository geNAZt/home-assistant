- id: heating_plan_every_5min
  alias: "Heizung: Planung alle 5 Minuten (PV/Preheat/Phasen)"
  mode: single
  trigger:
    - platform: time_pattern
      minutes: "/5"
  variables:
    # ===================================================================
    # SECTION 1: CONFIGURATION & GLOBAL PARAMETERS
    # ===================================================================
    rooms_json: '["bad","kueche","schlafzimmer","flur","speisekammer","wohnzimmer","buero_merja","buero_fabian"]'
    phase_max_amps: 16.0
    hysteresis_k: 0.05
    
    # PV and preheat parameters
    pv_forecast_w: "{{ states('sensor.filtered_exported_power_w') | float(0) }}"
    pv_thr_w: "{{ states('input_number.pv_excess_threshold_w') | float(0) }}"
    has_pv_excess: "{{ pv_forecast_w > pv_thr_w }}"
    pv_offset_k: "{{ 0.5 if has_pv_excess else 0 }}"
    
    # PV-/Top-Up-Fenster: nur mittags 12–14 Uhr & nur wenn PV-Überschuss
    is_midday_topup_window: >-
      {% set nowts = as_timestamp(now()) %}
      {% set t0 = as_timestamp(now().replace(hour=12, minute=0, second=0, microsecond=0)) %}
      {% set t1 = as_timestamp(now().replace(hour=14, minute=0, second=0, microsecond=0)) %}
      {{ t0 <= nowts < t1 }}

    # Preheat-Fenster 00–06 Uhr (Preis egal)
    is_preheat_window: >-
      {% set nowts = as_timestamp(now()) %}
      {% set t0 = as_timestamp(now().replace(hour=0, minute=0, second=0, microsecond=0)) %}
      {% set t1 = as_timestamp(now().replace(hour=6, minute=0, second=0, microsecond=0)) %}
      {{ t0 <= nowts < t1 }}
    
    # Heating blocking: When enabled, only allow heating during preheat window (00:00-06:00)
    # Turn this switch ON to block heating outside preheat window
    heating_block_enabled: "{{ is_state('input_boolean.heating_block_daytime', 'on') }}"
    
    C_eff: "{{ states('sensor.C_kWh_per_K_rolling') | float(10) }}"
    H_eff: "{{ states('sensor.H_kW_per_K_effective') | float(6.25) }}"
    dT_forecast: "{{ states('input_number.delta_t_forecast_k') | float(0) }}"
    
    # Erwarteter Tages-Abkühlbetrag innen (konservativ gedämpft über H/C)
    expected_temp_drop: >-
      {% set current_outside = states('sensor.outside_temperature') | float(0) %}
      {% set forecast_attr = state_attr('weather.home', 'forecast') %}
      {% set min_forecast_outside = current_outside %}
      {% if forecast_attr is iterable %}
        {% for day in forecast_attr %}
          {% if day.templow is defined and day.templow is number %}
            {% set day_low = day.templow | float %}
            {% if day_low < min_forecast_outside %}
              {% set min_forecast_outside = day_low %}
            {% endif %}
          {% endif %}
        {% endfor %}
      {% endif %}
      {% set outside_drop = current_outside - min_forecast_outside %}
      {% if outside_drop > 0 %}
        {% set H = H_eff | float(0.03) %}
        {% set C = C_eff | float(12.93) %}
        {% set attenuation = (H * 24.0) / C %}
        {% set att = 0.15 if attenuation > 0.15 else (0.05 if attenuation < 0.05 else attenuation) %}
        {{ (outside_drop * att) | float(0) }}
      {% else %} 0 {% endif %}
    
    # Preheat-Offset (K) aus C/H und erwartetem Drop, auf 0.2–0.6 begrenzt
    preheat_offset_k: >-
      {% if not is_preheat_window %} 0
      {% else %}
        {% set C = C_eff | float(0) %}
        {% set H = H_eff | float(0) %}
        {% set hours = 6.0 %}
        {% set temp_drop = expected_temp_drop | float(0) %}
        {% if temp_drop <= 0 %}{% set temp_drop = dT_forecast | float(0) %}{% endif %}
        {% if C <= 0 or H <= 0 or temp_drop <= 0 %} 0
        {% else %}
          {% set off_raw = (C * temp_drop) / (H * hours) %}
          {% set off = 0.6 if off_raw > 0.6 else (0.2 if off_raw < 0.2 else off_raw) %}
          {{ off }}
        {% endif %}
      {% endif %}

    # ===== Tibber Preisfenster =====
    # Anteil des Tagesmax, der "billig" ist (z.B. 0.10 = unter 10% des Max-Preises)
    price_pct_of_max: "{{ states('input_number.price_percentile_cutoff')|float(0.10) }}"
    current_price_eur: "{{ states('sensor.backerstrasse_3b_strompreis')|float(99) }}"

    # Gesamt-Offset
    offset_k: >-
      {% set total = (preheat_offset_k|float(0)) + (pv_offset_k|float(0)) %}
      {% if total < 0 %} 0
      {% elif total > 0.6 %} 0.6
      {% else %} {{ total }}{% endif %}
    
    # ===================================================================
    # SECTION 2: COMPREHENSIVE ROOM DATA (Single Pass)
    # ===================================================================
    # Build all room data in one pass - no JSON parsing needed!
    room_data: >-
      {% set rooms = rooms_json | from_json(default=[]) %}
      {% set offset = offset_k | float(0) %}
      {% set hyst = hysteresis_k | float(0.05) %}
      {% set invalid_states = ['unknown', 'unavailable', 'None', ''] %}
      {% set ns = namespace(rooms = {}) %}
      
      {% for room in rooms %}
        {% set climate_entity = 'climate.climate_room_' ~ room %}
        {% set sensor_l1 = 'sensor.current_l1_' ~ room ~ '_current' %}
        {% set sensor_l2 = 'sensor.current_l2_' ~ room ~ '_current' %}
        {% set sensor_l3 = 'sensor.current_l3_' ~ room ~ '_current' %}
        
        {# Read temperatures #}
        {% set current_temp = state_attr(climate_entity, 'current_temperature') %}
        {% set current_setpoint = state_attr(climate_entity, 'temperature') %}
        
        {# Get base temperature from helper, or use current setpoint if helper doesn't exist #}
        {# This prevents offset accumulation by always using the original base temperature #}
        {% set base_helper = 'input_number.heating_base_' ~ room %}
        {% set stored_base = states(base_helper) | float(0) %}
        {% if stored_base > 0 %}
          {# Use stored base temperature (original, before any offsets) #}
          {% set base_target = stored_base %}
        {% elif current_setpoint is number %}
          {# No stored base yet, use current setpoint as base (will be stored when offset is first applied) #}
          {% set base_target = current_setpoint | float %}
        {% else %}
          {# Fallback default #}
          {% set base_target = 22.0 %}
        {% endif %}
        
        {% if current_temp is number %}
          {% set current = current_temp | float %}
        {% else %}
          {% set current = 22.0 %}
        {% endif %}
        
        {% set effective_target = base_target + offset %}
        {% set error = effective_target - current %}
        
        {# Determine phase #}
        {% set phase = 0 %}
        {% if states(sensor_l1) not in invalid_states %}
          {% set phase = 1 %}
        {% elif states(sensor_l2) not in invalid_states %}
          {% set phase = 2 %}
        {% elif states(sensor_l3) not in invalid_states %}
          {% set phase = 3 %}
        {% endif %}
        
        {# Get current consumption #}
        {% set live_current_ma = 0 %}
        {% if states(sensor_l1) not in invalid_states %}
          {% set live_current_ma = states(sensor_l1) | float(0) %}
        {% elif states(sensor_l2) not in invalid_states %}
          {% set live_current_ma = states(sensor_l2) | float(0) %}
        {% elif states(sensor_l3) not in invalid_states %}
          {% set live_current_ma = states(sensor_l3) | float(0) %}
        {% endif %}
        {% if live_current_ma > 0 %}
          {% set live_current_a = live_current_ma / 1000 %}
        {% else %}
          {% set live_current_a = 0 %}
        {% endif %}
        {% set sql_current_a = states('sensor.heater_' ~ room ~ '_max_current_a') | float(0) %}
        {% set rated_current_a = states('input_number.heater_' ~ room ~ '_rated_a') | float(0) %}
        {% if live_current_a > 0 %}
          {% set amps = live_current_a %}
        {% elif sql_current_a > 0 %}
          {% set amps = sql_current_a %}
        {% else %}
          {% set amps = rated_current_a %}
        {% endif %}
        
        {# Determine if heating is needed #}
        {% set threshold = effective_target - hyst %}
        {% set needs_heating = current < threshold %}
        
        {# Build room data structure #}
        {% set ns.rooms = ns.rooms | combine({ 
          room: {
            'entity': climate_entity,
            'current_temp': current,
            'base_target': base_target,
            'effective_target': effective_target,
            'error': error,
            'phase': phase,
            'amps': amps,
            'needs_heating': needs_heating
          }
        }) %}
      {% endfor %}
      {{ (ns.rooms | tojson) | string }}
    
    # ===================================================================
    # SECTION 3: ROOM SELECTION BY PHASE
    # ===================================================================
    # Select rooms for each phase using greedy algorithm
    sel_p1: >-
      {% set rooms_data = room_data | from_json(default={}) %}
      {% set all_rooms = rooms_json | from_json(default=[]) %}
      {% set max_amps = phase_max_amps | float(16.0) %}
      {% set ns = namespace(room_list = [], selected = []) %}
      {% for room in all_rooms %}
        {% if rooms_data[room] is defined %}
          {% set data = rooms_data[room] %}
          {% if data.phase == 1 and data.needs_heating %}
            {% set ns.room_list = ns.room_list + [{'room': room, 'error': data.error, 'amps': data.amps}] %}
          {% endif %}
        {% endif %}
      {% endfor %}
      {% set sorted = ns.room_list | sort(attribute='error', reverse=True) %}
      {% set total = 0.0 %}
      {% set max_amps_float = max_amps | float(16.0) %}
      {% for item in sorted %}
        {% set item_amps = item.amps | float(0) %}
        {% set new_total = total + item_amps %}
        {% if new_total <= max_amps_float %}
          {% set total = new_total %}
          {% set ns.selected = ns.selected + [item.room] %}
        {% endif %}
      {% endfor %}
      {{ (ns.selected | tojson) | string }}
    
    sel_p2: >-
      {% set rooms_data = room_data | from_json(default={}) %}
      {% set all_rooms = rooms_json | from_json(default=[]) %}
      {% set max_amps = phase_max_amps | float(16.0) %}
      {% set ns = namespace(room_list = [], selected = []) %}
      {% for room in all_rooms %}
        {% if rooms_data[room] is defined %}
          {% set data = rooms_data[room] %}
          {% if data.phase == 2 and data.needs_heating %}
            {% set ns.room_list = ns.room_list + [{'room': room, 'error': data.error, 'amps': data.amps}] %}
          {% endif %}
        {% endif %}
      {% endfor %}
      {% set sorted = ns.room_list | sort(attribute='error', reverse=True) %}
      {% set total = 0.0 %}
      {% set max_amps_float = max_amps | float(16.0) %}
      {% for item in sorted %}
        {% set item_amps = item.amps | float(0) %}
        {% set new_total = total + item_amps %}
        {% if new_total <= max_amps_float %}
          {% set total = new_total %}
          {% set ns.selected = ns.selected + [item.room] %}
        {% endif %}
      {% endfor %}
      {{ (ns.selected | tojson) | string }}
    
    sel_p3: >-
      {% set rooms_data = room_data | from_json(default={}) %}
      {% set all_rooms = rooms_json | from_json(default=[]) %}
      {% set max_amps = phase_max_amps | float(16.0) %}
      {% set ns = namespace(room_list = [], selected = []) %}
      {% for room in all_rooms %}
        {% if rooms_data[room] is defined %}
          {% set data = rooms_data[room] %}
          {% if data.phase == 3 and data.needs_heating %}
            {% set ns.room_list = ns.room_list + [{'room': room, 'error': data.error, 'amps': data.amps}] %}
          {% endif %}
        {% endif %}
      {% endfor %}
      {% set sorted = ns.room_list | sort(attribute='error', reverse=True) %}
      {% set total = 0.0 %}
      {% set max_amps_float = max_amps | float(16.0) %}
      {% for item in sorted %}
        {% set item_amps = item.amps | float(0) %}
        {% set new_total = total + item_amps %}
        {% if new_total <= max_amps_float %}
          {% set total = new_total %}
          {% set ns.selected = ns.selected + [item.room] %}
        {% endif %}
      {% endfor %}
      {{ (ns.selected | tojson) | string }}
    
    final_on: >-
      {% set rooms_data = room_data | from_json(default={}) %}
      {% set all_rooms = rooms_json | from_json(default=[]) %}
      {% set max_amps = phase_max_amps | float(16.0) %}
      {% set ns = namespace(final = []) %}
      {% for phase_num in [1, 2, 3] %}
        {% set ns.room_list = [] %}
        {% for room in all_rooms %}
          {% if rooms_data[room] is defined %}
            {% set data = rooms_data[room] %}
            {% if data.phase == phase_num and data.needs_heating %}
              {% set ns.room_list = ns.room_list + [{'room': room, 'error': data.error, 'amps': data.amps}] %}
            {% endif %}
          {% endif %}
        {% endfor %}
        {% set sorted = ns.room_list | sort(attribute='error', reverse=True) %}
        {% set total = 0.0 %}
        {% for item in sorted %}
          {% if total + item.amps <= max_amps %}
            {% set total = total + item.amps %}
            {% if item.room not in ns.final %}
              {% set ns.final = ns.final + [item.room] %}
            {% endif %}
          {% endif %}
        {% endfor %}
      {% endfor %}
      {{ (ns.final | tojson) | string }}
    
    # ===================================================================
    # SECTION 4: CLIMATE ENTITY MAPPING (for debug output)
    # ===================================================================
    climates_on: >-
      {% set rooms_data = room_data | from_json(default={}) %}
      {% set max_amps = phase_max_amps | float(16.0) %}
      {% set ns = namespace(selected_rooms = [], climates = []) %}
      {% for phase_num in [1, 2, 3] %}
        {% set ns.room_list = [] %}
        {% for room, data in rooms_data.items() %}
          {% if data.phase == phase_num and data.needs_heating %}
            {% set ns.room_list = ns.room_list + [{'room': room, 'error': data.error, 'amps': data.amps}] %}
          {% endif %}
        {% endfor %}
        {% set sorted = ns.room_list | sort(attribute='error', reverse=True) %}
        {% set total = 0.0 %}
        {% for item in sorted %}
          {% if total + item.amps <= max_amps %}
            {% set total = total + item.amps %}
            {% if item.room not in ns.selected_rooms %}
              {% set ns.selected_rooms = ns.selected_rooms + [item.room] %}
            {% endif %}
          {% endif %}
        {% endfor %}
      {% endfor %}
      {% for room in ns.selected_rooms %}
        {% set ns.climates = ns.climates + ['climate.climate_room_' ~ room] %}
      {% endfor %}
      {{ (ns.climates | tojson) | string }}
    
    climates_off: >-
      {% set rooms_data = room_data | from_json(default={}) %}
      {% set max_amps = phase_max_amps | float(16.0) %}
      {% set all_rooms = rooms_json | from_json(default=[]) %}
      {% set ns = namespace(selected_rooms = [], climates = []) %}
      {% for phase_num in [1, 2, 3] %}
        {% set ns.room_list = [] %}
        {% for room, data in rooms_data.items() %}
          {% if data.phase == phase_num and data.needs_heating %}
            {% set ns.room_list = ns.room_list + [{'room': room, 'error': data.error, 'amps': data.amps}] %}
          {% endif %}
        {% endfor %}
        {% set sorted = ns.room_list | sort(attribute='error', reverse=True) %}
        {% set total = 0.0 %}
        {% for item in sorted %}
          {% if total + item.amps <= max_amps %}
            {% set total = total + item.amps %}
            {% if item.room not in ns.selected_rooms %}
              {% set ns.selected_rooms = ns.selected_rooms + [item.room] %}
            {% endif %}
          {% endif %}
        {% endfor %}
      {% endfor %}
      {% for room in all_rooms %}
        {% if room not in ns.selected_rooms %}
          {% set ns.climates = ns.climates + ['climate.climate_room_' ~ room] %}
        {% endif %}
      {% endfor %}
      {{ (ns.climates | tojson) | string }}
  
  condition: []
  action:
    # 1) Tagespreise laden
    - service: tibber.get_prices
      data:
        start: "{{ now().strftime('%Y-%m-%d %H:00:00') }}"
        end:   "{{ (now() + timedelta(hours=24)).strftime('%Y-%m-%d %H:00:00') }}"
      response_variable: tibber_resp

    # 2) Preis-Gate bestimmen (robuste Extraktion + Perzentil, ohne from_json)
    - variables:
        # 2.1 Rohdaten -> einheitliches Array [{price: ..., start_time: ...}, ...]
        tib_prices_arr: >-
          {% set raw = tibber_resp %}
          {% set arr = [] %}
          {% if raw is mapping and 'prices' in raw and (raw['prices'] is mapping) %}
            {% set first_key = (raw['prices'].keys() | list | first) %}
            {% if first_key %}
              {% set arr = raw['prices'][first_key] %}
            {% endif %}
          {% elif raw is sequence %}
            {% set arr = raw %}
          {% endif %}
          {{ arr }}

        # 2.2 Perzentil-Schwelle (unteres x-Perzentil des Tages)
        price_quantile_thr: >-
          {% set items = tib_prices_arr if tib_prices_arr is sequence else [] %}
          {% set prices = items | map(attribute='price') | select('number') | list %}
          {% if prices | length == 0 %}
            {{ none }}
          {% else %}
            {# Eingabe kann 0–1 oder 0–100 sein #}
            {% set p = states('input_number.price_percentile_cutoff') | float(0.10) %}
            {% if p > 1 %}{% set p = p / 100 %}{% endif %}
            {% set p = 0 if p < 0 else (1 if p > 1 else p) %}
            {% set sorted = prices | sort %}
            {% set idx = ((sorted | length - 1) * p) | round(0, 'floor') %}
            {{ sorted[idx] }}
          {% endif %}

        # 2.3 Ist der aktuelle Preis günstig?
        price_is_cheap_now: >-
          {% if price_quantile_thr is number %}
            {{ states('sensor.backerstrasse_3b_strompreis') | float(999) <= price_quantile_thr }}
          {% else %}
            {{ is_state('input_boolean.heating_ignore_price','on') }}
          {% endif %}

        # Optional: kompaktes Preis-Debug fürs Log
        price_debug: >-
          {% set items = tib_prices_arr if tib_prices_arr is sequence else [] %}
          {% set prs = items | map(attribute='price') | select('number') | list %}
          {% if prs | length == 0 %}
            {{ {'n': 0} | tojson }}
          {% else %}
            {{ {'n': prs|length, 'min': (prs|min), 'max': (prs|max), 'thr': price_quantile_thr} | tojson }}
          {% endif %}


    # 2b) Pmax/Threshold in Helper schreiben (für die UI-Sichtkontrolle)
    - variables:
        pmax_eur: >-
          {% set lst = tib_prices|from_json(default=[]) %}
          {% if lst|length > 0 %}
            {{ (lst | map(attribute='price') | list | max) }}
          {% else %} 0 {% endif %}
        thr_eur: >-
          {% set pct = states('input_number.price_percentile_cutoff')|float(0.10) %}
          {{ (pmax_eur|float(0)) * pct }}

    - service: input_number.set_value
      target: { entity_id: input_number.tibber_pmax_today }
      data:
        value: "{{ pmax_eur|float(0) }}"

    - service: input_number.set_value
      target: { entity_id: input_number.tibber_threshold_today }
      data:
        value: "{{ thr_eur|float(0) }}"

    # 3) Endgültiges Heizerlaubnis
    - variables:
        # tagsüber nur, wenn (Preis günstig) ODER (12–14 & PV-Excess)
        allow_daytime_heat: >-
          {% set topup_ok = (is_midday_topup_window and has_pv_excess) %}
          {{ price_is_cheap_now or topup_ok }}
        heating_allowed_now: >-
          {% if is_preheat_window %} true
          {% elif heating_block_enabled %} false
          {% else %} {{ allow_daytime_heat }}
          {% endif %}
    # ===================================================================
    # ACTION 1: Update temperature setpoints based on offset (always executed)
    # ===================================================================
    # Store base temperatures and apply/reset offsets (always, regardless of blocking)
    - repeat:
        for_each: "{{ rooms_json | from_json(default=[]) }}"
        sequence:
          - choose:
              # If offset is active: Store base temp (if not stored) and apply offset
              - conditions:
                  - condition: template
                    value_template: "{{ offset_k | float(0) > 0 }}"
                sequence:
                  - service: input_number.set_value
                    target:
                      entity_id: "input_number.heating_base_{{ repeat.item }}"
                    data:
                      value: >-
                        {% set base_helper = 'input_number.heating_base_' ~ repeat.item %}
                        {% set stored_base = states(base_helper) | float(0) %}
                        {% set rooms_data = room_data | from_json(default={}) %}
                        {% if stored_base > 0 %}
                          {# Keep existing stored base #}
                          {{ stored_base }}
                        {% else %}
                          {# Store current setpoint as base (before offset is applied) #}
                          {{ rooms_data[repeat.item].base_target | float }}
                        {% endif %}
                  - service: climate.set_temperature
                    target:
                      entity_id: "climate.climate_room_{{ repeat.item }}"
                    data:
                      temperature: >-
                        {% set base_helper = 'input_number.heating_base_' ~ repeat.item %}
                        {% set stored_base = states(base_helper) | float(0) %}
                        {% set offset = offset_k | float(0) %}
                        {% if stored_base > 0 %}
                          {# Use stored base + offset #}
                          {{ stored_base + offset }}
                        {% else %}
                          {# Fallback: use calculated effective target #}
                          {% set rooms_data = room_data | from_json(default={}) %}
                          {{ rooms_data[repeat.item].effective_target | float }}
                        {% endif %}
              # If offset is 0: Reset to stored base temperature (if stored)
              - conditions:
                  - condition: template
                    value_template: "{{ offset_k | float(0) == 0 }}"
                sequence:
                  - service: climate.set_temperature
                    target:
                      entity_id: "climate.climate_room_{{ repeat.item }}"
                    data:
                      temperature: >-
                        {% set base_helper = 'input_number.heating_base_' ~ repeat.item %}
                        {% set stored_base = states(base_helper) | float(0) %}
                        {% if stored_base > 0 %}
                          {# Reset to stored base #}
                          {{ stored_base }}
                        {% else %}
                          {# No stored base: use current setpoint (don't change) #}
                          {% set rooms_data = room_data | from_json(default={}) %}
                          {{ rooms_data[repeat.item].base_target | float }}
                        {% endif %}
    # Log offset status
    - choose:
        - conditions:
            - condition: template
              value_template: "{{ offset_k | float(0) > 0 }}"
          sequence:
            - service: logbook.log
              data:
                name: "Heiz-Planer"
                message: "Offset aktiv: {{ offset_k | float(0) }}K (PV: {{ pv_offset_k | float(0) }}K, Preheat: {{ preheat_offset_k | float(0) }}K)"
    
    # ===================================================================
    # ACTION 2: Log debug information
    # ===================================================================
    - service: logbook.log
      data:
        name: "Heiz-Planer"
        message: >-
          Offset={{ offset_k|float(0) }}K (PV={{ pv_offset_k|float(0) }} / Preheat={{ preheat_offset_k|float(0) }}),
          PreisOK={{ price_is_cheap_now }}, PVexcess={{ has_pv_excess }},
          Preheat={{ is_preheat_window }}, DayAllow={{ heating_allowed_now }},
          PriceDbg={{ price_debug }}

    # === 9) Phase-safe HVAC control =================================
    - choose:
        - conditions:
            - condition: template
              value_template: "{{ heating_allowed_now | string == 'true' }}"
          sequence:
            # Build phase-safe lists from selections (enforce per-phase amps)
            - variables:
                cap: "{{ phase_max_amps | float(16) }}"
                rd: "{{ room_data | from_json }}"
                p1_keep: >-
                  {% set ns = namespace(load=0, keep=[]) %}
                  {% for r in sel_p1 %}
                    {% set a = rd[r]['amps'] | float(0) %}
                    {% if ns.load + a <= cap %}
                      {% set ns.load = ns.load + a %}
                      {% set _ = ns.keep.append('climate.climate_room_' ~ r) %}
                    {% endif %}
                  {% endfor %}
                  {{ ns.keep }}
                p2_keep: >-
                  {% set ns = namespace(load=0, keep=[]) %}
                  {% for r in sel_p2 %}
                    {% set a = rd[r]['amps'] | float(0) %}
                    {% if ns.load + a <= cap %}
                      {% set ns.load = ns.load + a %}
                      {% set _ = ns.keep.append('climate.climate_room_' ~ r) %}
                    {% endif %}
                  {% endfor %}
                  {{ ns.keep }}
                p3_keep: >-
                  {% set ns = namespace(load=0, keep=[]) %}
                  {% for r in sel_p3 %}
                    {% set a = rd[r]['amps'] | float(0) %}
                    {% if ns.load + a <= cap %}
                      {% set ns.load = ns.load + a %}
                      {% set _ = ns.keep.append('climate.climate_room_' ~ r) %}
                    {% endif %}
                  {% endfor %}
                  {{ ns.keep }}
                phase_safe_on: "{{ p1_keep + p2_keep + p3_keep }}"
                # Everything planned but not allowed by phase guard must be off
                planned_on: "{{ climates_on }}"
                planned_off: "{{ climates_off }}"
                to_off: >-
                  {{ (planned_on + planned_off) | reject('in', phase_safe_on) | list }}

            # Heat the allowed ones
            - if:
                - condition: template
                  value_template: "{{ phase_safe_on | count > 0 }}"
              then:
                - service: climate.set_hvac_mode
                  target: { entity_id: "{{ phase_safe_on }}" }
                  data: { hvac_mode: heat }

            # Off for everybody else (incl. blocked by phase cap)
            - if:
                - condition: template
                  value_template: "{{ to_off | count > 0 }}"
              then:
                - service: climate.set_hvac_mode
                  target: { entity_id: "{{ to_off }}" }
                  data: { hvac_mode: "off" }

            # Optional: log how many made it per phase
            - service: logbook.log
              data:
                name: Heiz-Planer
                message: >-
                  Phase guard: cap={{ cap }}A | P1={{ p1_keep|count }} | P2={{ p2_keep|count }} | P3={{ p3_keep|count }}
      default:
        # If heating not allowed now: switch everything off
        - service: climate.set_hvac_mode
          target: { entity_id: "{{ climates_on + climates_off }}" }
          data: { hvac_mode: "off" }

